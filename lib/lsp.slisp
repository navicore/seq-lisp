; SeqLisp Language Server Protocol Implementation
; Implements LSP lifecycle via JSON-RPC 2.0 over stdin/stdout
;
; Supported methods:
;   initialize, initialized, shutdown, exit
;   textDocument/didOpen, textDocument/didChange
;
; Features:
;   - Real-time diagnostics with line/column positions
;   - Paren balance checking (detects ALL unmatched parens)
;   - Uses eval-all-with-errors for semantic validation of ALL expressions
;
; Limitations:
;   - Evaluation runs without timeout or resource limits.

(define (string-starts-with? str prefix)
  (if (< (string-length str) (string-length prefix)) #f
    (equal? (substring str 0 (string-length prefix)) prefix)))

; Note: \r escape is now supported by the tokenizer (issue #38 resolved)
; io.read-line+ normalizes CRLF to LF, but explicit \r check handles edge cases
(define (string-blank? str)
  (if (equal? str "") #t
    (if (equal? str "\n") #t
      (if (equal? str "\r") #t
        (equal? str "\r\n")))))

(define (assoc key alist)
  (if (null? alist) (list key '())
    (if (equal? (car (car alist)) key)
      (car alist)
      (assoc key (cdr alist)))))

(define (assoc-val key alist)
  (car (cdr (assoc key alist))))

; ============================================
; Paren balance checking
; ============================================

; Get character at position in string
(define (char-at str pos)
  (if (>= pos (string-length str))
      ""
      (substring str pos 1)))

; Count paren balance: returns (opens - closes)
; Positive = need more closing, Negative = too many closes, Zero = balanced
(define (paren-balance-loop str pos balance)
  (if (>= pos (string-length str))
      balance
      (let ch (char-at str pos)
        (if (equal? ch "(")
            (paren-balance-loop str (+ pos 1) (+ balance 1))
            (if (equal? ch ")")
                (paren-balance-loop str (+ pos 1) (- balance 1))
                (paren-balance-loop str (+ pos 1) balance))))))

(define (paren-balance str)
  (paren-balance-loop str 0 0))

; Find ALL unmatched parens, not just the first
; Returns list of (line col type) where type is "open" or "close"
; open-stack is list of (line col) for each unclosed '('
; errors is accumulated list of error positions
; NOTE: This is a simple character-based scanner that does not handle
; parens inside string literals (e.g., "(foo \"a(b)c\" bar)"). In practice,
; if parens are balanced inside strings, the overall count remains correct.
; Semantic validation via eval-all-with-errors will catch actual syntax errors.
(define (find-all-unmatched-loop str pos line col open-stack errors)
  (if (>= pos (string-length str))
      ; End of string - all remaining open parens are unmatched
      (append errors (map (lambda (p) (list (car p) (car (cdr p)) "open")) open-stack))
      (let ch (char-at str pos)
        (if (equal? ch "\n")
            (find-all-unmatched-loop str (+ pos 1) (+ line 1) 0 open-stack errors)
            (if (equal? ch "(")
                ; Push position onto open stack
                (find-all-unmatched-loop str (+ pos 1) line (+ col 1)
                                         (cons (list line col) open-stack) errors)
                (if (equal? ch ")")
                    (if (null? open-stack)
                        ; Extra close paren - add to errors
                        (find-all-unmatched-loop str (+ pos 1) line (+ col 1)
                                                 open-stack
                                                 (cons (list line col "close") errors))
                        ; Matched - pop from stack
                        (find-all-unmatched-loop str (+ pos 1) line (+ col 1)
                                                 (cdr open-stack) errors))
                    (find-all-unmatched-loop str (+ pos 1) line (+ col 1) open-stack errors)))))))

(define (find-all-unmatched-parens str)
  (find-all-unmatched-loop str 0 0 0 '() '()))

; ============================================
; Error handling helpers
; ============================================

; Check if try result is an error: (error message)
(define (try-error? val)
  (if (list? val)
      (if (null? val) #f
          (equal? (car val) 'error))
      #f))

; Extract value from (ok value)
(define (try-value val)
  (car (cdr val)))

; Extract error message from (error message)
(define (try-error-message val)
  (if (try-error? val)
      (car (cdr val))
      "Unknown error"))

; ============================================
; LSP I/O
; ============================================

; Maximum allowed message size (10MB) to prevent memory exhaustion
(define *max-content-length* 10485760)

; Find index of newline in string, or -1 if not found
(define (find-newline-loop str idx len)
  (if (>= idx len)
      -1
      (if (equal? (substring str idx (+ idx 1)) "\n")
          idx
          (find-newline-loop str (+ idx 1) len))))

(define (find-newline str)
  (find-newline-loop str 0 (string-length str)))

; Read a line, using buffer first if available
; Returns (list line remaining-buffer)
(define (read-line-from-buffer buffer)
  (if (equal? buffer "")
      ; Buffer empty - just read from stdin
      (let line (read-line)
        (if (equal? line #f)
            (list #f "")
            (list line "")))
      ; Check if buffer has a complete line
      (let nl-idx (find-newline buffer)
        (if (< nl-idx 0)
            ; No newline in buffer - read more and combine
            (let line (read-line)
              (if (equal? line #f)
                  (list buffer "")  ; Return buffer as final partial line
                  (list (string-append buffer line) "")))
            ; Found newline - split buffer
            (let buf-len (string-length buffer)
              (list (substring buffer 0 (+ nl-idx 1))
                    (substring buffer (+ nl-idx 1) buf-len)))))))

; Read headers with buffer support, returns (list content-length remaining-buffer)
; The seen-header flag tracks if we've seen any header (including Content-Length)
; Blank lines before headers are skipped (may come from file newlines after body)
; Blank line after headers signals end of headers
; Returns -1 if Content-Length is missing or invalid
(define (lsp-read-headers-loop content-length buffer seen-header)
  (let result (read-line-from-buffer buffer)
    (let line (car result)
      (let new-buffer (car (cdr result))
        (if (equal? line #f) (list -1 "")
          (if (string-blank? line)
              ; Blank line: if we've seen headers, this ends headers; otherwise skip it
              (if seen-header
                  ; Validate that we actually received a valid Content-Length
                  (if (> content-length 0)
                      (list content-length new-buffer)
                      (list -1 new-buffer))  ; Missing or zero Content-Length
                  (lsp-read-headers-loop content-length new-buffer #f))
            (if (string-starts-with? line "Content-Length:")
              ; Extract Content-Length value: skip "Content-Length: " (16 chars), take remaining minus newline
              ; Minimum valid line is "Content-Length: X\n" (18 chars)
              (if (< (string-length line) 18)
                  (list -1 new-buffer)  ; Malformed Content-Length header
                  (let parsed-length (json-parse (substring line 16 (- (string-length line) 17)))
                    ; Reject oversized messages
                    (if (> parsed-length *max-content-length*)
                        (list -1 new-buffer)
                        (lsp-read-headers-loop parsed-length new-buffer #t))))
              ; Other header (Content-Type, etc) - mark as seen and continue
              (lsp-read-headers-loop content-length new-buffer #t))))))))

(define (lsp-read-headers buffer) (lsp-read-headers-loop 0 buffer #f))

; Read message body of given length
; Uses read-n to read exactly the required number of bytes (no newline buffering issues)
; Returns the body as a string, or #f on EOF
(define (lsp-read-body length buffer)
  (let buf-len (string-length buffer)
    (if (>= buf-len length)
        ; Buffer has all the data we need - unlikely but handle it
        (substring buffer 0 length)
        ; Need to read more bytes from stdin
        (let remaining (- length buf-len)
          (let data (read-n remaining)
            (if (equal? data #f)
                #f  ; EOF
                (string-append buffer data)))))))

(define (lsp-send response)
  (let json-str (json-encode response)
    (let content-length (string-length json-str)
      (let header (string-append "Content-Length: " (json-encode content-length) "\r\n\r\n")
        (display (string-append header json-str))))))

; Send JSON-RPC error response
(define (lsp-send-error id code message)
  (lsp-send
    (list (list "jsonrpc" "2.0")
          (list "id" id)
          (list "error"
            (list (list "code" code)
                  (list "message" message))))))

; ============================================
; Diagnostics
; ============================================

; Make a position object {line, character}
; Note: LSP uses 0-based line/column numbers
(define (make-position line col)
  (list (list "line" line)
        (list "character" col)))

; Make a range object {start, end}
(define (make-range start-line start-col end-line end-col)
  (list (list "start" (make-position start-line start-col))
        (list "end" (make-position end-line end-col))))

; Make a diagnostic object
; Severity: 1=Error, 2=Warning, 3=Info, 4=Hint
(define (make-diagnostic range severity message)
  (list (list "range" range)
        (list "severity" severity)
        (list "message" message)))

; Publish diagnostics to client
(define (publish-diagnostics uri diagnostics)
  (lsp-send
    (list (list "jsonrpc" "2.0")
          (list "method" "textDocument/publishDiagnostics")
          (list "params"
            (list (list "uri" uri)
                  (list "diagnostics" diagnostics))))))

; Check if eval result is an error: (error message line col end-line end-col)
(define (eval-error? result)
  (if (list? result)
      (if (null? result) #f
          (equal? (car result) 'error))
      #f))

; Safe nth accessor - returns default if index out of bounds
(define (safe-nth n lst default)
  (if (null? lst)
      default
      (if (= n 0)
          (car lst)
          (safe-nth (- n 1) (cdr lst) default))))

; Extract error message from (error message line col end-line end-col)
; Returns "Unknown error" if malformed
(define (eval-error-message result)
  (safe-nth 1 result "Unknown error"))

; Extract start line from error result (convert to 0-based)
; Returns 0 if malformed
(define (eval-error-line result)
  (let val (safe-nth 2 result 1)
    (if (number? val) (- val 1) 0)))

; Extract start column from error result (convert to 0-based)
; Returns 0 if malformed
(define (eval-error-col result)
  (let val (safe-nth 3 result 1)
    (if (number? val) (- val 1) 0)))

; Extract end line from error result (convert to 0-based)
; Returns 0 if malformed
(define (eval-error-end-line result)
  (let val (safe-nth 4 result 1)
    (if (number? val) (- val 1) 0)))

; Extract end column from error result (convert to 0-based)
; Returns 0 if malformed
(define (eval-error-end-col result)
  (let val (safe-nth 5 result 1)
    (if (number? val) (- val 1) 0)))

; Convert a paren error (line col type) to a diagnostic
(define (paren-error-to-diagnostic err)
  (let line (car err)
    (let col (car (cdr err))
      (let type (car (cdr (cdr err)))
        (let msg (if (equal? type "open")
                     "Syntax error: unmatched '(' - missing closing parenthesis"
                     "Syntax error: unexpected ')' - extra closing parenthesis")
          (make-diagnostic
            (make-range line col line (+ col 1))
            1  ; Severity: Error
            msg))))))

; Validate document text and return list of diagnostics
; First checks paren balance, then uses eval-all-with-errors to evaluate all expressions
(define (validate-document text)
  (let balance (paren-balance text)
    (if (= balance 0)
        ; Balanced parens - try to evaluate all expressions
        (let result (eval-all-with-errors text)
          (if (eval-error? result)
              ; Create a diagnostic from the error
              (let msg (eval-error-message result)
                (let start-line (eval-error-line result)
                  (let start-col (eval-error-col result)
                    (let end-line (eval-error-end-line result)
                      (let end-col (eval-error-end-col result)
                        (list (make-diagnostic
                                (make-range start-line start-col end-line end-col)
                                1  ; Severity: Error
                                msg)))))))
              ; No error - return empty diagnostics
              (list)))
        ; Unbalanced parens - report ALL unmatched parens
        (let errors (find-all-unmatched-parens text)
          (map paren-error-to-diagnostic errors)))))

; Handle document open - validate and publish diagnostics
(define (handle-did-open params)
  (let text-doc (assoc-val 'textDocument params)
    (if (null? text-doc)
        '()
        (let uri (assoc-val 'uri text-doc)
          (if (null? uri)
              '()
              (let text (assoc-val 'text text-doc)
                (publish-diagnostics uri (validate-document text))))))))

; Handle document change - validate and publish diagnostics
; Using full document sync (textDocumentSync: 1)
(define (handle-did-change params)
  (let text-doc (assoc-val 'textDocument params)
    (if (null? text-doc)
        '()
        (let uri (assoc-val 'uri text-doc)
          (if (null? uri)
              '()
              (let changes (assoc-val 'contentChanges params)
                ; With full sync, changes is a list with one element containing the full text
                (if (null? changes)
                    '()
                    (let change (car changes)
                      (let text (assoc-val 'text change)
                        (publish-diagnostics uri (validate-document text)))))))))))

; ============================================
; LSP Dispatch
; ============================================

(define (lsp-dispatch msg)
  (let method (assoc-val 'method msg)
    (let id (assoc-val 'id msg)
      (let params (assoc-val 'params msg)
        (cond
          ((equal? method "initialize")
           (lsp-send
             (list (list "jsonrpc" "2.0")
                   (list "id" id)
                   (list "result"
                     (list (list "capabilities"
                             (list (list "textDocumentSync" 1)))
                           (list "serverInfo"
                             (list (list "name" "seqlisp-lsp")
                                   (list "version" "0.1.0"))))))))
          ((equal? method "initialized") '())
          ((equal? method "shutdown")
           (lsp-send
             (list (list "jsonrpc" "2.0")
                   (list "id" id)
                   (list "result" '()))))
          ((equal? method "exit") (exit 0))
          ((equal? method "textDocument/didOpen")
           (handle-did-open params))
          ((equal? method "textDocument/didChange")
           (handle-did-change params))
          (else
            ; For unknown methods: notifications (no id) are ignored, requests get error
            (if (null? id)
                '()
                (lsp-send-error id -32601 "Method not found"))))))))

; ============================================
; Main Loop
; ============================================

; Main loop with buffer threading
; Buffer holds leftover bytes from header reading that belong to body
; After body reading with read-n, no leftover exists so next message starts fresh
(define (lsp-loop-with-buffer buffer)
  (let header-result (lsp-read-headers buffer)
    (let cl (car header-result)
      (let header-buffer (car (cdr header-result))
        (if (<= cl 0)
            '()
            (let body (lsp-read-body cl header-buffer)
              (if (equal? body #f)
                  '()  ; EOF
                  (let parse-result (try (json-parse body))
                    (if (try-error? parse-result)
                        ; Parse error - send error response and continue
                        (begin
                          (lsp-send-error '() -32700 "Parse error")
                          (lsp-loop-with-buffer ""))
                        ; Success - extract value and dispatch
                        (let msg (try-value parse-result)
                          (begin
                            (lsp-dispatch msg)
                            (lsp-loop-with-buffer ""))))))))))))

(define (lsp-loop) (lsp-loop-with-buffer ""))

(lsp-loop)
