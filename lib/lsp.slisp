; SeqLisp Language Server Protocol Implementation
; Implements LSP lifecycle via JSON-RPC 2.0 over stdin/stdout
;
; Supported methods:
;   initialize, initialized, shutdown, exit
;   textDocument/didOpen, textDocument/didChange
;   textDocument/completion
;   textDocument/documentSymbol
;
; Features:
;   - Real-time diagnostics with line/column positions
;   - Paren balance checking (detects ALL unmatched parens)
;   - Uses eval-all-with-errors for semantic validation of ALL expressions
;   - Code completion for all builtins
;   - Document symbols for outline/navigation (Ctrl+Shift+O in VSCode)
;
; Limitations:
;   - Evaluation runs without timeout or resource limits.
;   - Completion only includes builtins (not user-defined symbols)

(define (string-starts-with? str prefix)
  (if (< (string-length str) (string-length prefix)) #f
    (equal? (substring str 0 (string-length prefix)) prefix)))

; Note: \r escape is now supported by the tokenizer (issue #38 resolved)
; io.read-line+ normalizes CRLF to LF, but explicit \r check handles edge cases
(define (string-blank? str)
  (if (equal? str "") #t
    (if (equal? str "\n") #t
      (if (equal? str "\r") #t
        (equal? str "\r\n")))))

(define (assoc key alist)
  (if (null? alist) (list key '())
    (if (equal? (car (car alist)) key)
      (car alist)
      (assoc key (cdr alist)))))

(define (assoc-val key alist)
  (car (cdr (assoc key alist))))

; ============================================
; Paren balance checking
; ============================================

; Get character at position in string
(define (char-at str pos)
  (if (>= pos (string-length str))
      ""
      (substring str pos 1)))

; Count paren balance: returns (opens - closes)
; Positive = need more closing, Negative = too many closes, Zero = balanced
(define (paren-balance-loop str pos balance)
  (if (>= pos (string-length str))
      balance
      (let ch (char-at str pos)
        (if (equal? ch "(")
            (paren-balance-loop str (+ pos 1) (+ balance 1))
            (if (equal? ch ")")
                (paren-balance-loop str (+ pos 1) (- balance 1))
                (paren-balance-loop str (+ pos 1) balance))))))

(define (paren-balance str)
  (paren-balance-loop str 0 0))

; Find ALL unmatched parens, not just the first
; Returns list of (line col type) where type is "open" or "close"
; open-stack is list of (line col) for each unclosed '('
; errors is accumulated list of error positions
; NOTE: This is a simple character-based scanner that does not handle
; parens inside string literals (e.g., "(foo \"a(b)c\" bar)"). In practice,
; if parens are balanced inside strings, the overall count remains correct.
; Semantic validation via eval-all-with-errors will catch actual syntax errors.
(define (find-all-unmatched-loop str pos line col open-stack errors)
  (if (>= pos (string-length str))
      ; End of string - all remaining open parens are unmatched
      (append errors (map (lambda (p) (list (car p) (car (cdr p)) "open")) open-stack))
      (let ch (char-at str pos)
        (if (equal? ch "\n")
            (find-all-unmatched-loop str (+ pos 1) (+ line 1) 0 open-stack errors)
            (if (equal? ch "(")
                ; Push position onto open stack
                (find-all-unmatched-loop str (+ pos 1) line (+ col 1)
                                         (cons (list line col) open-stack) errors)
                (if (equal? ch ")")
                    (if (null? open-stack)
                        ; Extra close paren - add to errors
                        (find-all-unmatched-loop str (+ pos 1) line (+ col 1)
                                                 open-stack
                                                 (cons (list line col "close") errors))
                        ; Matched - pop from stack
                        (find-all-unmatched-loop str (+ pos 1) line (+ col 1)
                                                 (cdr open-stack) errors))
                    (find-all-unmatched-loop str (+ pos 1) line (+ col 1) open-stack errors)))))))

(define (find-all-unmatched-parens str)
  (find-all-unmatched-loop str 0 0 0 '() '()))

; ============================================
; Error handling helpers
; ============================================

; Check if try result is an error: (error message)
(define (try-error? val)
  (if (list? val)
      (if (null? val) #f
          (equal? (car val) 'error))
      #f))

; Extract value from (ok value)
(define (try-value val)
  (car (cdr val)))

; Extract error message from (error message)
(define (try-error-message val)
  (if (try-error? val)
      (car (cdr val))
      "Unknown error"))

; ============================================
; LSP I/O
; ============================================

; Maximum allowed message size (10MB) to prevent memory exhaustion
(define *max-content-length* 10485760)

; Find index of newline in string, or -1 if not found
(define (find-newline-loop str idx len)
  (if (>= idx len)
      -1
      (if (equal? (substring str idx (+ idx 1)) "\n")
          idx
          (find-newline-loop str (+ idx 1) len))))

(define (find-newline str)
  (find-newline-loop str 0 (string-length str)))

; Read a line, using buffer first if available
; Returns (list line remaining-buffer)
(define (read-line-from-buffer buffer)
  (if (equal? buffer "")
      ; Buffer empty - just read from stdin
      (let line (read-line)
        (if (equal? line #f)
            (list #f "")
            (list line "")))
      ; Check if buffer has a complete line
      (let nl-idx (find-newline buffer)
        (if (< nl-idx 0)
            ; No newline in buffer - read more and combine
            (let line (read-line)
              (if (equal? line #f)
                  (list buffer "")  ; Return buffer as final partial line
                  (list (string-append buffer line) "")))
            ; Found newline - split buffer
            (let buf-len (string-length buffer)
              (list (substring buffer 0 (+ nl-idx 1))
                    (substring buffer (+ nl-idx 1) buf-len)))))))

; Read headers with buffer support, returns (list content-length remaining-buffer)
; The seen-header flag tracks if we've seen any header (including Content-Length)
; Blank lines before headers are skipped (may come from file newlines after body)
; Blank line after headers signals end of headers
; Returns -1 if Content-Length is missing or invalid
(define (lsp-read-headers-loop content-length buffer seen-header)
  (let result (read-line-from-buffer buffer)
    (let line (car result)
      (let new-buffer (car (cdr result))
        (if (equal? line #f) (list -1 "")
          (if (string-blank? line)
              ; Blank line: if we've seen headers, this ends headers; otherwise skip it
              (if seen-header
                  ; Validate that we actually received a valid Content-Length
                  (if (> content-length 0)
                      (list content-length new-buffer)
                      (list -1 new-buffer))  ; Missing or zero Content-Length
                  (lsp-read-headers-loop content-length new-buffer #f))
            (if (string-starts-with? line "Content-Length:")
              ; Extract Content-Length value: skip "Content-Length: " (16 chars), take remaining minus newline
              ; Minimum valid line is "Content-Length: X\n" (18 chars)
              (if (< (string-length line) 18)
                  (list -1 new-buffer)  ; Malformed Content-Length header
                  (let parsed-length (json-parse (substring line 16 (- (string-length line) 17)))
                    ; Reject oversized messages
                    (if (> parsed-length *max-content-length*)
                        (list -1 new-buffer)
                        (lsp-read-headers-loop parsed-length new-buffer #t))))
              ; Other header (Content-Type, etc) - mark as seen and continue
              (lsp-read-headers-loop content-length new-buffer #t))))))))

(define (lsp-read-headers buffer) (lsp-read-headers-loop 0 buffer #f))

; Read message body of given length
; Uses read-n to read exactly the required number of bytes (no newline buffering issues)
; Returns the body as a string, or #f on EOF
(define (lsp-read-body length buffer)
  (let buf-len (string-length buffer)
    (if (>= buf-len length)
        ; Buffer has all the data we need - unlikely but handle it
        (substring buffer 0 length)
        ; Need to read more bytes from stdin
        (let remaining (- length buf-len)
          (let data (read-n remaining)
            (if (equal? data #f)
                #f  ; EOF
                (string-append buffer data)))))))

(define (lsp-send response)
  (let json-str (json-encode response)
    (let content-length (string-length json-str)
      (let header (string-append "Content-Length: " (json-encode content-length) "\r\n\r\n")
        (display (string-append header json-str))))))

; Send JSON-RPC error response
(define (lsp-send-error id code message)
  (lsp-send
    (list (list "jsonrpc" "2.0")
          (list "id" id)
          (list "error"
            (list (list "code" code)
                  (list "message" message))))))

; ============================================
; Diagnostics
; ============================================

; Make a position object {line, character}
; Note: LSP uses 0-based line/column numbers
(define (make-position line col)
  (list (list "line" line)
        (list "character" col)))

; Make a range object {start, end}
(define (make-range start-line start-col end-line end-col)
  (list (list "start" (make-position start-line start-col))
        (list "end" (make-position end-line end-col))))

; Make a diagnostic object
; Severity: 1=Error, 2=Warning, 3=Info, 4=Hint
(define (make-diagnostic range severity message)
  (list (list "range" range)
        (list "severity" severity)
        (list "message" message)))

; Publish diagnostics to client
(define (publish-diagnostics uri diagnostics)
  (lsp-send
    (list (list "jsonrpc" "2.0")
          (list "method" "textDocument/publishDiagnostics")
          (list "params"
            (list (list "uri" uri)
                  (list "diagnostics" diagnostics))))))

; Check if eval result is an error: (error message line col end-line end-col)
(define (eval-error? result)
  (if (list? result)
      (if (null? result) #f
          (equal? (car result) 'error))
      #f))

; Safe nth accessor - returns default if index out of bounds
(define (safe-nth n lst default)
  (if (null? lst)
      default
      (if (= n 0)
          (car lst)
          (safe-nth (- n 1) (cdr lst) default))))

; Extract error message from (error message line col end-line end-col)
; Returns "Unknown error" if malformed
(define (eval-error-message result)
  (safe-nth 1 result "Unknown error"))

; Extract start line from error result (convert to 0-based)
; Returns 0 if malformed
(define (eval-error-line result)
  (let val (safe-nth 2 result 1)
    (if (number? val) (- val 1) 0)))

; Extract start column from error result (convert to 0-based)
; Returns 0 if malformed
(define (eval-error-col result)
  (let val (safe-nth 3 result 1)
    (if (number? val) (- val 1) 0)))

; Extract end line from error result (convert to 0-based)
; Returns 0 if malformed
(define (eval-error-end-line result)
  (let val (safe-nth 4 result 1)
    (if (number? val) (- val 1) 0)))

; Extract end column from error result (convert to 0-based)
; Returns 0 if malformed
(define (eval-error-end-col result)
  (let val (safe-nth 5 result 1)
    (if (number? val) (- val 1) 0)))

; Convert a paren error (line col type) to a diagnostic
(define (paren-error-to-diagnostic err)
  (let line (car err)
    (let col (car (cdr err))
      (let type (car (cdr (cdr err)))
        (let msg (if (equal? type "open")
                     "Syntax error: unmatched '(' - missing closing parenthesis"
                     "Syntax error: unexpected ')' - extra closing parenthesis")
          (make-diagnostic
            (make-range line col line (+ col 1))
            1  ; Severity: Error
            msg))))))

; Validate document text and return list of diagnostics
; First checks paren balance, then uses eval-all-with-errors to evaluate all expressions
(define (validate-document text)
  (let balance (paren-balance text)
    (if (= balance 0)
        ; Balanced parens - try to evaluate all expressions
        (let result (eval-all-with-errors text)
          (if (eval-error? result)
              ; Create a diagnostic from the error
              (let msg (eval-error-message result)
                (let start-line (eval-error-line result)
                  (let start-col (eval-error-col result)
                    (let end-line (eval-error-end-line result)
                      (let end-col (eval-error-end-col result)
                        (list (make-diagnostic
                                (make-range start-line start-col end-line end-col)
                                1  ; Severity: Error
                                msg)))))))
              ; No error - return empty diagnostics
              (list)))
        ; Unbalanced parens - report ALL unmatched parens
        (let errors (find-all-unmatched-parens text)
          (map paren-error-to-diagnostic errors)))))


; ============================================
; Completion Support
; ============================================

; String search: find index of substr in str starting at pos, or -1
(define (string-index-of-loop str substr pos str-len sub-len)
  (if (> (+ pos sub-len) str-len)
      -1
      (if (equal? (substring str pos sub-len) substr)
          pos
          (string-index-of-loop str substr (+ pos 1) str-len sub-len))))

(define (string-index-of str substr pos)
  (let str-len (string-length str)
    (let sub-len (string-length substr)
      (string-index-of-loop str substr pos str-len sub-len))))

; Skip whitespace characters, return new position
(define (skip-whitespace text pos)
  (if (>= pos (string-length text))
      pos
      (let ch (char-at text pos)
        (if (if (equal? ch " ") #t (if (equal? ch "\n") #t (if (equal? ch "\t") #t (equal? ch "\r"))))
            (skip-whitespace text (+ pos 1))
            pos))))

; Extract a symbol (identifier) starting at pos
; Returns (symbol . end-pos) or (#f . pos) if no symbol found
(define (extract-symbol-loop text pos acc)
  (if (>= pos (string-length text))
      (if (equal? acc "") (list #f pos) (list acc pos))
      (let ch (char-at text pos)
        (if (if (equal? ch " ") #t (if (equal? ch "\n") #t (if (equal? ch "\t") #t (if (equal? ch "\r") #t (if (equal? ch ")") #t (equal? ch "("))))))
            (if (equal? acc "") (list #f pos) (list acc pos))
            (extract-symbol-loop text (+ pos 1) (string-append acc ch))))))

(define (extract-symbol text pos)
  (extract-symbol-loop text pos ""))

; Extract symbol name after (define or (defmacro
; Handles both (define name ...) and (define (name ...) ...)
(define (extract-defined-symbol text start-pos)
  (let pos (skip-whitespace text start-pos)
    (if (>= pos (string-length text))
        #f
        (if (equal? (char-at text pos) "(")
            ; Function form: (define (name args) body)
            (car (extract-symbol text (skip-whitespace text (+ pos 1))))
            ; Variable form: (define name value)
            (car (extract-symbol text pos))))))

; Find all symbols defined with a keyword like "(define " or "(defmacro "
(define (find-definitions-loop text pattern pattern-len pos acc)
  (let idx (string-index-of text pattern pos)
    (if (< idx 0)
        acc
        (let sym (extract-defined-symbol text (+ idx pattern-len))
          (if (equal? sym #f)
              (find-definitions-loop text pattern pattern-len (+ idx 1) acc)
              (find-definitions-loop text pattern pattern-len (+ idx pattern-len)
                                     (cons sym acc)))))))

(define (find-definitions text pattern pattern-len)
  (find-definitions-loop text pattern pattern-len 0 '()))

; Find all user-defined symbols in text (from define and defmacro)
(define (find-defined-symbols text)
  (append (find-definitions text "(define " 8)
          (find-definitions text "(defmacro " 10)))

; ============================================
; Document Symbols Support
; ============================================

; Convert byte offset to (line . col) - 0-based for LSP
(define (offset-to-position-loop text pos line col target)
  (if (>= pos target)
      (list line col)
      (if (>= pos (string-length text))
          (list line col)
          (if (equal? (char-at text pos) "\n")
              (offset-to-position-loop text (+ pos 1) (+ line 1) 0 target)
              (offset-to-position-loop text (+ pos 1) line (+ col 1) target)))))

(define (offset-to-position text offset)
  (offset-to-position-loop text 0 0 0 offset))

; Find definitions with positions: returns list of (name line col)
(define (find-definitions-pos-loop text pattern pattern-len pos acc)
  (let idx (string-index-of text pattern pos)
    (if (< idx 0)
        acc
        (let sym (extract-defined-symbol text (+ idx pattern-len))
          (if (equal? sym #f)
              (find-definitions-pos-loop text pattern pattern-len (+ idx 1) acc)
              (let position (offset-to-position text idx)
                (find-definitions-pos-loop text pattern pattern-len (+ idx pattern-len)
                  (cons (list sym (car position) (car (cdr position))) acc))))))))

(define (find-definitions-with-pos text pattern pattern-len)
  (find-definitions-pos-loop text pattern pattern-len 0 '()))

(define (find-defined-symbols-with-pos text)
  (append (find-definitions-with-pos text "(define " 8)
          (find-definitions-with-pos text "(defmacro " 10)))

; Make a symbol information object for LSP
; SymbolKind: 12 = Function, 13 = Variable
(define (make-symbol-info name kind uri line col)
  (list (list "name" name)
        (list "kind" kind)
        (list "location"
          (list (list "uri" uri)
                (list "range" (make-range line col line (+ col (string-length name))))))))

; Handle document symbols request
; Returns list of SymbolInformation objects
(define (handle-document-symbols uri doc-text)
  (if (equal? doc-text #f)
      '()
      (let symbols (find-defined-symbols-with-pos doc-text)
        (map (lambda (sym)
               (make-symbol-info (car sym) 12 uri (car (cdr sym)) (car (cdr (cdr sym)))))
             symbols))))

; Remove duplicates from a list
(define (unique lst)
  (unique-loop lst '()))

(define (unique-loop lst acc)
  (if (null? lst)
      (reverse acc)
      (if (member? (car lst) acc)
          (unique-loop (cdr lst) acc)
          (unique-loop (cdr lst) (cons (car lst) acc)))))

; Check if item is in list
(define (member? item lst)
  (if (null? lst)
      #f
      (if (equal? item (car lst))
          #t
          (member? item (cdr lst)))))

; All SeqLisp builtins for completion
(define *builtins*
  '("+" "-" "*" "/" "abs" "min" "max" "modulo"
    "<" ">" "<=" ">=" "="
    "null?" "number?" "symbol?" "list?" "boolean?" "string?" "float?" "integer?"
    "equal?" "not"
    "car" "cdr" "cons" "list" "append" "reverse" "length" "nth" "last" "take" "drop"
    "map" "filter" "fold" "apply"
    "if" "cond" "begin" "let" "lambda" "define" "quote" "quasiquote" "unquote" "unquote-splicing"
    "print" "display" "write" "read-line" "read-n" "exit"
    "try" "assert-error"
    "defmacro" "gensym"
    "json-parse" "json-encode"
    "string-length" "substring" "string-append" "string?"
    "eval-with-errors" "eval-all-with-errors"))

; Make a completion item
; kind: 3 = Function, 6 = Variable, 14 = Keyword
(define (make-completion-item label kind)
  (list (list "label" label)
        (list "kind" kind)))

; Build completion items from a list of names
(define (build-completion-items names kind)
  (map (lambda (name) (make-completion-item name kind)) names))

; Handle completion request
; Returns builtins + user-defined symbols from the document
(define (handle-completion params doc-text)
  (let user-symbols (if (equal? doc-text #f)
                        '()
                        (unique (find-defined-symbols doc-text)))
    (let all-items (append (build-completion-items *builtins* 3)
                           (build-completion-items user-symbols 6))
      (list (list "isIncomplete" #f)
            (list "items" all-items)))))

; ============================================
; Document Storage
; ============================================

; Remove document from list
(define (doc-remove uri docs)
  (if (null? docs)
      '()
      (if (equal? (car (car docs)) uri)
          (doc-remove uri (cdr docs))
          (cons (car docs) (doc-remove uri (cdr docs))))))

; Store or update document in documents list
; documents is a list of (uri text) pairs
(define (doc-store uri text docs)
  (cons (list uri text) (doc-remove uri docs)))

; Get document text by uri, or #f if not found
(define (doc-get uri docs)
  (if (null? docs)
      #f
      (if (equal? (car (car docs)) uri)
          (car (cdr (car docs)))
          (doc-get uri (cdr docs)))))

; ============================================
; LSP Dispatch
; ============================================

; Handle didOpen and store document, returns updated docs
(define (dispatch-did-open params docs)
  (let text-doc (assoc-val 'textDocument params)
    (if (null? text-doc)
        docs
        (let uri (assoc-val 'uri text-doc)
          (if (null? uri)
              docs
              (let text (assoc-val 'text text-doc)
                (begin
                  (publish-diagnostics uri (validate-document text))
                  (doc-store uri text docs))))))))

; Handle didChange and update document, returns updated docs
(define (dispatch-did-change params docs)
  (let text-doc (assoc-val 'textDocument params)
    (if (null? text-doc)
        docs
        (let uri (assoc-val 'uri text-doc)
          (if (null? uri)
              docs
              (let changes (assoc-val 'contentChanges params)
                (if (null? changes)
                    docs
                    (let change (car changes)
                      (let text (assoc-val 'text change)
                        (begin
                          (publish-diagnostics uri (validate-document text))
                          (doc-store uri text docs)))))))))))

; Main dispatch - returns updated documents
(define (lsp-dispatch msg docs)
  (let method (assoc-val 'method msg)
    (let id (assoc-val 'id msg)
      (let params (assoc-val 'params msg)
        (cond
          ((equal? method "initialize")
           (begin
             (lsp-send
               (list (list "jsonrpc" "2.0")
                     (list "id" id)
                     (list "result"
                       (list (list "capabilities"
                               (list (list "textDocumentSync" 1)
                                     (list "completionProvider"
                                       (list (list "triggerCharacters" '("(" " "))
                                             (list "resolveProvider" #f)))
                                     (list "documentSymbolProvider" #t)))
                            (list "serverInfo"
                              (list (list "name" "seqlisp-lsp")
                                    (list "version" "0.3.0")))))))
             docs))
          ((equal? method "initialized") docs)
          ((equal? method "shutdown")
           (begin
             (lsp-send
               (list (list "jsonrpc" "2.0")
                     (list "id" id)
                     (list "result" '())))
             docs))
          ((equal? method "exit") (exit 0))
          ((equal? method "textDocument/didOpen")
           (dispatch-did-open params docs))
          ((equal? method "textDocument/didChange")
           (dispatch-did-change params docs))
          ((equal? method "textDocument/completion")
           (let uri (assoc-val 'uri (assoc-val 'textDocument params))
             (let doc-text (doc-get uri docs)
               (begin
                 (lsp-send
                   (list (list "jsonrpc" "2.0")
                         (list "id" id)
                         (list "result" (handle-completion params doc-text))))
                 docs))))
          ((equal? method "textDocument/documentSymbol")
           (let uri (assoc-val 'uri (assoc-val 'textDocument params))
             (let doc-text (doc-get uri docs)
               (begin
                 (lsp-send
                   (list (list "jsonrpc" "2.0")
                         (list "id" id)
                         (list "result" (handle-document-symbols uri doc-text))))
                 docs))))
          (else
            ; For unknown methods: notifications (no id) are ignored, requests get error
            (begin
              (if (null? id)
                  '()
                  (lsp-send-error id -32601 "Method not found"))
              docs)))))))

; ============================================
; Main Loop
; ============================================

; Main loop with buffer and document threading
; Buffer holds leftover bytes from header reading that belong to body
; Documents is an alist of (uri . text) for open documents
(define (lsp-loop-with-state buffer docs)
  (let header-result (lsp-read-headers buffer)
    (let cl (car header-result)
      (let header-buffer (car (cdr header-result))
        (if (<= cl 0)
            '()
            (let body (lsp-read-body cl header-buffer)
              (if (equal? body #f)
                  '()  ; EOF
                  (let parse-result (try (json-parse body))
                    (if (try-error? parse-result)
                        ; Parse error - send error response and continue
                        (begin
                          (lsp-send-error '() -32700 "Parse error")
                          (lsp-loop-with-state "" docs))
                        ; Success - extract value and dispatch
                        (let msg (try-value parse-result)
                          (let new-docs (lsp-dispatch msg docs)
                            (lsp-loop-with-state "" new-docs))))))))))))

(define (lsp-loop) (lsp-loop-with-state "" '()))

(lsp-loop)
