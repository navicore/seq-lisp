# Test evaluator

include "../../src/eval"

: main ( -- )
  "Testing evaluator:" io.write-line

  # Simple numbers
  "42" eval-print

  # Addition
  "(+ 1 2)" eval-print
  "(+ 1 2 3 4 5)" eval-print

  # Subtraction
  "(- 10 3)" eval-print
  "(- 5)" eval-print

  # Multiplication
  "(* 3 4)" eval-print
  "(* 2 3 4)" eval-print

  # Division
  "(/ 10 2)" eval-print
  "(/ 100 2 5)" eval-print

  # Nested expressions
  "(+ 1 (* 2 3))" eval-print
  "(* (+ 1 2) (- 10 5))" eval-print

  # Conditionals
  "(if 1 42 0)" eval-print
  "(if 0 42 99)" eval-print

  # Let bindings
  "(let x 10 x)" eval-print
  "(let x 5 (+ x 3))" eval-print
  "(let a 10 (let b 20 (+ a b)))" eval-print

  # Lambda
  "((lambda (x) x) 42)" eval-print
  "((lambda (x) (+ x 1)) 5)" eval-print
  "((lambda (x) (* x x)) 7)" eval-print

  # Closure capturing environment
  "(let y 10 ((lambda (x) (+ x y)) 5))" eval-print

  # Quote - returns unevaluated
  "'x" eval-print
  "'(1 2 3)" eval-print
  "(quote (+ 1 2))" eval-print

  # List operations
  "(list 1 2 3)" eval-print
  "(list (+ 1 2) (* 3 4))" eval-print
  "(car '(1 2 3))" eval-print
  "(cdr '(1 2 3))" eval-print
  "(cons 1 '(2 3))" eval-print
  "(cons 'a '())" eval-print
  "(car (cdr '(1 2 3)))" eval-print

  # Predicates
  "(null? '())" eval-print
  "(null? '(1 2))" eval-print
  "(number? 42)" eval-print
  "(number? 'x)" eval-print
  "(symbol? 'x)" eval-print
  "(symbol? 42)" eval-print
  "(list? '(1 2 3))" eval-print
  "(list? 42)" eval-print
  "(number? (+ 1 2))" eval-print
  "(list? (list 1 2))" eval-print
  "(null? (car '(())))" eval-print

  # Begin (sequencing)
  "(begin 1 2 3)" eval-print
  "(begin (+ 1 2))" eval-print
  "(begin (+ 1 1) (+ 2 2) (+ 3 3))" eval-print

  # Boolean literals
  "#t" eval-print
  "#f" eval-print
  "(if #t 'yes 'no)" eval-print
  "(if #f 'yes 'no)" eval-print
  "(< 1 2)" eval-print
  "(> 1 2)" eval-print
  "(boolean? #t)" eval-print
  "(boolean? #f)" eval-print
  "(boolean? 42)" eval-print
  "(boolean? 'x)" eval-print
  "(if '() 'yes 'no)" eval-print

  # Cond (multi-way conditional)
  "(cond (#t 'yes))" eval-print
  "(cond (#f 'no) (#t 'yes))" eval-print
  "(cond ((< 1 2) 'less) (else 'other))" eval-print
  "(cond ((> 1 2) 'greater) (else 'not-greater))" eval-print
  "(cond (#f 'a) (#f 'b) (else 'c))" eval-print
  "(cond (#t 1 2 3))" eval-print

  # Error handling - arity validation
  "Testing error handling:" io.write-line
  "(car)" eval-print  # Error: car expects 1 argument(s)
  "(car '(a b c))" eval-print  # a (continues after error)
  "(cdr)" eval-print  # Error: cdr expects 1 argument(s)
  "(cdr '(1 2 3))" eval-print  # (2 3)
  "(car 'a 'b)" eval-print  # Error: car expects 1 argument(s) (too many)

  # Error propagation in nested expressions
  "Testing error propagation:" io.write-line
  "(+ 1 (car))" eval-print  # Error propagates through +
  "(+ 1 2)" eval-print  # 3 (continues after nested error)
  "(+ (car) (cdr))" eval-print  # First error propagates

  # ============================================
  # Currying / Partial Application Tests
  # ============================================
  "Testing currying:" io.write-line

  # Basic partial application - 2 params, 1 arg -> closure
  "((lambda (x y) (+ x y)) 3)" eval-print  # #<closure>

  # Partial then full - curried addition
  "(((lambda (x y) (+ x y)) 3) 4)" eval-print  # 7

  # Full application - all args at once
  "((lambda (x y) (+ x y)) 3 4)" eval-print  # 7

  # Three-level currying
  "((((lambda (x y z) (+ x (+ y z))) 1) 2) 3)" eval-print  # 6

  # Partial with 2 of 3 params
  "(((lambda (x y z) (+ x (+ y z))) 1 2) 3)" eval-print  # 6

  # Over-application: nested lambdas with extra args
  "((lambda (x) (lambda (y) (+ x y))) 3 4)" eval-print  # 7

  # Deep over-application: three nested lambdas
  "((lambda (a) (lambda (b) (lambda (c) (+ a (+ b c))))) 1 2 3)" eval-print  # 6

  # Zero-param lambda (should work)
  "((lambda () 42))" eval-print  # 42

  # Single param, no args -> closure
  "((lambda (x) x))" eval-print  # #<closure>

  # Over-application with non-function result - should error
  "((lambda (x) x) 42 extra)" eval-print  # Error: over-application: result is not a function

  # ============================================
  # Define Tests
  # ============================================
  "Testing define:" io.write-line

  # Simple value define
  "(begin (define x 42) x)" eval-print  # 42

  # Define then use in expression
  "(begin (define a 10) (define b 20) (+ a b))" eval-print  # 30

  # Define a lambda
  "(begin (define add (lambda (x y) (+ x y))) (add 3 4))" eval-print  # 7

  # Curried define usage
  "(begin (define add (lambda (x y) (+ x y))) ((add 10) 5))" eval-print  # 15

  # Function shorthand define
  "(begin (define (square n) (* n n)) (square 5))" eval-print  # 25

  # Function define with multiple params
  "(begin (define (add3 a b c) (+ a (+ b c))) (add3 1 2 3))" eval-print  # 6

  # Curried function define
  "(begin (define (mul x y) (* x y)) ((mul 3) 4))" eval-print  # 12

  # Recursive define (factorial)
  "(begin (define (fact n) (if (< n 2) 1 (* n (fact (- n 1))))) (fact 5))" eval-print  # 120

  # ============================================
  # List Utility Tests
  # ============================================
  "Testing list utilities:" io.write-line

  # length
  "(length '())" eval-print  # 0
  "(length '(a))" eval-print  # 1
  "(length '(1 2 3 4 5))" eval-print  # 5

  # nth (0-indexed)
  "(nth 0 '(a b c d e))" eval-print  # a
  "(nth 2 '(a b c d e))" eval-print  # c
  "(nth 4 '(a b c d e))" eval-print  # e
  "(nth 10 '(a b c))" eval-print  # Error: index out of bounds

  # last
  "(last '(1 2 3 4 5))" eval-print  # 5
  "(last '(x))" eval-print  # x
  "(last '())" eval-print  # Error: empty list

  # take
  "(take 0 '(a b c d e))" eval-print  # ()
  "(take 3 '(a b c d e))" eval-print  # (a b c)
  "(take 10 '(a b c))" eval-print  # (a b c)

  # drop
  "(drop 0 '(a b c d e))" eval-print  # (a b c d e)
  "(drop 2 '(a b c d e))" eval-print  # (c d e)
  "(drop 10 '(a b c))" eval-print  # ()
;

