# Evaluator for SeqLisp
#
# Currently supports:
# - Numbers: return as-is
# - Symbols: lookup in environment
# - Arithmetic: +, -, *, /
# - let: local binding
# - if: conditional
# - lambda: anonymous functions

include "parser"

# ============================================
# Environment (Association List)
#
# Env is a list of (Symbol . Value) pairs
# Using scons/snil for the list structure
# Each binding is a 2-field variant (tag 50)
# ============================================

: make-binding ( String Variant -- Variant )
  50 make-variant-2 ;

: binding-name ( Variant -- String )
  0 variant-field-at ;

: binding-value ( Variant -- Variant )
  1 variant-field-at ;

: env-empty ( -- Variant )
  snil ;

: env-extend ( String Variant Variant -- Variant )
  # Stack: Name Value Env
  rot rot make-binding swap scons ;

# ============================================
# Closure (Lambda Value)
#
# Closure is a 3-field variant (tag 60):
# - Field 0: Parameter list (cons list of symbols)
# - Field 1: Body expression
# - Field 2: Captured environment
# ============================================

: make-closure ( Variant Variant Variant -- Variant )
  60 make-variant-3 ;

: closure? ( Variant -- Int )
  variant-tag 60 = ;

: closure-params ( Variant -- Variant )
  0 variant-field-at ;

: closure-body ( Variant -- Variant )
  1 variant-field-at ;

: closure-env ( Variant -- Variant )
  2 variant-field-at ;

: env-lookup ( String Variant -- Variant )
  # Stack: Name Env
  # Returns the value or snil if not found
  dup snil? if
    # Not found - return snil
    nip
  else
    dup scar binding-name
    2 pick string-equal if
      # Found it
      nip scar binding-value
    else
      # Keep looking
      scdr env-lookup
    then
  then ;

# ============================================
# Main Evaluator
# ============================================

# Simple eval without environment (for backward compatibility)
: eval ( Variant -- Variant )
  env-empty eval-with-env ;

# Eval with explicit environment
: eval-with-env ( Variant Variant -- Variant )
  # Stack: Expr Env
  over variant-tag
  dup 1 = if
    # SNum - return as-is
    drop drop
  else
    dup 2 = if
      # SSym - lookup in environment
      drop swap ssym-val swap env-lookup
    else
      3 = if
        # SList - function application
        eval-list-with-env
      else
        # Unknown - return as-is
        drop drop
      then
    then
  then
;

# ============================================
# List Evaluation (Function Application)
# ============================================

: eval-list-with-env ( Variant Variant -- Variant )
  # Stack: Expr Env
  swap slist-val
  dup snil? if
    # Empty list - return empty list
    nip slist
  else
    # Non-empty list: first element is function
    dup scar
    dup ssym? if
      # Symbol - check for built-in functions
      # Stack: Env List Head
      ssym-val swap rot eval-builtin-with-env
    else
      dup slist? if
        # List in function position - evaluate it (likely a lambda)
        # Stack: Env List Head
        2 pick eval-with-env  # -> Env List EvaledHead
        dup closure? if
          # It's a closure - apply it
          # Stack: Env List EvaledHead
          rot rot  # -> EvaledHead Env List
          scdr     # -> EvaledHead Env Args
          swap     # -> EvaledHead Args Env
          apply-closure
        else
          # Not a closure - error
          drop drop slist
        then
      else
        # Non-symbol, non-list in function position
        drop slist nip
      then
    then
  then
;

# ============================================
# Built-in Function Dispatch
# ============================================

: eval-builtin-with-env ( String Variant Variant -- Variant )
  # Stack: FuncName List Env
  rot
  dup "+" string-equal if
    drop eval-add-with-env
  else
    dup "-" string-equal if
      drop eval-sub-with-env
    else
      dup "*" string-equal if
        drop eval-mul-with-env
      else
        dup "/" string-equal if
          drop eval-div-with-env
        else
          dup "if" string-equal if
            drop eval-if-with-env
          else
            dup "let" string-equal if
              drop eval-let-with-env
            else
              dup "lambda" string-equal if
                drop eval-lambda-with-env
              else
                # Unknown function - return list as-is
                drop drop slist
              then
            then
          then
        then
      then
    then
  then
;

# ============================================
# Arithmetic Operations
# ============================================

: eval-add-with-env ( Variant Variant -- Variant )
  # Stack: List Env
  swap scdr swap  # Skip the + -> RestList Env
  0 swap eval-fold-add-with-env snum
;

: eval-fold-add-with-env ( Variant Int Variant -- Int )
  # Stack: List Acc Env
  2 pick snil? if
    # List is empty, return Acc
    drop nip
  else
    # Get first element and eval it
    2 pick scar over eval-with-env snum-val
    # Stack: List Acc Env FirstVal
    rot add
    # Stack: List Env NewAcc
    swap rot scdr rot rot
    # Stack: RestList NewAcc Env
    eval-fold-add-with-env
  then
;

: eval-sub-with-env ( Variant Variant -- Variant )
  # Stack: List Env
  swap scdr
  dup snil? if
    drop drop 0 snum
  else
    dup scar 2 pick eval-with-env snum-val
    swap scdr
    dup snil? if
      # Unary minus: negate
      drop nip 0 swap subtract snum
    else
      # Binary minus: first - rest
      # Stack: Env FirstVal RestList -> need RestList FirstVal Env
      rot rot swap eval-fold-sub-with-env snum
    then
  then
;

: eval-fold-sub-with-env ( Variant Int Variant -- Int )
  # Stack: List Acc Env
  2 pick snil? if
    # List is empty, return Acc
    drop nip
  else
    # Get first element and eval it
    2 pick scar over eval-with-env snum-val
    # Stack: List Acc Env FirstVal
    rot swap subtract
    # Stack: List Env NewAcc
    swap rot scdr rot rot
    # Stack: RestList NewAcc Env
    eval-fold-sub-with-env
  then
;

: eval-mul-with-env ( Variant Variant -- Variant )
  # Stack: List Env
  swap scdr swap  # Skip the * -> RestList Env
  1 swap eval-fold-mul-with-env snum
;

: eval-fold-mul-with-env ( Variant Int Variant -- Int )
  # Stack: List Acc Env
  2 pick snil? if
    # List is empty, return Acc
    drop nip
  else
    # Get first element and eval it
    2 pick scar over eval-with-env snum-val
    # Stack: List Acc Env FirstVal
    rot multiply
    # Stack: List Env NewAcc
    swap rot scdr rot rot
    # Stack: RestList NewAcc Env
    eval-fold-mul-with-env
  then
;

: eval-div-with-env ( Variant Variant -- Variant )
  # Stack: List Env
  swap scdr
  dup snil? if
    drop drop 0 snum
  else
    dup scar 2 pick eval-with-env snum-val
    swap scdr
    dup snil? if
      drop nip snum
    else
      # Stack: Env FirstVal RestList -> need RestList FirstVal Env
      rot rot swap eval-fold-div-with-env snum
    then
  then
;

: eval-fold-div-with-env ( Variant Int Variant -- Int )
  # Stack: List Acc Env
  2 pick snil? if
    # List is empty, return Acc
    drop nip
  else
    # Get first element and eval it
    2 pick scar over eval-with-env snum-val
    # Stack: List Acc Env FirstVal
    rot swap divide
    # Stack: List Env NewAcc
    swap rot scdr rot rot
    # Stack: RestList NewAcc Env
    eval-fold-div-with-env
  then
;

# ============================================
# Conditional (if)
# ============================================

: eval-if-with-env ( Variant Variant -- Variant )
  # Stack: List Env
  # List is (if cond then-expr else-expr)
  swap scdr  # Skip the if -> Env Args
  # Args is (cond then-expr else-expr)
  dup scar   # -> Env Args CondExpr
  2 pick     # -> Env Args CondExpr Env
  eval-with-env  # -> Env Args CondResult
  # Check if condition is numeric 0 (false)
  dup snum? if
    snum-val 0 = if
      # False (0) - eval else branch
      # Stack: Env Args
      scdr scdr scar swap eval-with-env
    else
      # True (non-zero) - eval then branch
      # Stack: Env Args
      scdr scar swap eval-with-env
    then
  else
    # Non-numeric condition - treat as true
    drop  # Drop CondResult -> Env Args
    scdr scar swap eval-with-env
  then
;

# ============================================
# Let Binding
# ============================================

: eval-let-with-env ( Variant Variant -- Variant )
  # Stack: List Env
  # List is (let name value body)
  swap scdr  # Skip the 'let' -> Env Args
  dup scar ssym-val  # Get binding name -> Env Args Name
  swap scdr  # -> Env Name RestArgs
  dup scar  # -> Env Name RestArgs ValueExpr
  3 pick eval-with-env  # Evaluate value -> Env Name RestArgs Value
  rot  # -> Env RestArgs Value Name
  swap  # -> Env RestArgs Name Value
  3 pick  # -> Env RestArgs Name Value Env
  env-extend  # -> Env RestArgs NewEnv
  swap scdr scar  # Get body expr -> Env NewEnv BodyExpr
  swap  # -> Env BodyExpr NewEnv
  eval-with-env  # Evaluate body in new env -> Env Result
  nip  # -> Result
;

# ============================================
# Lambda
# ============================================

: eval-lambda-with-env ( Variant Variant -- Variant )
  # Stack: List Env
  # List is (lambda (params) body)
  swap scdr  # Skip 'lambda' -> Env Args
  # Args is ((params) body)
  dup scar slist-val  # Get params list -> Env Args Params
  swap scdr scar  # Get body -> Env Params Body
  rot  # -> Params Body Env
  make-closure  # -> Closure
;

# ============================================
# Closure Application
# ============================================

: apply-closure ( Variant Variant Variant -- Variant )
  # Stack: Closure Args CallerEnv
  # For simplicity, support single-parameter lambdas
  # 1. Evaluate the single argument
  # 2. Bind param to value in closure's env
  # 3. Evaluate body in extended env
  over scar  # -> Closure Args CallerEnv ArgExpr
  over eval-with-env  # -> Closure Args CallerEnv ArgVal
  # Now get closure components
  3 pick closure-params scar ssym-val  # -> Closure Args CallerEnv ArgVal ParamName
  swap  # -> Closure Args CallerEnv ParamName ArgVal
  4 pick closure-env  # -> Closure Args CallerEnv ParamName ArgVal ClosureEnv
  env-extend  # -> Closure Args CallerEnv ExtendedEnv
  # Evaluate body
  3 pick closure-body  # -> Closure Args CallerEnv ExtendedEnv Body
  swap eval-with-env  # -> Closure Args CallerEnv Result
  nip nip nip  # -> Result
;

# ============================================
# REPL Helper
# ============================================

: eval-print ( String -- )
  parse eval sexpr-to-string write_line ;
