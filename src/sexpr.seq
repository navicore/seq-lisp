# S-Expression Data Types for SeqLisp
#
# Algebraic Data Types for S-expressions:
#
#   Sexpr = SNum Int | SSym String | SList SexprList
#   SexprList = SNil | SCons Sexpr SexprList

# ============================================
# Type Definitions
# ============================================

union Sexpr {
  SNum { value: Int }
  SSym { name: String }
  SList { items: SexprList }
}

union SexprList {
  SNil
  SCons { head: Sexpr, tail: SexprList }
}

# ============================================
# Convenience Constructors (lowercase aliases)
# ============================================

: snum ( Int -- Sexpr )
  Make-SNum ;

: ssym ( String -- Sexpr )
  Make-SSym ;

: slist ( SexprList -- Sexpr )
  Make-SList ;

: snil ( -- SexprList )
  Make-SNil ;

: scons ( Sexpr SexprList -- SexprList )
  Make-SCons ;

# ============================================
# Predicates
# ============================================

: snum? ( Sexpr -- Int )
  variant-tag 0 = ;

: ssym? ( Sexpr -- Int )
  variant-tag 1 = ;

: slist? ( Sexpr -- Int )
  variant-tag 2 = ;

: snil? ( SexprList -- Int )
  variant-tag 0 = ;

# ============================================
# Accessors
# ============================================

: snum-val ( Sexpr -- Int )
  0 variant-field-at ;

: ssym-val ( Sexpr -- String )
  0 variant-field-at ;

: slist-val ( Sexpr -- SexprList )
  0 variant-field-at ;

: scar ( SexprList -- Sexpr )
  0 variant-field-at ;

: scdr ( SexprList -- SexprList )
  1 variant-field-at ;

# ============================================
# Pretty Printing
# ============================================

: sexpr-to-string ( Sexpr -- String )
  match
    SNum { >value } ->
      # Stack: ( value )
      int->string
    SSym { >name } ->
      # Stack: ( name ) - already a string
    SList { >items } ->
      # Stack: ( items )
      list-to-string
  end
;

: list-to-string ( SexprList -- String )
  "(" swap list-items-to-string ")" string-concat string-concat
;

: list-items-to-string ( SexprList -- String )
  match
    SNil ->
      ""
    SCons { >head >tail } ->
      # Stack: ( head tail )
      swap sexpr-to-string  # ( tail head_str )
      swap                  # ( head_str tail )
      dup snil? if
        drop  # Last item, just return head_str
      else
        " " swap list-items-to-string string-concat string-concat
      then
  end
;
