# S-Expression Data Types for SeqLisp
#
# Algebraic Data Types for S-expressions:
#
#   Sexpr = SNum Int | SSym String | SList SexprList | SClosure Closure
#   SexprList = SNil | SCons Sexpr SexprList
#   Closure = { params: Sexpr, body: Sexpr, env: Env }
#   Env = EnvEmpty | EnvExtend Binding Env
#   Binding = { name: String, value: Sexpr }
#
# All types are defined here to support mutual recursion.

# ============================================
# Type Definitions
# ============================================

# Environment binding: maps a name to a value
union Binding {
  Bind { name: String, value: Sexpr }
}

# Environment: linked list of bindings
union Env {
  EnvEmpty
  EnvExtend { binding: Binding, parent: Env }
}

# Closure: captures params, body, and defining environment
# NamedClos includes self_name for recursive functions (avoids O(nÂ²) env growth)
union LispClosure {
  Clos { params: Sexpr, body: Sexpr, captured_env: Env }
  NamedClos { params: Sexpr, body: Sexpr, captured_env: Env, self_name: String }
}

# S-expressions: the core Lisp value type
union Sexpr {
  SNum { value: Int }
  SSym { name: String }
  SList { items: SexprList }
  SClosure { closure: LispClosure }
  SMacro { macro: LispClosure }  # Same structure as closure, different semantics
}

# Linked list of S-expressions
union SexprList {
  SNil
  SCons { head: Sexpr, tail: SexprList }
}

# ============================================
# Convenience Constructors (lowercase aliases)
# ============================================

: snum ( Int -- Sexpr )
  Make-SNum ;

: ssym ( String -- Sexpr )
  Make-SSym ;

: slist ( SexprList -- Sexpr )
  Make-SList ;

: sclosure ( LispClosure -- Sexpr )
  Make-SClosure ;

: smacro ( LispClosure -- Sexpr )
  Make-SMacro ;

: snil ( -- SexprList )
  Make-SNil ;

: scons ( Sexpr SexprList -- SexprList )
  Make-SCons ;

# Binding constructors
: make-binding ( String Sexpr -- Binding )
  Make-Bind ;

# Environment constructors
: env-empty ( -- Env )
  Make-EnvEmpty ;

: env-extend ( String Sexpr Env -- Env )
  # Stack: Name Value Env
  rot rot make-binding swap Make-EnvExtend ;

# Closure constructors
: make-closure ( Sexpr Sexpr Env -- LispClosure )
  Make-Clos ;

: make-named-closure ( Sexpr Sexpr Env String -- LispClosure )
  Make-NamedClos ;

# ============================================
# Predicates
# ============================================

: snum? ( Sexpr -- Int )
  variant.tag 0 = ;

: ssym? ( Sexpr -- Int )
  variant.tag 1 = ;

: slist? ( Sexpr -- Int )
  variant.tag 2 = ;

: sclosure? ( Sexpr -- Int )
  variant.tag 3 = ;

: smacro? ( Sexpr -- Int )
  variant.tag 4 = ;

: snil? ( SexprList -- Int )
  variant.tag 0 = ;

# Closure type predicates
: named-closure? ( LispClosure -- Int )
  variant.tag 1 = ;

# ============================================
# Accessors
# ============================================

: snum-val ( Sexpr -- Int )
  0 variant.field-at ;

: ssym-val ( Sexpr -- String )
  0 variant.field-at ;

: slist-val ( Sexpr -- SexprList )
  0 variant.field-at ;

: sclosure-val ( Sexpr -- LispClosure )
  0 variant.field-at ;

: smacro-val ( Sexpr -- LispClosure )
  0 variant.field-at ;

: scar ( SexprList -- Sexpr )
  0 variant.field-at ;

: scdr ( SexprList -- SexprList )
  1 variant.field-at ;

# Binding accessors
: binding-name ( Binding -- String )
  0 variant.field-at ;

: binding-value ( Binding -- Sexpr )
  1 variant.field-at ;

# Closure accessors (work for both Clos and NamedClos)
: closure-params ( LispClosure -- Sexpr )
  0 variant.field-at ;

: closure-body ( LispClosure -- Sexpr )
  1 variant.field-at ;

# Only valid for NamedClos - use named-closure? to check first
: closure-self-name ( LispClosure -- String )
  3 variant.field-at ;

: closure-env ( LispClosure -- Env )
  2 variant.field-at ;

# ============================================
# Pretty Printing
# ============================================

: sexpr-to-string ( Sexpr -- String )
  match
    SNum { >value } ->
      # Stack: ( value )
      int->string
    SSym { >name } ->
      # Stack: ( name ) - already a string
    SList { >items } ->
      # Stack: ( items )
      list-to-string
    SClosure { >closure } ->
      # Stack: ( closure )
      drop "#<closure>"
    SMacro { >macro } ->
      # Stack: ( macro )
      drop "#<macro>"
  end
;

: list-to-string ( SexprList -- String )
  "(" swap list-items-to-string ")" string.concat string.concat
;

: list-items-to-string ( SexprList -- String )
  match
    SNil ->
      ""
    SCons { >head >tail } ->
      # Stack: ( head tail )
      swap sexpr-to-string  # ( tail head_str )
      swap                  # ( head_str tail )
      dup snil? if
        drop  # Last item, just return head_str
      else
        " " swap list-items-to-string string.concat string.concat
      then
  end
;
