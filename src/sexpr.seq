# S-Expression Data Types for SeqLisp
#
# Algebraic Data Types for S-expressions:
#
#   Sexpr = SNum Int | SSym String | SList SexprList | SClosure Closure
#         | SMacro Closure | SString String | SFloat Float
#   SexprList = SNil | SCons Sexpr SexprList
#   Closure = { params: Sexpr, body: Sexpr, env: Env }
#   Env = EnvEmpty | EnvExtend Binding Env
#   Binding = { name: String, value: Sexpr }
#
# All types are defined here to support mutual recursion.

# ============================================
# Type Definitions
# ============================================

# Source location span for error reporting
# NoSpan: no location info (for generated/runtime values)
# Span: start and end positions (1-based line/column)
union SourceSpan {
  NoSpan
  Span { start_line: Int, start_col: Int, end_line: Int, end_col: Int }
}

# Environment binding: maps a name to a value
union Binding {
  Bind { name: String, value: Sexpr }
}

# Environment: linked list of bindings
union Env {
  EnvEmpty
  EnvExtend { binding: Binding, parent: Env }
}

# Closure: captures params, body, and defining environment
# NamedClos includes self_name for recursive functions (avoids O(nÂ²) env growth)
union LispClosure {
  Clos { params: Sexpr, body: Sexpr, captured_env: Env }
  NamedClos { params: Sexpr, body: Sexpr, captured_env: Env, self_name: String }
}

# S-expressions: the core Lisp value type
# Tags: 0=SNum, 1=SSym, 2=SList, 3=SClosure, 4=SMacro, 5=SString, 6=SFloat
# Each variant carries a SourceSpan for error reporting
union Sexpr {
  SNum { value: Int, span: SourceSpan }
  SSym { name: String, span: SourceSpan }
  SList { items: SexprList, span: SourceSpan }
  SClosure { closure: LispClosure, span: SourceSpan }
  SMacro { macro: LispClosure, span: SourceSpan }
  SString { value: String, span: SourceSpan }
  SFloat { value: Float, span: SourceSpan }
}

# Linked list of S-expressions
union SexprList {
  SNil
  SCons { head: Sexpr, tail: SexprList }
}

# ============================================
# Convenience Constructors (lowercase aliases)
# ============================================

# Constructors with explicit span
: snum-at ( Int SourceSpan -- Sexpr )
  Make-SNum ;

: ssym-at ( String SourceSpan -- Sexpr )
  Make-SSym ;

: slist-at ( SexprList SourceSpan -- Sexpr )
  Make-SList ;

: sclosure-at ( LispClosure SourceSpan -- Sexpr )
  Make-SClosure ;

: smacro-at ( LispClosure SourceSpan -- Sexpr )
  Make-SMacro ;

: sstring-at ( String SourceSpan -- Sexpr )
  Make-SString ;

: sfloat-at ( Float SourceSpan -- Sexpr )
  Make-SFloat ;

# Backward-compatible constructors (use no-span)
: snum ( Int -- Sexpr )
  no-span Make-SNum ;

: ssym ( String -- Sexpr )
  no-span Make-SSym ;

: slist ( SexprList -- Sexpr )
  no-span Make-SList ;

: sclosure ( LispClosure -- Sexpr )
  no-span Make-SClosure ;

: smacro ( LispClosure -- Sexpr )
  no-span Make-SMacro ;

: sstring ( String -- Sexpr )
  no-span Make-SString ;

: sfloat ( Float -- Sexpr )
  no-span Make-SFloat ;

: snil ( -- SexprList )
  Make-SNil ;

: scons ( Sexpr SexprList -- SexprList )
  Make-SCons ;

# Binding constructors
: make-binding ( String Sexpr -- Binding )
  Make-Bind ;

# Environment constructors
: env-empty ( -- Env )
  Make-EnvEmpty ;

: env-extend ( String Sexpr Env -- Env )
  # Stack: Name Value Env
  rot rot make-binding swap Make-EnvExtend ;

# Closure constructors
: make-closure ( Sexpr Sexpr Env -- LispClosure )
  Make-Clos ;

: make-named-closure ( Sexpr Sexpr Env String -- LispClosure )
  Make-NamedClos ;

# SourceSpan constructors
: no-span ( -- SourceSpan )
  Make-NoSpan ;

: make-span ( Int Int Int Int -- SourceSpan )
  # start_line start_col end_line end_col
  Make-Span ;

# ============================================
# Predicates
# ============================================

: snum? ( Sexpr -- Bool )
  is-SNum? ;

: ssym? ( Sexpr -- Bool )
  is-SSym? ;

: slist? ( Sexpr -- Bool )
  is-SList? ;

: sclosure? ( Sexpr -- Bool )
  is-SClosure? ;

: smacro? ( Sexpr -- Bool )
  is-SMacro? ;

: sstring? ( Sexpr -- Bool )
  is-SString? ;

: sfloat? ( Sexpr -- Bool )
  is-SFloat? ;

: snil? ( SexprList -- Bool )
  is-SNil? ;

# Closure type predicates
: named-closure? ( LispClosure -- Bool )
  is-NamedClos? ;

# SourceSpan predicates
: span? ( SourceSpan -- Bool )
  is-Span? ;

: no-span? ( SourceSpan -- Bool )
  is-NoSpan? ;

# ============================================
# Accessors
# ============================================

: snum-val ( Sexpr -- Int )
  SNum-value ;

: ssym-val ( Sexpr -- String )
  SSym-name ;

: slist-val ( Sexpr -- SexprList )
  SList-items ;

: sclosure-val ( Sexpr -- LispClosure )
  SClosure-closure ;

: smacro-val ( Sexpr -- LispClosure )
  SMacro-macro ;

: sstring-val ( Sexpr -- String )
  SString-value ;

: sfloat-val ( Sexpr -- Float )
  SFloat-value ;

# Get the span from any Sexpr (span is always field 1)
# Note: using variant.field-at for polymorphic access across all Sexpr variants
: sexpr-span ( Sexpr -- SourceSpan )
  1 variant.field-at ;

: scar ( SexprList -- Sexpr )
  SCons-head ;

: scdr ( SexprList -- SexprList )
  SCons-tail ;

# Binding accessors
: binding-name ( Binding -- String )
  Bind-name ;

: binding-value ( Binding -- Sexpr )
  Bind-value ;

# Closure accessors (work for both Clos and NamedClos)
# Note: using variant.field-at for polymorphic access across Clos and NamedClos
: closure-params ( LispClosure -- Sexpr )
  0 variant.field-at ;

: closure-body ( LispClosure -- Sexpr )
  1 variant.field-at ;

# Only valid for NamedClos - use named-closure? to check first
: closure-self-name ( LispClosure -- String )
  NamedClos-self_name ;

: closure-env ( LispClosure -- Env )
  2 variant.field-at ;

# SourceSpan accessors (only valid when span? is true)
: span-start-line ( SourceSpan -- Int )
  Span-start_line ;

: span-start-col ( SourceSpan -- Int )
  Span-start_col ;

: span-end-line ( SourceSpan -- Int )
  Span-end_line ;

: span-end-col ( SourceSpan -- Int )
  Span-end_col ;

# ============================================
# Pretty Printing
# ============================================

# Helper to get a double-quote character
: quote-char ( -- String )
  34 char->string ;

: sexpr-to-string ( Sexpr -- String )
  match
    SNum { >value } ->
      # Stack: ( value )
      int->string
    SSym { >name } ->
      # Stack: ( name ) - already a string
    SList { >items } ->
      # Stack: ( items )
      list-to-string
    SClosure { >closure } ->
      # Stack: ( closure )
      drop "#<closure>"
    SMacro { >macro } ->
      # Stack: ( macro )
      drop "#<macro>"
    SString { >value } ->
      # Stack: ( value ) - wrap in quotes
      quote-char swap string.concat quote-char string.concat
    SFloat { >value } ->
      # Stack: ( value )
      float->string
  end
;

: list-to-string ( SexprList -- String )
  "(" swap list-items-to-string ")" string.concat string.concat
;

: list-items-to-string ( SexprList -- String )
  match
    SNil ->
      ""
    SCons { >head >tail } ->
      # Stack: ( head tail )
      swap sexpr-to-string  # ( tail head_str )
      swap                  # ( head_str tail )
      dup snil? if
        drop  # Last item, just return head_str
      else
        " " swap list-items-to-string string.concat string.concat
      then
  end
;
