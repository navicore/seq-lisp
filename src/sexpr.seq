# S-Expression Data Types for SeqLisp
#
# Algebraic Data Types for S-expressions:
#
#   Sexpr = SNum Int | SSym String | SList SexprList | SClosure Closure
#         | SMacro Closure | SString String | SFloat Float
#   SexprList = SNil | SCons Sexpr SexprList
#   Closure = { params: Sexpr, body: Sexpr, env: Env }
#   Env = EnvEmpty | EnvExtend Binding Env
#   Binding = { name: String, value: Sexpr }
#
# All types are defined here to support mutual recursion.

# ============================================
# Type Definitions
# ============================================

# Source location span for error reporting
# NoSpan: no location info (for generated/runtime values)
# Span: start and end positions (1-based line/column)
union SourceSpan {
  NoSpan
  Span { start_line: Int, start_col: Int, end_line: Int, end_col: Int }
}

# Environment binding: maps a name to a value
union Binding {
  Bind { name: String, value: Sexpr }
}

# Environment: linked list of bindings
union Env {
  EnvEmpty
  EnvExtend { binding: Binding, parent: Env }
}

# Closure: captures params, body, and defining environment
# NamedClos includes self_name for recursive functions (avoids O(nÂ²) env growth)
union LispClosure {
  Clos { params: Sexpr, body: Sexpr, captured_env: Env }
  NamedClos { params: Sexpr, body: Sexpr, captured_env: Env, self_name: String }
}

# S-expressions: the core Lisp value type
# Tags: 0=SNum, 1=SSym, 2=SList, 3=SClosure, 4=SMacro, 5=SString, 6=SFloat
union Sexpr {
  SNum { value: Int }
  SSym { name: String }
  SList { items: SexprList }
  SClosure { closure: LispClosure }
  SMacro { macro: LispClosure }  # Same structure as closure, different semantics
  SString { value: String }      # String literals (distinct from symbols)
  SFloat { value: Float }        # Floating point numbers
}

# Linked list of S-expressions
union SexprList {
  SNil
  SCons { head: Sexpr, tail: SexprList }
}

# ============================================
# Convenience Constructors (lowercase aliases)
# ============================================

: snum ( Int -- Sexpr )
  Make-SNum ;

: ssym ( String -- Sexpr )
  Make-SSym ;

: slist ( SexprList -- Sexpr )
  Make-SList ;

: sclosure ( LispClosure -- Sexpr )
  Make-SClosure ;

: smacro ( LispClosure -- Sexpr )
  Make-SMacro ;

: sstring ( String -- Sexpr )
  Make-SString ;

: sfloat ( Float -- Sexpr )
  Make-SFloat ;

: snil ( -- SexprList )
  Make-SNil ;

: scons ( Sexpr SexprList -- SexprList )
  Make-SCons ;

# Binding constructors
: make-binding ( String Sexpr -- Binding )
  Make-Bind ;

# Environment constructors
: env-empty ( -- Env )
  Make-EnvEmpty ;

: env-extend ( String Sexpr Env -- Env )
  # Stack: Name Value Env
  rot rot make-binding swap Make-EnvExtend ;

# Closure constructors
: make-closure ( Sexpr Sexpr Env -- LispClosure )
  Make-Clos ;

: make-named-closure ( Sexpr Sexpr Env String -- LispClosure )
  Make-NamedClos ;

# SourceSpan constructors
: no-span ( -- SourceSpan )
  Make-NoSpan ;

: make-span ( Int Int Int Int -- SourceSpan )
  # start_line start_col end_line end_col
  Make-Span ;

# ============================================
# Predicates
# ============================================

: snum? ( Sexpr -- Int )
  variant.tag 0 = ;

: ssym? ( Sexpr -- Int )
  variant.tag 1 = ;

: slist? ( Sexpr -- Int )
  variant.tag 2 = ;

: sclosure? ( Sexpr -- Int )
  variant.tag 3 = ;

: smacro? ( Sexpr -- Int )
  variant.tag 4 = ;

: sstring? ( Sexpr -- Int )
  variant.tag 5 = ;

: sfloat? ( Sexpr -- Int )
  variant.tag 6 = ;

: snil? ( SexprList -- Int )
  variant.tag 0 = ;

# Closure type predicates
: named-closure? ( LispClosure -- Int )
  variant.tag 1 = ;

# SourceSpan predicates
: span? ( SourceSpan -- Int )
  variant.tag 1 = ;  # 0=NoSpan, 1=Span

: no-span? ( SourceSpan -- Int )
  variant.tag 0 = ;

# ============================================
# Accessors
# ============================================

: snum-val ( Sexpr -- Int )
  0 variant.field-at ;

: ssym-val ( Sexpr -- String )
  0 variant.field-at ;

: slist-val ( Sexpr -- SexprList )
  0 variant.field-at ;

: sclosure-val ( Sexpr -- LispClosure )
  0 variant.field-at ;

: smacro-val ( Sexpr -- LispClosure )
  0 variant.field-at ;

: sstring-val ( Sexpr -- String )
  0 variant.field-at ;

: sfloat-val ( Sexpr -- Float )
  0 variant.field-at ;

: scar ( SexprList -- Sexpr )
  0 variant.field-at ;

: scdr ( SexprList -- SexprList )
  1 variant.field-at ;

# Binding accessors
: binding-name ( Binding -- String )
  0 variant.field-at ;

: binding-value ( Binding -- Sexpr )
  1 variant.field-at ;

# Closure accessors (work for both Clos and NamedClos)
: closure-params ( LispClosure -- Sexpr )
  0 variant.field-at ;

: closure-body ( LispClosure -- Sexpr )
  1 variant.field-at ;

# Only valid for NamedClos - use named-closure? to check first
: closure-self-name ( LispClosure -- String )
  3 variant.field-at ;

: closure-env ( LispClosure -- Env )
  2 variant.field-at ;

# SourceSpan accessors (only valid when span? is true)
: span-start-line ( SourceSpan -- Int )
  0 variant.field-at ;

: span-start-col ( SourceSpan -- Int )
  1 variant.field-at ;

: span-end-line ( SourceSpan -- Int )
  2 variant.field-at ;

: span-end-col ( SourceSpan -- Int )
  3 variant.field-at ;

# ============================================
# Pretty Printing
# ============================================

# Helper to get a double-quote character
: quote-char ( -- String )
  34 char->string ;

: sexpr-to-string ( Sexpr -- String )
  match
    SNum { >value } ->
      # Stack: ( value )
      int->string
    SSym { >name } ->
      # Stack: ( name ) - already a string
    SList { >items } ->
      # Stack: ( items )
      list-to-string
    SClosure { >closure } ->
      # Stack: ( closure )
      drop "#<closure>"
    SMacro { >macro } ->
      # Stack: ( macro )
      drop "#<macro>"
    SString { >value } ->
      # Stack: ( value ) - wrap in quotes
      quote-char swap string.concat quote-char string.concat
    SFloat { >value } ->
      # Stack: ( value )
      float->string
  end
;

: list-to-string ( SexprList -- String )
  "(" swap list-items-to-string ")" string.concat string.concat
;

: list-items-to-string ( SexprList -- String )
  match
    SNil ->
      ""
    SCons { >head >tail } ->
      # Stack: ( head tail )
      swap sexpr-to-string  # ( tail head_str )
      swap                  # ( head_str tail )
      dup snil? if
        drop  # Last item, just return head_str
      else
        " " swap list-items-to-string string.concat string.concat
      then
  end
;
