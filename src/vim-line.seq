# vim-line.seq - Vim-style line editor for SeqLisp REPL
#
# A minimal vim-like editor written in pure Seq, using the terminal FFI.
# Implements modal editing (Normal/Insert) with basic motions.
#
# Usage:
#   "prompt> " "" vim-edit  # Returns edited string on Enter

# ============================================
# Constants
# ============================================

# Editor modes
: mode-normal ( -- Int ) 0 ;
: mode-insert ( -- Int ) 1 ;

# Key codes
: key-escape    ( -- Int ) 27 ;
: key-enter     ( -- Int ) 13 ;
: key-newline   ( -- Int ) 10 ;
: key-backspace ( -- Int ) 127 ;
: key-ctrl-h    ( -- Int ) 8 ;
: key-ctrl-c    ( -- Int ) 3 ;
: key-ctrl-d    ( -- Int ) 4 ;

# Arrow key codes (synthetic, outside ASCII range)
: key-up    ( -- Int ) 1001 ;
: key-down  ( -- Int ) 1002 ;
: key-left  ( -- Int ) 1003 ;
: key-right ( -- Int ) 1004 ;

# Read a key, handling arrow escape sequences
# Uses non-blocking read after ESC to avoid requiring double-ESC
: read-key ( -- Int )
  terminal.read-char
  dup 27 i.= if
    # ESC - check for arrow sequence (non-blocking)
    drop terminal.read-char?
    dup 0 i.< if
      # No character available - plain ESC
      drop 27
    else
      dup 91 i.= if
        # ESC [ - read arrow code
        drop terminal.read-char
        dup 65 i.= if drop key-up else     # Up arrow
        dup 66 i.= if drop key-down else   # Down arrow
        dup 67 i.= if drop key-right else  # Right arrow
        dup 68 i.= if drop key-left else   # Left arrow
        drop 27  # Unknown sequence, return ESC
        then then then then
      else
        # ESC followed by something else, return ESC
        drop 27
      then
    then
  then ;

# ============================================
# Integer Helpers (missing from Seq stdlib)
# ============================================

: int-min ( Int Int -- Int )
  2dup i.< if drop else nip then ;

: int-max ( Int Int -- Int )
  2dup i.> if drop else nip then ;

: int-mod ( Int Int -- Int )
  # a b -- a mod b = a - (a / b) * b
  # Note: i.divide returns (Int Bool) in Seq 3.0, drop the Bool
  2dup i.divide drop i.multiply i.subtract ;

# ============================================
# Character Classification
# ============================================

# Check if character code is whitespace (space, tab)
: is-whitespace ( Int -- Bool )
  dup 32 i.= swap 9 i.= or ;

# Check if character code is a word character (letter, digit, underscore)
: is-word-char ( Int -- Bool )
  dup 48 i.>= over 57 i.<= and if drop true else  # 0-9
  dup 65 i.>= over 90 i.<= and if drop true else  # A-Z
  dup 97 i.>= over 122 i.<= and if drop true else  # a-z
  95 i.=  # underscore
  then then then ;

# ============================================
# History Management
# ============================================

# History is stored as an slist of SString values (newest first)
# We use the sexpr types from the Lisp implementation

# Create empty history
: history-empty ( -- History )
  snil ;

# Strip trailing newlines and whitespace from a string
: string-strip-trailing ( String -- String )
  dup string.length string-strip-trailing-loop ;

: string-strip-trailing-loop ( String Int -- String )
  # Stack: Str Len
  dup 0 i.<= if
    # Empty - return empty string
    drop drop ""
  else
    # Check last char
    2dup 1 i.subtract string.char-at
    dup 10 i.= over 13 i.= or over 32 i.= or if
      # Newline (10), CR (13), or space (32) - trim it
      drop 1 i.subtract string-strip-trailing-loop
    else
      # Not whitespace - done, return Str[0..Len]
      drop swap 0 rot string.substring
    then
  then ;

# Add entry to history (prepends to front = newest first)
# Skips empty strings and duplicates of the most recent entry
: history-add ( History String -- History )
  # Strip trailing whitespace/newlines first
  string-strip-trailing
  # Check if string is empty
  dup string.empty? if
    drop  # Don't add empty strings
  else
    # Check if duplicate of most recent
    over snil? if
      # History empty, just add
      sstring swap scons
    else
      # Compare with most recent entry
      # Stack: History(1) NewString(0)
      over scar sstring-val  # History(2) NewString(1) OldString(0)
      1 pick                 # History(3) NewString(2) OldString(1) NewString(0)
      string.equal? if       # History(2) NewString(1) AreEqual(0)
        drop  # Duplicate, don't add
      else
        sstring swap scons
      then
    then
  then ;

# Get history length
: history-length ( History -- Int )
  0 history-length-loop ;

: history-length-loop ( History Int -- Int )
  over snil? if
    nip
  else
    1 i.add swap scdr swap history-length-loop
  then ;

# Get nth history entry (1-indexed, 1 = most recent)
# Returns empty string if out of bounds
: history-get ( History Int -- String )
  # Stack: History N
  dup 1 i.< if
    drop drop ""  # Invalid index
  else
    history-get-loop
  then ;

: history-get-loop ( History Int -- String )
  # Stack: History N
  over snil? if
    drop drop ""  # Past end of history
  else
    dup 1 i.= if
      # Found it
      drop scar sstring-val
    else
      # Keep looking
      1 i.subtract swap scdr swap history-get-loop
    then
  then ;

# ============================================
# History Persistence
# ============================================

# Maximum history entries to keep
: history-max-entries ( -- Int ) 100 ;

# Get history file path (~/.seqlisp_history)
: history-file-path ( -- String )
  "HOME" os.getenv if
    "/.seqlisp_history" string.concat
  else
    drop ".seqlisp_history"  # Fallback to current dir
  then ;

# Reverse a history list (for saving oldest-first)
: history-reverse ( History -- History )
  snil history-reverse-loop ;

: history-reverse-loop ( History Acc -- Acc )
  over snil? if
    nip
  else
    over scar swap scons  # Prepend current item to acc
    swap scdr swap        # Move to next item
    history-reverse-loop
  then ;

# Convert history to string (one entry per line, oldest first)
: history-to-string ( History -- String )
  history-reverse "" history-to-string-loop ;

: history-to-string-loop ( History String -- String )
  over snil? if
    nip
  else
    over scar sstring-val  # Get entry string
    "\n" string.concat     # Add newline
    string.concat          # Append to result
    swap scdr swap         # Move to next
    history-to-string-loop
  then ;

# Save history to file
: history-save ( History -- )
  dup snil? if
    drop  # Nothing to save
  else
    history-to-string
    history-file-path
    file.spit drop  # Ignore success/failure
  then ;

# Load history from file (returns history list, newest first)
: history-load ( -- History )
  history-file-path
  dup file.exists? if
    file.slurp if
      # Got content, parse lines
      snil swap history-load-lines
    else
      drop snil  # Failed to read, return empty
    then
  else
    drop snil  # File doesn't exist, return empty
  then ;

# Parse lines from file content into history
# File has oldest entries first, we prepend each so newest ends up first
: history-load-lines ( History String -- History )
  dup string.empty? if
    drop  # Done, return history
  else
    dup "\n" string.find  # History Content Pos
    dup 0 i.< if
      # No newline - this is the last entry
      drop  # History Content
      string-strip-trailing
      dup string.empty? if
        drop  # Empty, just return History
      else
        sstring swap scons  # NewHistory
      then
    else
      # Found newline at Pos
      # Stack: History Content Pos
      # 1. Extract line = Content[0..Pos]
      over swap  # History Content Content Pos
      0 swap     # History Content Content 0 Pos
      string.substring  # History Content Line
      string-strip-trailing  # History Content StrippedLine

      # 2. Swap to get: History StrippedLine Content
      swap  # History StrippedLine Content

      # 3. Find newline again to get rest (simpler than tracking Pos)
      dup "\n" string.find 1 i.add  # History StrippedLine Content Start
      over string.length over i.subtract  # History StrippedLine Content Start RestLen
      string.substring  # History StrippedLine Rest

      # 4. Add StrippedLine to History if not empty
      # Stack: History StrippedLine Rest
      swap dup string.empty? if
        drop  # Empty line, skip: History Rest
      else
        sstring  # History Rest SLine
        rot     # Rest SLine History
        scons   # Rest NewHistory  (scons takes SLine History, correct order)
        swap    # NewHistory Rest
      then

      # Stack: History Rest
      history-load-lines
    then
  then ;

# ============================================
# Word Motion Helpers
# ============================================

# Find next word start position from current position
# Skips current word (if in one), then skips whitespace
: find-next-word ( String Int -- Int )
  # Stack: Str Pos
  over string.length  # Str Pos Len
  2dup i.>= if
    # Already at or past end
    drop nip  # Return Len (clamped later)
  else
    # Skip non-whitespace (current word)
    find-next-word-skip-word
  then ;

: find-next-word-skip-word ( String Int Int -- Int )
  # Stack: Str Pos Len
  2dup i.>= if
    drop nip
  else
    2 pick 2 pick string.char-at is-whitespace if
      # Found whitespace, now skip it
      find-next-word-skip-space
    else
      # Still in word, advance
      swap 1 i.add swap find-next-word-skip-word
    then
  then ;

: find-next-word-skip-space ( String Int Int -- Int )
  # Stack: Str Pos Len
  2dup i.>= if
    drop nip
  else
    2 pick 2 pick string.char-at is-whitespace if
      # Still whitespace, advance
      swap 1 i.add swap find-next-word-skip-space
    else
      # Found start of next word
      drop nip
    then
  then ;

# Find previous word start position from current position
: find-prev-word ( String Int -- Int )
  # Stack: Str Pos
  dup 0 i.<= if
    drop drop 0  # Already at start, return 0
  else
    # Move back one first
    1 i.subtract
    find-prev-word-skip-space
  then ;

: find-prev-word-skip-space ( String Int -- Int )
  # Stack: Str Pos
  dup 0 i.< if
    drop drop 0
  else
    over over string.char-at is-whitespace if
      dup 0 i.<= if
        drop drop 0
      else
        1 i.subtract find-prev-word-skip-space
      then
    else
      find-prev-word-skip-word
    then
  then ;

: find-prev-word-skip-word ( String Int -- Int )
  # Stack: Str Pos - we're in a word, find its start
  dup 0 i.<= if
    drop drop 0
  else
    over over string.char-at is-whitespace not if
      dup 0 i.<= if
        drop drop 0
      else
        1 i.subtract find-prev-word-skip-word
      then
    else
      # Hit whitespace, the word starts at pos+1
      nip 1 i.add
    then
  then ;

# ============================================
# String Helpers
# ============================================

# Delete character at position: ( Str Pos -- NewStr )
# string.substring takes (Str Start Len -- Substr)
: string-delete-at ( String Int -- String )
  over string.length over i.<= if
    drop  # Position beyond string - return unchanged
  else
    # Stack: Str Pos
    2dup 0 swap string.substring  # Before: Str[0..Pos]
    # Stack: Str Pos Before
    rot rot  # Stack: Before Str Pos
    1 i.add    # Stack: Before Str Pos+1
    over string.length over i.subtract  # Stack: Before Str Pos+1 Len-Pos-1
    string.substring  # After: Str[Pos+1..end]
    # Stack: Before After
    string.concat
  then ;

# Insert character at position: ( Str Pos Char -- NewStr )
: string-insert-at ( String Int Int -- String )
  # Stack: Str Pos Char
  char->string  # Stack: Str Pos CharStr
  rot rot  # Stack: CharStr Str Pos
  2dup 0 swap string.substring  # Before: Str[0..Pos]
  # Stack: CharStr Str Pos Before
  rot rot  # Stack: CharStr Before Str Pos
  over string.length over i.subtract  # Stack: CharStr Before Str Pos Len-Pos
  string.substring  # After: Str[Pos..end]
  # Stack: CharStr Before After
  # Result: Before + CharStr + After
  rot swap string.concat string.concat ;

# ============================================
# Cursor Helpers
# ============================================

# Clamp cursor to valid range for normal mode (0 to len-1, or 0 if empty)
: clamp-cursor-normal ( String Int -- Int )
  over string.length
  dup 0 i.= if
    drop drop drop 0  # Drop Len, Cursor, Str -> push 0
  else
    1 i.subtract int-min 0 int-max nip  # Compute clamped cursor, drop Str
  then ;

# Clamp cursor to valid range for insert mode (0 to len)
: clamp-cursor-insert ( String Int -- Int )
  over string.length int-min 0 int-max nip ;

# ============================================
# Rendering
# ============================================

# Render: clear line, show prompt, show buffer, position cursor
: vim-render ( String String Int Int -- )
  # Stack: Prompt Buffer Cursor Mode
  "\r\x1b[2K" io.write  # Clear line first
  # Show mode indicator: ● for insert, ○ for normal
  dup mode-insert i.= if "● " io.write else "○ " io.write then
  drop  # Drop mode -> Prompt Buffer Cursor
  rot io.write  # Write prompt -> Buffer Cursor
  over io.write  # Write buffer -> Buffer Cursor
  # Move cursor: we're at end of buffer, need to go back (buflen - cursor) chars
  over string.length swap i.subtract  # -> Buffer Diff
  dup 0 i.> if
    "\x1b[" io.write
    int-to-string io.write
    "D" io.write
  else
    drop
  then
  drop  # Drop Buffer
  terminal.flush ;

# Convert int to string (simple, positive only)
: int-to-string ( Int -- String )
  dup 0 i.= if
    drop "0"
  else
    "" swap int-to-string-loop
  then ;

: int-to-string-loop ( String Int -- String )
  dup 0 i.= if
    drop
  else
    dup 10 int-mod 48 i.add char->string rot string.concat swap
    10 i./ drop int-to-string-loop
  then ;

# ============================================
# Normal Mode Key Handlers
# ============================================

# Each returns: ( Buf Cur Mode -- NewBuf NewCur NewMode Continue? )

: normal-key-h ( String Int Int -- String Int Int Bool )
  swap dup 0 i.> if 1 i.subtract then swap true ;

: normal-key-l ( String Int Int -- String Int Int Bool )
  # Move cursor right if not at end (cursor < len-1)
  2 pick string.length 1 i.subtract  # Stack: ... (len-1)
  2 pick i.> if swap 1 i.add swap then true ;  # if (len-1) > cursor

: normal-key-0 ( String Int Int -- String Int Int Bool )
  swap drop 0 swap true ;

: normal-key-$ ( String Int Int -- String Int Int Bool )
  swap drop over string.length dup 0 i.> if 1 i.subtract then swap true ;

: normal-key-i ( String Int Int -- String Int Int Bool )
  drop mode-insert true ;

: normal-key-a ( String Int Int -- String Int Int Bool )
  drop  # Buffer Cursor
  over string.length over i.> if  # If len > cursor
    1 i.add  # Increment cursor
  then
  mode-insert true ;

: normal-key-A ( String Int Int -- String Int Int Bool )
  drop  # Buffer Cursor
  drop  # Buffer (discard old cursor)
  dup string.length  # Buffer NewCursor (cursor at end)
  mode-insert true ;

: normal-key-I ( String Int Int -- String Int Int Bool )
  drop  # Buffer Cursor
  drop  # Buffer (discard old cursor)
  0 mode-insert true ;  # Buffer 0 Mode true

: normal-key-x ( String Int Int -- String Int Int Bool )
  # Stack: Buffer Cursor Mode
  # Check if buffer length > cursor (cursor is within bounds)
  2 pick string.length 2 pick i.> if
    # Delete char and clamp cursor
    rot rot  # Mode Buffer Cursor
    over over string-delete-at  # Mode Buffer Cursor NewBuffer
    swap over swap clamp-cursor-normal  # Mode Buffer NewBuffer NewCursor
    rot drop  # Mode NewBuffer NewCursor
    rot  # NewBuffer NewCursor Mode
  then
  true ;

: normal-key-w ( String Int Int -- String Int Int Bool )
  # Move to next word: Buffer Cursor Mode -> Buffer NewCursor Mode true
  # Stack: Buffer Cursor Mode
  drop  # Buffer Cursor (we'll restore mode at the end)
  over swap find-next-word  # Buffer NewCursor
  # Clamp to len-1 for normal mode
  over string.length 1 i.subtract 0 int-max int-min  # Buffer ClampedCursor
  mode-normal true ;

: normal-key-b ( String Int Int -- String Int Int Bool )
  # Move to previous word: Buffer Cursor Mode -> Buffer NewCursor Mode true
  # Stack: Buffer Cursor Mode
  drop  # Buffer Cursor
  over swap find-prev-word  # Buffer NewCursor
  mode-normal true ;

: do-replace-char ( String Int Int -- String )
  # Replace char at position with new char: Buffer Cursor Char -> NewBuffer
  rot rot  # Char Buffer Cursor
  over over string-delete-at  # Char Buffer Cursor TmpBuffer
  rot drop  # Char TmpBuffer Cursor
  swap rot  # TmpBuffer Cursor Char
  string-insert-at ;

: normal-key-r ( String Int Int -- String Int Int Bool )
  # Replace character under cursor
  # Stack: Buffer Cursor Mode
  terminal.read-char
  dup 27 i.= over 0 i.< or if
    # Escape or error - cancel
    drop true
  else
    # Stack: Buffer Cursor Mode Char
    3 pick string.length 3 pick i.> if
      # Cursor valid - do replacement
      # Stack: Buffer Cursor Mode Char
      # Drop Mode now, we'll restore it at the end
      swap drop  # Buffer Cursor Char
      # Compute NewBuffer: delete then insert
      2 pick 2 pick string-delete-at  # Buffer Cursor Char TmpBuffer
      2 pick 2 pick string-insert-at  # Buffer Cursor Char NewBuffer
      # Stack: Buffer Cursor Char NewBuffer
      # Get copy of Cursor for result
      2 pick  # Buffer Cursor Char NewBuffer Cursor2
      # Drop garbage, keep NewBuffer and Cursor2
      rot drop rot drop rot drop  # NewBuffer Cursor2
      # Restore mode and return
      mode-normal true
    else
      drop true
    then
  then ;

# ============================================
# Operator Handlers (d, c)
# ============================================

# D - delete to end of line (same as d$)
: normal-key-D ( String Int Int -- String Int Int Bool )
  # Stack: Buffer Cursor Mode
  drop  # Buffer Cursor
  swap 0 rot string.substring  # NewBuffer (Buffer[0..Cursor])
  dup string.length 1 i.subtract 0 int-max  # NewBuffer NewCursor
  mode-normal true ;

# Operator: d (delete)
: normal-key-d ( String Int Int -- String Int Int Bool )
  # Stack: Buffer Cursor Mode
  terminal.read-char
  dup 27 i.= over 0 i.< or if
    # Escape or error - cancel
    drop true
  else
    dup 100 i.= if
      # dd - delete entire line
      drop drop drop drop
      "" 0 mode-normal true
    else
      dup 36 i.= if
        # d$ - delete to end of line
        drop normal-key-D
      else
        # Unknown motion - ignore for now
        drop true
      then
    then
  then ;

# C - change to end of line (same as c$)
: normal-key-C ( String Int Int -- String Int Int Bool )
  # Stack: Buffer Cursor Mode
  drop  # Buffer Cursor
  swap 0 rot string.substring  # NewBuffer (Buffer[0..Cursor])
  dup string.length  # NewBuffer Cursor (cursor at end of truncated string)
  mode-insert true ;

# Operator: c (change = delete + insert mode)
: normal-key-c ( String Int Int -- String Int Int Bool )
  # Stack: Buffer Cursor Mode
  terminal.read-char
  dup 27 i.= over 0 i.< or if
    # Escape or error - cancel
    drop true
  else
    dup 99 i.= if
      # cc - change entire line
      drop drop drop drop
      "" 0 mode-insert true
    else
      dup 36 i.= if
        # c$ - change to end of line
        drop normal-key-C
      else
        # Unknown motion - ignore for now
        drop true
      then
    then
  then ;

# ============================================
# Insert Mode Key Handlers
# ============================================

: insert-backspace ( String Int Int -- String Int Int Bool )
  # Input: Buffer Cursor Mode
  over 0 i.> if
    # Cursor > 0, do backspace
    drop  # Buffer Cursor (drop Mode)
    1 i.subtract  # Buffer NewCursor
    over over string-delete-at  # Buffer NewCursor NewBuffer
    rot drop  # NewCursor NewBuffer
    swap  # NewBuffer NewCursor
    mode-insert  # NewBuffer NewCursor mode-insert
  then
  true ;

: insert-char ( String Int Int Int -- String Int Int Bool )
  # Input: Buffer Cursor Mode Char
  # Stack positions: Buffer(3) Cursor(2) Mode(1) Char(0)
  # We need to call string-insert-at(Buffer, Cursor, Char)
  3 pick  # ... Buffer  (positions shift: Char now at 1)
  3 pick  # ... Buffer Cursor  (positions shift: Char now at 2)
  2 pick  # ... Buffer Cursor Char
  string-insert-at  # Buffer Cursor Mode Char NewBuffer
  # Compute NewCursor = Cursor + 1
  3 pick 1 i.add  # Buffer Cursor Mode Char NewBuffer NewCursor
  # Drop old values, keep NewBuffer and NewCursor
  rot drop rot drop rot drop rot drop
  mode-insert true ;

# ============================================
# Main Key Dispatch
# ============================================

: handle-key ( String Int Int Int -- String Int Int Bool )
  # Stack: Buffer Cursor Mode Key
  over mode-insert i.= if
    handle-insert-key
  else
    handle-normal-key
  then ;

: handle-normal-key ( String Int Int Int -- String Int Int Bool )
  dup 104 i.= over key-left i.= or if drop normal-key-h else   # h or Left - left
  dup 108 i.= over key-right i.= or if drop normal-key-l else  # l or Right - right
  dup 119 i.= if drop normal-key-w else  # w - next word
  dup 98 i.= if drop normal-key-b else   # b - prev word
  dup 48 i.= if drop normal-key-0 else   # 0 - start of line
  dup 36 i.= if drop normal-key-$ else   # $ - end of line
  dup 105 i.= if drop normal-key-i else  # i - insert
  dup 97 i.= if drop normal-key-a else   # a - append
  dup 65 i.= if drop normal-key-A else   # A - append at end
  dup 73 i.= if drop normal-key-I else   # I - insert at start
  dup 120 i.= if drop normal-key-x else  # x - delete char
  dup 114 i.= if drop normal-key-r else  # r - replace char
  dup 100 i.= if drop normal-key-d else  # d - delete operator
  dup 99 i.= if drop normal-key-c else   # c - change operator
  dup 68 i.= if drop normal-key-D else   # D - delete to end
  dup 67 i.= if drop normal-key-C else   # C - change to end
  dup key-enter i.= if drop false else
  dup key-newline i.= if drop false else
  dup key-ctrl-c i.= if drop rot drop drop "" 0 rot false else
  dup key-ctrl-d i.= if drop rot drop drop "" 0 rot false else
  drop true
  then then then then then then then then then then then then then then then then then then then then ;

: handle-insert-key ( String Int Int Int -- String Int Int Bool )
  dup key-escape i.= if
    # Escape: return to normal mode, clamp cursor
    drop drop  # Buffer Cursor (dropped Key and Mode)
    2dup clamp-cursor-normal  # Buffer Cursor NewCursor
    nip  # Buffer NewCursor
    mode-normal true
  else
  dup key-left i.= if
    # Left arrow: move cursor left, stay in insert mode
    drop drop  # Buffer Cursor
    dup 0 i.> if 1 i.subtract then
    mode-insert true
  else
  dup key-right i.= if
    # Right arrow: move cursor right, stay in insert mode
    drop drop  # Buffer Cursor
    over string.length over i.> if 1 i.add then
    mode-insert true
  else
  dup key-enter i.= if drop false else
  dup key-newline i.= if drop false else
  dup key-backspace i.= if drop insert-backspace else
  dup key-ctrl-h i.= if drop insert-backspace else
  dup key-ctrl-c i.= if drop drop drop drop "" 0 mode-normal false else
  dup 32 i.>= over 126 i.<= and if insert-char else
  drop true
  then then then then then then then then then ;

# ============================================
# Main Editor
# ============================================

# Edit result codes
: edit-done    ( -- Int ) 0 ;  # Normal completion (Enter pressed)
: edit-hist-up ( -- Int ) 1 ;  # Request history up (k pressed)
: edit-hist-dn ( -- Int ) 2 ;  # Request history down (j pressed)

# Edit a string with vim keybindings
# ( History Prompt InitialBuffer -- History FinalBuffer )
: vim-edit ( Sexpr String String -- Sexpr String )
  # Stack: History Prompt Buffer
  true terminal.raw-mode
  0 vim-edit-with-histpos  # Start with HistPos=0
  false terminal.raw-mode
  "\r\n" io.write ;

# Inner editor that handles history position
# ( History Prompt Buffer HistPos -- History FinalBuffer )
: vim-edit-with-histpos ( Sexpr String String Int -- Sexpr String )
  # Stack: History Prompt Buffer HistPos
  swap dup string.length mode-normal
  # Stack: History Prompt HistPos Buffer Cursor Mode
  vim-edit-inner
  # Stack: History Prompt HistPos Buffer ResultCode
  # Check result code
  dup edit-hist-up i.= if
    # Navigate up in history
    drop  # History Prompt HistPos Buffer
    # Stack: History(3) Prompt(2) HistPos(1) Buffer(0)
    3 pick history-length 2 pick i.> if
      # Can go up: increment histpos, get history entry
      swap 1 i.add  # History Prompt Buffer NewHistPos
      dup 4 pick swap history-get  # History Prompt Buffer NewHistPos HistEntry
      rot drop swap  # History Prompt HistEntry NewHistPos
      vim-edit-with-histpos
    else
      # Can't go up, restart with same buffer
      swap vim-edit-with-histpos
    then
  else
    dup edit-hist-dn i.= if
      # Navigate down in history
      drop  # History Prompt HistPos Buffer
      # Check if can go down
      over 0 i.> if
        # Can go down: decrement histpos
        swap 1 i.subtract  # History Prompt Buffer NewHistPos
        dup 0 i.= if
          # Back to position 0, use empty buffer
          swap drop "" swap  # History Prompt "" NewHistPos
          vim-edit-with-histpos
        else
          # Get history entry at new position
          dup 4 pick swap history-get  # History Prompt Buffer NewHistPos HistEntry
          rot drop swap  # History Prompt HistEntry NewHistPos
          vim-edit-with-histpos
        then
      else
        # Already at 0, restart with same buffer
        swap vim-edit-with-histpos
      then
    else
      # Normal completion (edit-done)
      drop  # History(3) Prompt(2) HistPos(1) Buffer(0)
      # Keep History and Buffer, drop Prompt and HistPos
      # Don't add to history here - caller will do it when expression is complete
      3 pick 1 pick  # ... History Buffer
      rot drop rot drop rot drop rot drop  # History Buffer
    then
  then ;

# Core edit loop - returns Buffer and ResultCode
# ( History Prompt HistPos Buffer Cursor Mode -- History Prompt HistPos Buffer ResultCode )
: vim-edit-inner ( Sexpr String Int String Int Int -- Sexpr String Int String Int )
  # Render current state: vim-render(Prompt Buffer Cursor Mode)
  # Stack: History(5) Prompt(4) HistPos(3) Buffer(2) Cursor(1) Mode(0)
  4 pick 3 pick 3 pick 3 pick vim-render
  # Read a key (handles arrow key escape sequences)
  read-key
  dup 0 i.< if
    # Error reading key, return done
    drop drop drop edit-done
  else
    # Check for history navigation
    # Stack: History(6) Prompt(5) HistPos(4) Buffer(3) Cursor(2) Mode(1) Key(0)
    # Up arrow always navigates history
    dup key-up i.= if
      drop drop drop edit-hist-up
    else
      # k navigates history in normal mode
      dup 107 i.= 2 pick mode-normal i.= and if
        drop drop drop edit-hist-up
      else
        # Down arrow always navigates history
        dup key-down i.= if
          drop drop drop edit-hist-dn
        else
          # j navigates history in normal mode
          dup 106 i.= 2 pick mode-normal i.= and if
            drop drop drop edit-hist-dn
          else
            # Regular key handling
            handle-key
            # Stack: History Prompt HistPos NewBuffer NewCursor NewMode Continue?
            if
              vim-edit-inner
            else
              drop drop edit-done
            then
          then
        then
      then
    then
  then ;
