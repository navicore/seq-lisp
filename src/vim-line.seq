# vim-line.seq - Vim-style line editor for SeqLisp REPL
#
# A minimal vim-like editor written in pure Seq, using the terminal FFI.
# Implements modal editing (Normal/Insert) with basic motions.
#
# Usage:
#   "prompt> " "" vim-edit  # Returns edited string on Enter

# ============================================
# Constants
# ============================================

# Editor modes
: mode-normal ( -- Int ) 0 ;
: mode-insert ( -- Int ) 1 ;

# Key codes
: key-escape    ( -- Int ) 27 ;
: key-enter     ( -- Int ) 13 ;
: key-newline   ( -- Int ) 10 ;
: key-backspace ( -- Int ) 127 ;
: key-ctrl-h    ( -- Int ) 8 ;
: key-ctrl-c    ( -- Int ) 3 ;
: key-ctrl-d    ( -- Int ) 4 ;

# ============================================
# Integer Helpers (missing from Seq stdlib)
# ============================================

: int-min ( Int Int -- Int )
  2dup i.< if drop else nip then ;

: int-max ( Int Int -- Int )
  2dup i.> if drop else nip then ;

: int-mod ( Int Int -- Int )
  # a b -- a mod b = a - (a / b) * b
  2dup i.divide i.multiply i.subtract ;

# ============================================
# Character Classification
# ============================================

# Check if character code is whitespace (space, tab)
: is-whitespace ( Int -- Bool )
  dup 32 i.= swap 9 i.= or ;

# Check if character code is a word character (letter, digit, underscore)
: is-word-char ( Int -- Bool )
  dup 48 i.>= over 57 i.<= and if drop true else  # 0-9
  dup 65 i.>= over 90 i.<= and if drop true else  # A-Z
  dup 97 i.>= over 122 i.<= and if drop true else  # a-z
  95 i.=  # underscore
  then then then ;

# ============================================
# History Management
# ============================================

# History is stored as an slist of SString values (newest first)
# We use the sexpr types from the Lisp implementation

# Create empty history
: history-empty ( -- History )
  snil ;

# Add entry to history (prepends to front = newest first)
# Only adds if non-empty and different from most recent
: history-add ( History String -- History )
  dup string.empty? if
    drop  # Don't add empty strings
  else
    over snil? if
      # Empty history, just add
      sstring scons
    else
      # Check if same as most recent
      over scar sstring-val 2 pick string.equal? if
        drop  # Same as last, don't add duplicate
      else
        sstring scons
      then
    then
  then ;

# Get history length
: history-length ( History -- Int )
  0 history-length-loop ;

: history-length-loop ( History Int -- Int )
  over snil? if
    nip
  else
    1 i.add swap scdr swap history-length-loop
  then ;

# Get nth history entry (1-indexed, 1 = most recent)
# Returns empty string if out of bounds
: history-get ( History Int -- String )
  # Stack: History N
  dup 1 i.< if
    drop drop ""  # Invalid index
  else
    history-get-loop
  then ;

: history-get-loop ( History Int -- String )
  # Stack: History N
  over snil? if
    drop drop ""  # Past end of history
  else
    dup 1 i.= if
      # Found it
      drop scar sstring-val
    else
      # Keep looking
      1 i.subtract swap scdr swap history-get-loop
    then
  then ;

# ============================================
# Word Motion Helpers
# ============================================

# Find next word start position from current position
# Skips current word (if in one), then skips whitespace
: find-next-word ( String Int -- Int )
  # Stack: Str Pos
  over string.length  # Str Pos Len
  2dup i.>= if
    # Already at or past end
    drop nip  # Return Len (clamped later)
  else
    # Skip non-whitespace (current word)
    find-next-word-skip-word
  then ;

: find-next-word-skip-word ( String Int Int -- Int )
  # Stack: Str Pos Len
  2dup i.>= if
    drop nip
  else
    2 pick 2 pick string.char-at is-whitespace if
      # Found whitespace, now skip it
      find-next-word-skip-space
    else
      # Still in word, advance
      swap 1 i.add swap find-next-word-skip-word
    then
  then ;

: find-next-word-skip-space ( String Int Int -- Int )
  # Stack: Str Pos Len
  2dup i.>= if
    drop nip
  else
    2 pick 2 pick string.char-at is-whitespace if
      # Still whitespace, advance
      swap 1 i.add swap find-next-word-skip-space
    else
      # Found start of next word
      drop nip
    then
  then ;

# Find previous word start position from current position
: find-prev-word ( String Int -- Int )
  # Stack: Str Pos
  dup 0 i.<= if
    drop drop 0  # Already at start, return 0
  else
    # Move back one first
    1 i.subtract
    find-prev-word-skip-space
  then ;

: find-prev-word-skip-space ( String Int -- Int )
  # Stack: Str Pos
  dup 0 i.< if
    drop drop 0
  else
    over over string.char-at is-whitespace if
      dup 0 i.<= if
        drop drop 0
      else
        1 i.subtract find-prev-word-skip-space
      then
    else
      find-prev-word-skip-word
    then
  then ;

: find-prev-word-skip-word ( String Int -- Int )
  # Stack: Str Pos - we're in a word, find its start
  dup 0 i.<= if
    drop drop 0
  else
    over over string.char-at is-whitespace not if
      dup 0 i.<= if
        drop drop 0
      else
        1 i.subtract find-prev-word-skip-word
      then
    else
      # Hit whitespace, the word starts at pos+1
      nip 1 i.add
    then
  then ;

# ============================================
# String Helpers
# ============================================

# Delete character at position: ( Str Pos -- NewStr )
# string.substring takes (Str Start Len -- Substr)
: string-delete-at ( String Int -- String )
  over string.length over i.<= if
    drop  # Position beyond string - return unchanged
  else
    # Stack: Str Pos
    2dup 0 swap string.substring  # Before: Str[0..Pos]
    # Stack: Str Pos Before
    rot rot  # Stack: Before Str Pos
    1 i.add    # Stack: Before Str Pos+1
    over string.length over i.subtract  # Stack: Before Str Pos+1 Len-Pos-1
    string.substring  # After: Str[Pos+1..end]
    # Stack: Before After
    string.concat
  then ;

# Insert character at position: ( Str Pos Char -- NewStr )
: string-insert-at ( String Int Int -- String )
  # Stack: Str Pos Char
  char->string  # Stack: Str Pos CharStr
  rot rot  # Stack: CharStr Str Pos
  2dup 0 swap string.substring  # Before: Str[0..Pos]
  # Stack: CharStr Str Pos Before
  rot rot  # Stack: CharStr Before Str Pos
  over string.length over i.subtract  # Stack: CharStr Before Str Pos Len-Pos
  string.substring  # After: Str[Pos..end]
  # Stack: CharStr Before After
  # Result: Before + CharStr + After
  rot swap string.concat string.concat ;

# ============================================
# Cursor Helpers
# ============================================

# Clamp cursor to valid range for normal mode (0 to len-1, or 0 if empty)
: clamp-cursor-normal ( String Int -- Int )
  over string.length
  dup 0 i.= if
    drop drop drop 0  # Drop Len, Cursor, Str -> push 0
  else
    1 i.subtract int-min 0 int-max nip  # Compute clamped cursor, drop Str
  then ;

# Clamp cursor to valid range for insert mode (0 to len)
: clamp-cursor-insert ( String Int -- Int )
  over string.length int-min 0 int-max nip ;

# ============================================
# Rendering
# ============================================

# Render: clear line, show prompt, show buffer, position cursor
: vim-render ( String String Int Int -- )
  # Stack: Prompt Buffer Cursor Mode
  "\r\x1b[2K" io.write  # Clear line first
  # Show mode indicator
  dup mode-insert i.= if "● " io.write else "○ " io.write then
  drop  # Drop mode -> Prompt Buffer Cursor
  rot io.write  # Write prompt -> Buffer Cursor
  over io.write  # Write buffer -> Buffer Cursor
  # Move cursor: we're at end of buffer, need to go back (buflen - cursor) chars
  over string.length swap i.subtract  # -> Buffer Diff
  dup 0 i.> if
    "\x1b[" io.write
    int-to-string io.write
    "D" io.write
  else
    drop
  then
  drop  # Drop Buffer
  terminal.flush ;

# Convert int to string (simple, positive only)
: int-to-string ( Int -- String )
  dup 0 i.= if
    drop "0"
  else
    "" swap int-to-string-loop
  then ;

: int-to-string-loop ( String Int -- String )
  dup 0 i.= if
    drop
  else
    dup 10 int-mod 48 i.add char->string rot string.concat swap
    10 i./ int-to-string-loop
  then ;

# ============================================
# Normal Mode Key Handlers
# ============================================

# Each returns: ( Buf Cur Mode -- NewBuf NewCur NewMode Continue? )

: normal-key-h ( String Int Int -- String Int Int Bool )
  swap dup 0 i.> if 1 i.subtract then swap true ;

: normal-key-l ( String Int Int -- String Int Int Bool )
  # Move cursor right if not at end (cursor < len-1)
  2 pick string.length 1 i.subtract  # Stack: ... (len-1)
  2 pick i.> if swap 1 i.add swap then true ;  # if (len-1) > cursor

: normal-key-0 ( String Int Int -- String Int Int Bool )
  swap drop 0 swap true ;

: normal-key-$ ( String Int Int -- String Int Int Bool )
  swap drop over string.length dup 0 i.> if 1 i.subtract then swap true ;

: normal-key-i ( String Int Int -- String Int Int Bool )
  drop mode-insert true ;

: normal-key-a ( String Int Int -- String Int Int Bool )
  drop  # Buffer Cursor
  over string.length over i.> if  # If len > cursor
    1 i.add  # Increment cursor
  then
  mode-insert true ;

: normal-key-A ( String Int Int -- String Int Int Bool )
  drop  # Buffer Cursor
  drop  # Buffer (discard old cursor)
  dup string.length  # Buffer NewCursor (cursor at end)
  mode-insert true ;

: normal-key-I ( String Int Int -- String Int Int Bool )
  drop  # Buffer Cursor
  drop  # Buffer (discard old cursor)
  0 mode-insert true ;  # Buffer 0 Mode true

: normal-key-x ( String Int Int -- String Int Int Bool )
  # Stack: Buffer Cursor Mode
  # Check if buffer length > cursor (cursor is within bounds)
  2 pick string.length 2 pick i.> if
    # Delete char and clamp cursor
    rot rot  # Mode Buffer Cursor
    over over string-delete-at  # Mode Buffer Cursor NewBuffer
    swap over swap clamp-cursor-normal  # Mode Buffer NewBuffer NewCursor
    rot drop  # Mode NewBuffer NewCursor
    rot  # NewBuffer NewCursor Mode
  then
  true ;

: normal-key-w ( String Int Int -- String Int Int Bool )
  # Move to next word: Buffer Cursor Mode -> Buffer NewCursor Mode true
  # Stack: Buffer Cursor Mode
  drop  # Buffer Cursor (we'll restore mode at the end)
  over swap find-next-word  # Buffer NewCursor
  # Clamp to len-1 for normal mode
  over string.length 1 i.subtract 0 int-max int-min  # Buffer ClampedCursor
  mode-normal true ;

: normal-key-b ( String Int Int -- String Int Int Bool )
  # Move to previous word: Buffer Cursor Mode -> Buffer NewCursor Mode true
  # Stack: Buffer Cursor Mode
  drop  # Buffer Cursor
  over swap find-prev-word  # Buffer NewCursor
  mode-normal true ;

: do-replace-char ( String Int Int -- String )
  # Replace char at position with new char: Buffer Cursor Char -> NewBuffer
  rot rot  # Char Buffer Cursor
  over over string-delete-at  # Char Buffer Cursor TmpBuffer
  rot drop  # Char TmpBuffer Cursor
  swap rot  # TmpBuffer Cursor Char
  string-insert-at ;

: normal-key-r ( String Int Int -- String Int Int Bool )
  # Replace character under cursor
  # Stack: Buffer Cursor Mode
  terminal.read-char
  dup 27 i.= over 0 i.< or if
    # Escape or error - cancel
    drop true
  else
    # Stack: Buffer Cursor Mode Char
    3 pick string.length 3 pick i.> if
      # Cursor valid - do replacement
      # Stack: Buffer Cursor Mode Char
      # Drop Mode now, we'll restore it at the end
      swap drop  # Buffer Cursor Char
      # Compute NewBuffer: delete then insert
      2 pick 2 pick string-delete-at  # Buffer Cursor Char TmpBuffer
      2 pick 2 pick string-insert-at  # Buffer Cursor Char NewBuffer
      # Stack: Buffer Cursor Char NewBuffer
      # Get copy of Cursor for result
      2 pick  # Buffer Cursor Char NewBuffer Cursor2
      # Drop garbage, keep NewBuffer and Cursor2
      rot drop rot drop rot drop  # NewBuffer Cursor2
      # Restore mode and return
      mode-normal true
    else
      drop true
    then
  then ;

# ============================================
# Insert Mode Key Handlers
# ============================================

: insert-backspace ( String Int Int -- String Int Int Bool )
  # Input: Buffer Cursor Mode
  over 0 i.> if
    # Cursor > 0, do backspace
    drop  # Buffer Cursor (drop Mode)
    1 i.subtract  # Buffer NewCursor
    over over string-delete-at  # Buffer NewCursor NewBuffer
    rot drop  # NewCursor NewBuffer
    swap  # NewBuffer NewCursor
    mode-insert  # NewBuffer NewCursor mode-insert
  then
  true ;

: insert-char ( String Int Int Int -- String Int Int Bool )
  # Input: Buffer Cursor Mode Char
  # Stack positions: Buffer(3) Cursor(2) Mode(1) Char(0)
  # We need to call string-insert-at(Buffer, Cursor, Char)
  3 pick  # ... Buffer  (positions shift: Char now at 1)
  3 pick  # ... Buffer Cursor  (positions shift: Char now at 2)
  2 pick  # ... Buffer Cursor Char
  string-insert-at  # Buffer Cursor Mode Char NewBuffer
  # Compute NewCursor = Cursor + 1
  3 pick 1 i.add  # Buffer Cursor Mode Char NewBuffer NewCursor
  # Drop old values, keep NewBuffer and NewCursor
  rot drop rot drop rot drop rot drop
  mode-insert true ;

# ============================================
# Main Key Dispatch
# ============================================

: handle-key ( String Int Int Int -- String Int Int Bool )
  # Stack: Buffer Cursor Mode Key
  over mode-insert i.= if
    handle-insert-key
  else
    handle-normal-key
  then ;

: handle-normal-key ( String Int Int Int -- String Int Int Bool )
  dup 104 i.= if drop normal-key-h else  # h - left
  dup 108 i.= if drop normal-key-l else  # l - right
  dup 119 i.= if drop normal-key-w else  # w - next word
  dup 98 i.= if drop normal-key-b else   # b - prev word
  dup 48 i.= if drop normal-key-0 else   # 0 - start of line
  dup 36 i.= if drop normal-key-$ else   # $ - end of line
  dup 105 i.= if drop normal-key-i else  # i - insert
  dup 97 i.= if drop normal-key-a else   # a - append
  dup 65 i.= if drop normal-key-A else   # A - append at end
  dup 73 i.= if drop normal-key-I else   # I - insert at start
  dup 120 i.= if drop normal-key-x else  # x - delete char
  dup 114 i.= if drop normal-key-r else  # r - replace char
  dup key-enter i.= if drop false else
  dup key-newline i.= if drop false else
  dup key-ctrl-c i.= if drop rot drop "" rot rot false else
  dup key-ctrl-d i.= if drop rot drop "" rot rot false else
  drop true
  then then then then then then then then then then then then then then then then ;

: handle-insert-key ( String Int Int Int -- String Int Int Bool )
  dup key-escape i.= if
    # Escape: return to normal mode, clamp cursor
    drop drop  # Buffer Cursor (dropped Key and Mode)
    2dup clamp-cursor-normal  # Buffer Cursor NewCursor
    nip  # Buffer NewCursor
    mode-normal true
  else
  dup key-enter i.= if drop false else
  dup key-newline i.= if drop false else
  dup key-backspace i.= if drop insert-backspace else
  dup key-ctrl-h i.= if drop insert-backspace else
  dup key-ctrl-c i.= if drop drop drop drop "" 0 mode-normal false else
  dup 32 i.>= over 126 i.<= and if insert-char else
  drop true
  then then then then then then then ;

# ============================================
# Main Editor
# ============================================

# Edit result codes
: edit-done    ( -- Int ) 0 ;  # Normal completion (Enter pressed)
: edit-hist-up ( -- Int ) 1 ;  # Request history up (k pressed)
: edit-hist-dn ( -- Int ) 2 ;  # Request history down (j pressed)

# Edit a string with vim keybindings
# ( History Prompt InitialBuffer -- History FinalBuffer )
: vim-edit ( Sexpr String String -- Sexpr String )
  # Stack: History Prompt Buffer
  true terminal.raw-mode
  0 vim-edit-with-histpos  # Start with HistPos=0
  false terminal.raw-mode
  "\r\n" io.write ;

# Inner editor that handles history position
# ( History Prompt Buffer HistPos -- History FinalBuffer )
: vim-edit-with-histpos ( Sexpr String String Int -- Sexpr String )
  # Stack: History Prompt Buffer HistPos
  rot dup string.length mode-normal
  # Stack: History Prompt HistPos Buffer Cursor Mode
  vim-edit-inner
  # Stack: History Prompt HistPos Buffer ResultCode
  # Check result code
  dup edit-hist-up i.= if
    # Navigate up in history
    drop  # History Prompt HistPos Buffer
    # Check if can go up
    3 pick history-length 2 pick i.> if
      # Can go up: increment histpos, get history entry
      swap 1 i.add  # History Prompt Buffer NewHistPos
      dup 3 pick swap history-get  # History Prompt Buffer NewHistPos HistEntry
      rot drop swap  # History Prompt HistEntry NewHistPos
      vim-edit-with-histpos
    else
      # Can't go up, restart with same buffer
      swap vim-edit-with-histpos
    then
  else
    dup edit-hist-dn i.= if
      # Navigate down in history
      drop  # History Prompt HistPos Buffer
      # Check if can go down
      over 0 i.> if
        # Can go down: decrement histpos
        swap 1 i.subtract  # History Prompt Buffer NewHistPos
        dup 0 i.= if
          # Back to position 0, use empty buffer
          rot drop ""  # History Prompt NewHistPos ""
          swap vim-edit-with-histpos
        else
          # Get history entry at new position
          dup 3 pick swap history-get  # History Prompt Buffer NewHistPos HistEntry
          rot drop swap  # History Prompt HistEntry NewHistPos
          vim-edit-with-histpos
        then
      else
        # Already at 0, restart with same buffer
        swap vim-edit-with-histpos
      then
    else
      # Normal completion (edit-done)
      drop  # History Prompt HistPos Buffer
      # Add to history and return
      swap drop  # History Prompt Buffer
      rot drop   # History Buffer
      over over history-add  # History Buffer NewHistory
      rot drop   # Buffer NewHistory
      swap       # NewHistory Buffer
    then
  then ;

# Core edit loop - returns Buffer and ResultCode
# ( History Prompt HistPos Buffer Cursor Mode -- History Prompt HistPos Buffer ResultCode )
: vim-edit-inner ( Sexpr String Int String Int Int -- Sexpr String Int String Int )
  # Render current state: vim-render(Prompt Buffer Cursor Mode)
  # Stack: History(5) Prompt(4) HistPos(3) Buffer(2) Cursor(1) Mode(0)
  4 pick 3 pick 3 pick 3 pick vim-render
  # Read a key
  terminal.read-char
  dup 0 i.< if
    # Error reading key, return done
    drop drop drop edit-done
  else
    # Check for history navigation (j/k in normal mode)
    dup 107 i.= 2 pick mode-normal i.= and if  # k in normal mode
      drop drop drop edit-hist-up
    else
      dup 106 i.= 2 pick mode-normal i.= and if  # j in normal mode
        drop drop drop edit-hist-dn
      else
        # Regular key handling
        handle-key
        # Stack: History Prompt HistPos NewBuffer NewCursor NewMode Continue?
        if
          vim-edit-inner
        else
          drop drop edit-done
        then
      then
    then
  then ;
