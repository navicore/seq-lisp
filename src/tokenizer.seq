# Tokenizer for SeqLisp - Using ADTs
#
# Uses explicit state variant to avoid complex stack manipulation

# ============================================
# Type Definitions
# ============================================

union TokenList {
  TNil
  TCons { token: String, rest: TokenList }
}

union TokState {
  TState { input: String, pos: Int, current_token: String, tokens: TokenList }
}

# ============================================
# Token List Constructors and Accessors
# ============================================

: tnil ( -- TokenList )
  Make-TNil ;

: tcons ( String TokenList -- TokenList )
  Make-TCons ;

: tnil? ( TokenList -- Int )
  variant.tag 0 = ;

: tcar ( TokenList -- String )
  0 variant.field-at ;

: tcdr ( TokenList -- TokenList )
  1 variant.field-at ;

: trev ( TokenList -- TokenList )
  tnil trev-loop ;

: trev-loop ( TokenList TokenList -- TokenList )
  swap dup tnil? if drop else
    dup tcar rot tcons swap tcdr swap trev-loop
  then
;

# ============================================
# Tokenizer State Constructors and Accessors
# ============================================

: make-state ( String Int String TokenList -- TokState )
  Make-TState ;

: state-input ( TokState -- String )
  0 variant.field-at ;

: state-pos ( TokState -- Int )
  1 variant.field-at ;

: state-tok ( TokState -- String )
  2 variant.field-at ;

: state-list ( TokState -- TokenList )
  3 variant.field-at ;

# ============================================
# Simple tokenizer
# ============================================

: tokenize ( String -- TokenList )
  0 "" tnil make-state
  tokenize-loop
  state-list trev
;

: tokenize-loop ( TokState -- TokState )
  dup state-input string.length
  over state-pos <= if
    # Done - flush any remaining token
    dup state-tok string.empty? if
      # Nothing to flush - keep state as is (do nothing)
    else
      # Flush final token using consistent pattern
      dup state-input
      over state-pos
      2 pick state-list
      3 pick state-tok
      swap tcons
      "" swap
      make-state nip
    then
  else
    # Get current char code at position
    dup state-input over state-pos string.char-at
    # Stack: State CharCode

    dup 32 = over 10 = or over 9 = or over 13 = or if
      # Whitespace
      drop handle-space tokenize-loop
    else
      dup 59 = if
        # Semicolon - start of comment, skip to end of line
        drop handle-comment tokenize-loop
      else
        dup 40 = if
          # Left paren
          drop handle-lparen tokenize-loop
        else
          dup 41 = if
            # Right paren
            drop handle-rparen tokenize-loop
          else
            dup 39 = if
              # Single quote - emit as its own token
              drop handle-quote tokenize-loop
            else
              dup 96 = if
                # Backtick (quasiquote) - emit as its own token
                drop handle-backtick tokenize-loop
              else
                dup 44 = if
                  # Comma (unquote) - check for ,@
                  drop handle-comma tokenize-loop
                else
                  # Regular char
                  drop handle-char tokenize-loop
                then
              then
            then
          then
        then
      then
    then
  then
;

# Flush current token (if any) and reset
: handle-space ( TokState -- TokState )
  dup state-tok string.empty? if
    advance-pos
  else
    # Flush token and advance
    dup state-input
    over state-pos 1 add
    2 pick state-list
    3 pick state-tok
    swap tcons
    "" swap
    make-state nip
  then
;

# Flush token, add "(", advance
: handle-lparen ( TokState -- TokState )
  dup state-tok string.empty? if
    # Just add "(" to list and advance
    dup state-input
    over state-pos 1 add
    2 pick state-list
    "(" swap tcons
    "" swap
    make-state nip
  else
    # Flush token, then add "("
    dup state-input
    over state-pos 1 add
    2 pick state-list
    3 pick state-tok
    swap tcons
    "(" swap tcons
    "" swap
    make-state nip
  then
;

# Flush token, add ")", advance
: handle-rparen ( TokState -- TokState )
  dup state-tok string.empty? if
    # Just add ")" to list and advance
    dup state-input
    over state-pos 1 add
    2 pick state-list
    ")" swap tcons
    "" swap
    make-state nip
  else
    # Flush token, then add ")"
    dup state-input
    over state-pos 1 add
    2 pick state-list
    3 pick state-tok
    swap tcons
    ")" swap tcons
    "" swap
    make-state nip
  then
;

# Flush token, add "'", advance
: handle-quote ( TokState -- TokState )
  dup state-tok string.empty? if
    # Just add "'" to list and advance
    dup state-input
    over state-pos 1 add
    2 pick state-list
    "'" swap tcons
    "" swap
    make-state nip
  else
    # Flush token, then add "'"
    dup state-input
    over state-pos 1 add
    2 pick state-list
    3 pick state-tok
    swap tcons
    "'" swap tcons
    "" swap
    make-state nip
  then
;

# Flush token, add "`", advance (quasiquote)
: handle-backtick ( TokState -- TokState )
  dup state-tok string.empty? if
    # Just add "`" to list and advance
    dup state-input
    over state-pos 1 add
    2 pick state-list
    "`" swap tcons
    "" swap
    make-state nip
  else
    # Flush token, then add "`"
    dup state-input
    over state-pos 1 add
    2 pick state-list
    3 pick state-tok
    swap tcons
    "`" swap tcons
    "" swap
    make-state nip
  then
;

# Handle comma - check for ,@ (unquote-splicing) vs , (unquote)
: handle-comma ( TokState -- TokState )
  # First flush any current token
  dup state-tok string.empty? if
    handle-comma-check
  else
    # Flush token first
    dup state-input
    over state-pos
    2 pick state-list
    3 pick state-tok
    swap tcons
    "" swap
    make-state nip
    handle-comma-check
  then
;

# Check if next char is @ for ,@
: handle-comma-check ( TokState -- TokState )
  # Check if there's a next character
  dup state-input string.length
  over state-pos 1 add > if
    # There's a next char - check if it's @
    dup state-input over state-pos 1 add string.char-at
    64 = if
      # It's ,@ - emit ",@" and advance by 2
      dup state-input
      over state-pos 2 add
      2 pick state-list
      ",@" swap tcons
      "" swap
      make-state nip
    else
      # Just , - emit "," and advance by 1
      dup state-input
      over state-pos 1 add
      2 pick state-list
      "," swap tcons
      "" swap
      make-state nip
    then
  else
    # No next char - just emit ","
    dup state-input
    over state-pos 1 add
    2 pick state-list
    "," swap tcons
    "" swap
    make-state nip
  then
;

# Skip comment (everything from ; to end of line)
: handle-comment ( TokState -- TokState )
  # First flush any current token
  dup state-tok string.empty? if
    skip-to-eol
  else
    # Flush token first, then skip
    dup state-input
    over state-pos
    2 pick state-list
    3 pick state-tok
    swap tcons
    "" swap
    make-state nip
    skip-to-eol
  then
;

# Skip characters until newline or end of input
: skip-to-eol ( TokState -- TokState )
  dup state-input string.length
  over state-pos <= if
    # End of input, done
  else
    dup state-input over state-pos string.char-at
    10 = if
      # Found newline, advance past it
      advance-pos
    else
      # Keep skipping
      advance-pos skip-to-eol
    then
  then
;

# Add char to current token, advance
: handle-char ( TokState -- TokState )
  # Build (Input, Pos+1, Tok++Char, List)
  dup state-input
  over state-pos 1 add
  2 pick state-list
  3 pick state-tok
  4 pick state-input
  5 pick state-pos
  1 string.substring
  string.concat
  swap
  make-state nip
;

# Just advance position
: advance-pos ( TokState -- TokState )
  dup state-input
  over state-pos 1 add
  2 pick state-tok
  3 pick state-list
  make-state nip
;

# ============================================
# Debug
# ============================================

: print-tokens ( TokenList -- )
  dup tnil? if drop else
    dup tcar io.write-line tcdr print-tokens
  then
;
