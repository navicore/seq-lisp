# Tokenizer for SeqLisp - Using ADTs with Position Tracking
#
# Uses nested union types to track source positions within Seq's 4-field limit.
# Token type includes SourceSpan for LSP diagnostics.

include "sexpr"  # For SourceSpan type

# ============================================
# Type Definitions
# ============================================

# Token with source location (uses SourceSpan from sexpr.seq)
union Token {
  Tok { text: String, span: SourceSpan }
}

union TokenList {
  TNil
  TCons { token: Token, rest: TokenList }
}

# Current position in source (3 fields)
union TokPos {
  Pos { pos: Int, line: Int, col: Int }
}

# Token being accumulated (3 fields)
union TokAccum {
  Accum { text: String, start_line: Int, start_col: Int }
}

# Main tokenizer state (4 fields - at the limit)
union TokState {
  TState { input: String, current: TokPos, accum: TokAccum, tokens: TokenList }
}

# ============================================
# Token Constructors and Accessors
# ============================================

: make-token ( String SourceSpan -- Token )
  Make-Tok ;

: tok-text ( Token -- String )
  0 variant.field-at ;

: tok-span ( Token -- SourceSpan )
  1 variant.field-at ;

# ============================================
# Token List Constructors and Accessors
# ============================================

: tnil ( -- TokenList )
  Make-TNil ;

# Add token with span to list
: tcons-tok ( Token TokenList -- TokenList )
  Make-TCons ;

# Convenience: create token with span and add to list
: tcons-span ( String SourceSpan TokenList -- TokenList )
  rot rot make-token swap tcons-tok ;

: tnil? ( TokenList -- Int )
  variant.tag 0 = ;

: tcar ( TokenList -- Token )
  0 variant.field-at ;

: tcdr ( TokenList -- TokenList )
  1 variant.field-at ;

# Reverse token list (preserving spans)
: trev ( TokenList -- TokenList )
  tnil trev-loop ;

: trev-loop ( TokenList TokenList -- TokenList )
  swap dup tnil? if drop else
    dup tcar swap tcdr   # acc token rest
    rot                  # token rest acc
    rot                  # rest acc token
    swap tcons-tok       # rest new-acc (correct order for recursive call!)
    trev-loop            # NO swap needed - rest is list, new-acc is accumulator
  then
;

# ============================================
# TokPos Constructors and Accessors
# ============================================

: make-pos ( Int Int Int -- TokPos )
  Make-Pos ;

: pos-pos ( TokPos -- Int )
  0 variant.field-at ;

: pos-line ( TokPos -- Int )
  1 variant.field-at ;

: pos-col ( TokPos -- Int )
  2 variant.field-at ;

# ============================================
# TokAccum Constructors and Accessors
# ============================================

: make-accum ( String Int Int -- TokAccum )
  Make-Accum ;

# Empty accumulator at given position
: empty-accum ( Int Int -- TokAccum )
  "" rot rot make-accum ;

: accum-text ( TokAccum -- String )
  0 variant.field-at ;

: accum-start-line ( TokAccum -- Int )
  1 variant.field-at ;

: accum-start-col ( TokAccum -- Int )
  2 variant.field-at ;

# ============================================
# TokState Constructors and Accessors
# ============================================

: make-state ( String TokPos TokAccum TokenList -- TokState )
  Make-TState ;

: state-input ( TokState -- String )
  0 variant.field-at ;

: state-current ( TokState -- TokPos )
  1 variant.field-at ;

: state-accum ( TokState -- TokAccum )
  2 variant.field-at ;

: state-tokens ( TokState -- TokenList )
  3 variant.field-at ;

# Convenience accessors that unwrap nested types
: state-pos ( TokState -- Int )
  state-current pos-pos ;

: state-line ( TokState -- Int )
  state-current pos-line ;

: state-col ( TokState -- Int )
  state-current pos-col ;

: state-tok ( TokState -- String )
  state-accum accum-text ;

: state-tok-start-line ( TokState -- Int )
  state-accum accum-start-line ;

: state-tok-start-col ( TokState -- Int )
  state-accum accum-start-col ;

# ============================================
# State Update Helpers
# ============================================

# Advance position by 1 char (not a newline)
: advance-col ( TokState -- TokState )
  dup state-input
  over state-pos 1 add
  2 pick state-line
  3 pick state-col 1 add
  make-pos
  2 pick state-accum
  3 pick state-tokens
  make-state nip
;

# Advance position past a newline
: advance-newline ( TokState -- TokState )
  dup state-input
  over state-pos 1 add
  2 pick state-line 1 add
  1  # col resets to 1
  make-pos
  2 pick state-accum
  3 pick state-tokens
  make-state nip
;

# Start accumulating a new token at current position
: start-token ( TokState -- TokState )
  dup state-input
  over state-current
  2 pick state-line
  3 pick state-col
  empty-accum
  3 pick state-tokens
  make-state nip
;

# Append character to current token
: append-to-token ( TokState String -- TokState )
  over state-accum accum-text swap string.concat  # new-text
  over state-accum accum-start-line               # new-text start-line
  2 pick state-accum accum-start-col              # new-text start-line start-col
  make-accum                                       # new-accum
  over state-input                                 # new-accum input
  2 pick state-current                             # new-accum input current
  rot                                              # input current new-accum
  3 pick state-tokens                              # input current new-accum tokens
  make-state nip
;

# Create span from token start to current position
: make-token-span ( TokState -- SourceSpan )
  dup state-tok-start-line
  over state-tok-start-col
  2 pick state-line
  3 pick state-col
  make-span nip
;

# Emit current accumulated token (if non-empty) and reset accumulator
: emit-token ( TokState -- TokState )
  dup state-tok string.empty? if
    # Nothing to emit - return state unchanged
  else
    # Build all components for new state, then assemble
    # Stack: state

    # 1. Get input (stays the same)
    dup state-input           # state input

    # 2. Get current position (stays the same)
    over state-current        # state input current

    # 3. Create empty accum at current position
    2 pick state-line         # state input current line
    3 pick state-col          # state input current line col
    empty-accum               # state input current new-accum

    # 4. Create new token and add to token list
    3 pick state-tok          # state input current new-accum text
    4 pick make-token-span    # state input current new-accum text span
    make-token                # state input current new-accum token
    4 pick state-tokens       # state input current new-accum token tokens
    tcons-tok                 # state input current new-accum new-tokens

    # Stack: state input current new-accum new-tokens
    # make-state needs: input current accum tokens (tokens on top)
    # We have them in the right order!
    make-state nip
  then
;

# Emit a single-char token at current position, then advance
# Builds token with span, adds to list, advances position, resets accum
: emit-single-char ( TokState String -- TokState )
  # Stack: state str
  # Create span: (line, col) -> (line, col+1)
  over state-line          # state str start-line
  2 pick state-col         # state str start-line start-col
  3 pick state-line        # state str start-line start-col end-line
  4 pick state-col 1 add   # state str start-line start-col end-line end-col
  make-span                # state str span

  # Create token (make-token expects: String SourceSpan -- Token)
  make-token               # state token

  # Add token to state's token list
  over state-tokens tcons-tok  # state new-tokens

  # Build new state with advanced position and empty accum
  over state-input             # state new-tokens input
  2 pick state-pos 1 add       # state new-tokens input pos+1
  3 pick state-line            # state new-tokens input pos+1 line
  4 pick state-col 1 add       # state new-tokens input pos+1 line col+1
  make-pos                     # state new-tokens input new-pos

  3 pick state-line            # state new-tokens input new-pos line
  4 pick state-col 1 add       # state new-tokens input new-pos line col+1
  empty-accum                  # state new-tokens input new-pos new-accum

  # Rearrange for make-state: need input new-pos new-accum new-tokens
  # Current: state new-tokens input new-pos new-accum
  # Indices:   4      3        2      1       0
  3 roll                       # state input new-pos new-accum new-tokens
  make-state nip
;

# ============================================
# Main Tokenizer
# ============================================

: tokenize ( String -- TokenList )
  # Initial state: pos=0, line=1, col=1, empty accum, empty tokens
  0 1 1 make-pos      # input pos
  1 1 empty-accum     # input pos accum
  tnil                # input pos accum tokens
  make-state
  tokenize-loop
  emit-token          # flush any remaining token
  state-tokens trev
;

: tokenize-loop ( TokState -- TokState )
  dup state-input string.length
  over state-pos <= if
    # Done - return state (caller will flush)
  else
    # Get current char code at position
    dup state-input over state-pos string.char-at
    # Stack: State CharCode

    dup 10 = if
      # Newline - flush token and advance with line increment
      drop handle-newline tokenize-loop
    else
      dup 32 = over 9 = or over 13 = or if
        # Other whitespace (space, tab, CR)
        drop handle-space tokenize-loop
      else
        dup 59 = if
          # Semicolon - start of comment
          drop handle-comment tokenize-loop
        else
          dup 40 = if
            # Left paren
            drop handle-lparen tokenize-loop
          else
            dup 41 = if
              # Right paren
              drop handle-rparen tokenize-loop
            else
              dup 39 = if
                # Single quote
                drop handle-quote tokenize-loop
              else
                dup 96 = if
                  # Backtick (quasiquote)
                  drop handle-backtick tokenize-loop
                else
                  dup 44 = if
                    # Comma (unquote/unquote-splicing)
                    drop handle-comma tokenize-loop
                  else
                    dup 34 = if
                      # Double quote - string literal
                      drop handle-string tokenize-loop
                    else
                      # Regular char - add to token
                      drop handle-char tokenize-loop
                    then
                  then
                then
              then
            then
          then
        then
      then
    then
  then
;

# ============================================
# Character Handlers
# ============================================

# Handle newline: emit token, advance with line increment
: handle-newline ( TokState -- TokState )
  emit-token advance-newline start-token
;

# Handle whitespace: emit token, advance
: handle-space ( TokState -- TokState )
  emit-token advance-col start-token
;

# Handle left paren: emit any accumulated token, emit "(", advance
: handle-lparen ( TokState -- TokState )
  emit-token "(" emit-single-char start-token
;

# Handle right paren: emit any accumulated token, emit ")", advance
: handle-rparen ( TokState -- TokState )
  emit-token ")" emit-single-char start-token
;

# Handle quote: emit any accumulated token, emit "'", advance
: handle-quote ( TokState -- TokState )
  emit-token "'" emit-single-char start-token
;

# Handle backtick: emit any accumulated token, emit "`", advance
: handle-backtick ( TokState -- TokState )
  emit-token "`" emit-single-char start-token
;

# Handle comma: check for ,@ vs ,
: handle-comma ( TokState -- TokState )
  emit-token
  # Check if next char is @
  dup state-input string.length
  over state-pos 1 add > if
    dup state-input over state-pos 1 add string.char-at
    64 = if
      # It's ,@ - emit as two-char token
      ",@" emit-two-char start-token
    else
      "," emit-single-char start-token
    then
  else
    "," emit-single-char start-token
  then
;

# Emit a two-char token at current position, then advance by 2
: emit-two-char ( TokState String -- TokState )
  # Stack: state str
  # Create span: (line, col) -> (line, col+2)
  over state-line            # state str start-line
  2 pick state-col           # state str start-line start-col
  3 pick state-line          # state str start-line start-col end-line
  4 pick state-col 2 add     # state str start-line start-col end-line end-col
  make-span                  # state str span

  # Create token (make-token expects: String SourceSpan -- Token)
  make-token                 # state token

  # Add token to state's token list
  over state-tokens tcons-tok  # state new-tokens

  # Build new state with advanced position and empty accum
  over state-input             # state new-tokens input
  2 pick state-pos 2 add       # state new-tokens input pos+2
  3 pick state-line            # state new-tokens input pos+2 line
  4 pick state-col 2 add       # state new-tokens input pos+2 line col+2
  make-pos                     # state new-tokens input new-pos

  3 pick state-line            # state new-tokens input new-pos line
  4 pick state-col 2 add       # state new-tokens input new-pos line col+2
  empty-accum                  # state new-tokens input new-pos new-accum

  # Rearrange for make-state: need input new-pos new-accum new-tokens
  3 roll                       # state input new-pos new-accum new-tokens
  make-state nip
;

# Handle regular character: add to accumulator, advance
: handle-char ( TokState -- TokState )
  # If accumulator is empty, this is the start of a new token
  dup state-tok string.empty? if
    start-token
  else
  then
  # Get current char as string
  dup state-input
  over state-pos
  1 string.substring
  # Append to token and advance
  append-to-token
  advance-col
;

# ============================================
# String Literal Handler
# ============================================

# Handle string literal - accumulate until closing quote
: handle-string ( TokState -- TokState )
  emit-token
  start-token
  # Add opening quote to accumulator
  34 char->string append-to-token
  advance-col
  string-scan-loop
;

# Scan string contents until closing quote
: string-scan-loop ( TokState -- TokState )
  # Check if at end of input
  dup state-input string.length
  over state-pos <= if
    # End of input before closing quote - emit what we have with closing quote
    34 char->string append-to-token
    emit-token start-token
  else
    # Get current char
    dup state-input over state-pos string.char-at

    dup 34 = if
      # Closing quote - add it and emit
      drop
      34 char->string append-to-token
      advance-col
      emit-token start-token
    else
      dup 92 = if
        # Backslash - handle escape
        drop handle-string-escape string-scan-loop
      else
        dup 10 = if
          # Newline in string - add it and update line tracking
          drop
          10 char->string append-to-token
          advance-newline
          string-scan-loop
        else
          # Regular char - add to string and advance
          char->string append-to-token
          advance-col
          string-scan-loop
        then
      then
    then
  then
;

# Handle escape sequence in string
: handle-string-escape ( TokState -- TokState )
  # Check if there's another char after backslash
  dup state-input string.length
  over state-pos 1 add > if
    # Get escaped char
    dup state-input over state-pos 1 add string.char-at

    dup 34 = if
      # backslash-quote -> add quote to string
      drop 34 char->string append-to-token
      advance-col advance-col
    else
      dup 92 = if
        # backslash-backslash -> add backslash to string
        drop 92 char->string append-to-token
        advance-col advance-col
      else
        dup 110 = if
          # backslash-n -> add newline to string
          drop 10 char->string append-to-token
          advance-col advance-col
        else
          # Unknown escape - add backslash and the char
          char->string
          92 char->string swap string.concat
          append-to-token
          advance-col advance-col
        then
      then
    then
  else
    # No char after backslash - just add backslash
    92 char->string append-to-token
    advance-col
  then
;

# ============================================
# Comment Handler
# ============================================

# Skip comment (everything from ; to end of line)
: handle-comment ( TokState -- TokState )
  emit-token skip-to-eol
;

# Skip characters until newline or end of input
: skip-to-eol ( TokState -- TokState )
  dup state-input string.length
  over state-pos <= if
    # End of input
    start-token
  else
    dup state-input over state-pos string.char-at
    10 = if
      # Found newline - advance past it with line increment
      advance-newline start-token
    else
      # Keep skipping
      advance-col skip-to-eol
    then
  then
;

# ============================================
# Debug
# ============================================

: print-tokens ( TokenList -- )
  dup tnil? if drop else
    dup tcar tok-text io.write-line tcdr print-tokens
  then
;

# Debug function to print token with position
# Format: "text @ line:col"
: print-token-with-pos ( Token -- )
  dup tok-text                    # token text
  swap tok-span                   # text span
  dup span? if
    dup span-start-line int->string   # text span line-str
    ":" string.concat                  # text span "line:"
    swap span-start-col int->string   # text "line:" col-str
    string.concat                      # text "line:col"
    " @ " swap string.concat           # text " @ line:col"
    string.concat io.write-line        # print "text @ line:col"
  else
    drop io.write-line                 # just print text
  then
;

: print-tokens-with-pos ( TokenList -- )
  dup tnil? if drop else
    dup tcar print-token-with-pos tcdr print-tokens-with-pos
  then
;
