# Tokenizer for SeqLisp - Using ADTs
#
# Uses explicit state variant to avoid complex stack manipulation
# Token type includes SourceSpan for LSP diagnostics

include "sexpr"  # For SourceSpan type

# ============================================
# Type Definitions
# ============================================

# Token with source location (uses SourceSpan from sexpr.seq)
union Token {
  Tok { text: String, span: SourceSpan }
}

union TokenList {
  TNil
  TCons { token: Token, rest: TokenList }
}

union TokState {
  TState { input: String, pos: Int, current_token: String, tokens: TokenList }
}

# ============================================
# Token Constructors and Accessors
# ============================================

: make-token ( String SourceSpan -- Token )
  Make-Tok ;

# Create token with no position info (for incremental migration)
: make-simple-token ( String -- Token )
  no-span make-token ;

: tok-text ( Token -- String )
  0 variant.field-at ;

: tok-span ( Token -- SourceSpan )
  1 variant.field-at ;

# ============================================
# Token List Constructors and Accessors
# ============================================

: tnil ( -- TokenList )
  Make-TNil ;

# Original interface: takes String, wraps in Token with no-span
: tcons ( String TokenList -- TokenList )
  swap make-simple-token swap Make-TCons ;

: tnil? ( TokenList -- Int )
  variant.tag 0 = ;

: tcar ( TokenList -- Token )
  0 variant.field-at ;

: tcdr ( TokenList -- TokenList )
  1 variant.field-at ;

: trev ( TokenList -- TokenList )
  tnil trev-loop ;

: trev-loop ( TokenList TokenList -- TokenList )
  swap dup tnil? if drop else
    dup tcar tok-text rot tcons swap tcdr swap trev-loop
  then
;

# ============================================
# Tokenizer State Constructors and Accessors
# ============================================

: make-state ( String Int String TokenList -- TokState )
  Make-TState ;

: state-input ( TokState -- String )
  0 variant.field-at ;

: state-pos ( TokState -- Int )
  1 variant.field-at ;

: state-tok ( TokState -- String )
  2 variant.field-at ;

: state-list ( TokState -- TokenList )
  3 variant.field-at ;

# ============================================
# Simple tokenizer
# ============================================

: tokenize ( String -- TokenList )
  0 "" tnil make-state
  tokenize-loop
  state-list trev
;

: tokenize-loop ( TokState -- TokState )
  dup state-input string.length
  over state-pos <= if
    # Done - flush any remaining token
    dup state-tok string.empty? if
      # Nothing to flush - keep state as is (do nothing)
    else
      # Flush final token using consistent pattern
      dup state-input
      over state-pos
      2 pick state-list
      3 pick state-tok
      swap tcons
      "" swap
      make-state nip
    then
  else
    # Get current char code at position
    dup state-input over state-pos string.char-at
    # Stack: State CharCode

    dup 32 = over 10 = or over 9 = or over 13 = or if
      # Whitespace
      drop handle-space tokenize-loop
    else
      dup 59 = if
        # Semicolon - start of comment, skip to end of line
        drop handle-comment tokenize-loop
      else
        dup 40 = if
          # Left paren
          drop handle-lparen tokenize-loop
        else
          dup 41 = if
            # Right paren
            drop handle-rparen tokenize-loop
          else
            dup 39 = if
              # Single quote - emit as its own token
              drop handle-quote tokenize-loop
            else
              dup 96 = if
                # Backtick (quasiquote) - emit as its own token
                drop handle-backtick tokenize-loop
              else
                dup 44 = if
                  # Comma (unquote) - check for ,@
                  drop handle-comma tokenize-loop
                else
                  dup 34 = if
                    # Double quote - string literal
                    drop handle-string tokenize-loop
                  else
                    # Regular char
                    drop handle-char tokenize-loop
                  then
                then
              then
            then
          then
        then
      then
    then
  then
;

# Flush current token (if any) and reset
: handle-space ( TokState -- TokState )
  dup state-tok string.empty? if
    advance-pos
  else
    # Flush token and advance
    dup state-input
    over state-pos 1 add
    2 pick state-list
    3 pick state-tok
    swap tcons
    "" swap
    make-state nip
  then
;

# Flush token, add "(", advance
: handle-lparen ( TokState -- TokState )
  dup state-tok string.empty? if
    # Just add "(" to list and advance
    dup state-input
    over state-pos 1 add
    2 pick state-list
    "(" swap tcons
    "" swap
    make-state nip
  else
    # Flush token, then add "("
    dup state-input
    over state-pos 1 add
    2 pick state-list
    3 pick state-tok
    swap tcons
    "(" swap tcons
    "" swap
    make-state nip
  then
;

# Flush token, add ")", advance
: handle-rparen ( TokState -- TokState )
  dup state-tok string.empty? if
    # Just add ")" to list and advance
    dup state-input
    over state-pos 1 add
    2 pick state-list
    ")" swap tcons
    "" swap
    make-state nip
  else
    # Flush token, then add ")"
    dup state-input
    over state-pos 1 add
    2 pick state-list
    3 pick state-tok
    swap tcons
    ")" swap tcons
    "" swap
    make-state nip
  then
;

# Flush token, add "'", advance
: handle-quote ( TokState -- TokState )
  dup state-tok string.empty? if
    # Just add "'" to list and advance
    dup state-input
    over state-pos 1 add
    2 pick state-list
    "'" swap tcons
    "" swap
    make-state nip
  else
    # Flush token, then add "'"
    dup state-input
    over state-pos 1 add
    2 pick state-list
    3 pick state-tok
    swap tcons
    "'" swap tcons
    "" swap
    make-state nip
  then
;

# Flush token, add "`", advance (quasiquote)
: handle-backtick ( TokState -- TokState )
  dup state-tok string.empty? if
    # Just add "`" to list and advance
    dup state-input
    over state-pos 1 add
    2 pick state-list
    "`" swap tcons
    "" swap
    make-state nip
  else
    # Flush token, then add "`"
    dup state-input
    over state-pos 1 add
    2 pick state-list
    3 pick state-tok
    swap tcons
    "`" swap tcons
    "" swap
    make-state nip
  then
;

# Handle comma - check for ,@ (unquote-splicing) vs , (unquote)
: handle-comma ( TokState -- TokState )
  # First flush any current token
  dup state-tok string.empty? if
    handle-comma-check
  else
    # Flush token first
    dup state-input
    over state-pos
    2 pick state-list
    3 pick state-tok
    swap tcons
    "" swap
    make-state nip
    handle-comma-check
  then
;

# Check if next char is @ for ,@
: handle-comma-check ( TokState -- TokState )
  # Check if there's a next character
  dup state-input string.length
  over state-pos 1 add > if
    # There's a next char - check if it's @
    dup state-input over state-pos 1 add string.char-at
    64 = if
      # It's ,@ - emit ",@" and advance by 2
      dup state-input
      over state-pos 2 add
      2 pick state-list
      ",@" swap tcons
      "" swap
      make-state nip
    else
      # Just , - emit "," and advance by 1
      dup state-input
      over state-pos 1 add
      2 pick state-list
      "," swap tcons
      "" swap
      make-state nip
    then
  else
    # No next char - just emit ","
    dup state-input
    over state-pos 1 add
    2 pick state-list
    "," swap tcons
    "" swap
    make-state nip
  then
;

# Handle string literal - accumulate until closing quote
# Handles escape sequences: backslash-quote and backslash-backslash
: handle-string ( TokState -- TokState )
  # First flush any current token
  dup state-tok string.empty? if
    # Start string with opening quote char
    34 char->string
    swap string-scan-loop
  else
    # Flush token first, then start string
    dup state-input
    over state-pos
    2 pick state-list
    3 pick state-tok
    swap tcons
    "" swap
    make-state nip
    34 char->string
    swap string-scan-loop
  then
;

# Scan string contents until closing quote
# Stack: accumulated_str TokState -- TokState
: string-scan-loop ( String TokState -- TokState )
  # Stack: accum TokState (TokState on top)
  # Check if at end of input
  dup state-input string.length
  over state-pos 1 add <= if
    # End of input before closing quote - emit what we have
    # and add closing quote for well-formed token
    # Stack: accum TokState
    dup state-input               # accum TokState input
    over state-pos 1 add          # accum TokState input pos+1
    2 pick state-list             # accum TokState input pos+1 list
    4 pick 34 char->string string.concat  # accum TokState input pos+1 list (accum+quote)
    swap tcons                    # accum TokState input pos+1 tokens
    "" swap                       # accum TokState input pos+1 "" tokens
    make-state                    # accum TokState NewState
    nip nip                       # NewState
  else
    # Get next char
    dup state-input over state-pos 1 add string.char-at
    # Stack: accum TokState charcode

    dup 34 = if
      # Found closing quote - emit complete string
      drop
      # Advance past opening and closing quotes
      # Stack: accum TokState
      dup state-input               # accum TokState input
      over state-pos 2 add          # accum TokState input pos+2
      2 pick state-list             # accum TokState input pos+2 list
      4 pick 34 char->string string.concat  # accum TokState input pos+2 list (accum+quote)
      swap tcons                    # accum TokState input pos+2 tokens
      "" swap                       # accum TokState input pos+2 "" tokens
      make-state                    # accum TokState NewState
      nip nip                       # NewState
    else
      dup 92 = if
        # Backslash - check for escape sequence
        drop
        # Check if there's another char after backslash
        dup state-input string.length
        over state-pos 2 add > if
          # Get escaped char
          dup state-input over state-pos 2 add string.char-at
          # Stack: accum TokState escaped_char

          dup 34 = if
            # Escaped quote - add quote to string
            drop
            # Stack: accum TokState
            swap 34 char->string string.concat swap  # (accum+quote) TokState
            # Advance by 2 (backslash and quote)
            dup state-input
            over state-pos 2 add
            2 pick state-tok
            3 pick state-list
            make-state nip
            string-scan-loop
          else
            dup 92 = if
              # Escaped backslash - add backslash to string
              drop
              # Stack: accum TokState
              swap 92 char->string string.concat swap  # (accum+backslash) TokState
              # Advance by 2
              dup state-input
              over state-pos 2 add
              2 pick state-tok
              3 pick state-list
              make-state nip
              string-scan-loop
            else
              dup 110 = if
                # Escaped n - add newline to string
                drop
                # Stack: accum TokState
                swap 10 char->string string.concat swap  # (accum+newline) TokState
                # Advance by 2
                dup state-input
                over state-pos 2 add
                2 pick state-tok
                3 pick state-list
                make-state nip
                string-scan-loop
              else
                # Unknown escape - just add backslash and the char
                # Stack: accum TokState escaped_char
                char->string                        # accum TokState charstr
                rot                                 # TokState charstr accum
                92 char->string string.concat       # TokState charstr (accum+backslash)
                swap string.concat                  # TokState (accum+backslash+charstr)
                swap                                # (accum+backslash+charstr) TokState
                # Advance by 2
                dup state-input
                over state-pos 2 add
                2 pick state-tok
                3 pick state-list
                make-state nip
                string-scan-loop
              then
            then
          then
        else
          # No char after backslash - add backslash and continue
          # Stack: accum TokState
          swap 92 char->string string.concat swap
          advance-pos-keep-accum string-scan-loop
        then
      else
        # Regular char - add to string
        # Stack: accum TokState charcode
        char->string                    # accum TokState charstr
        rot                             # TokState charstr accum
        swap string.concat              # TokState (accum+charstr)
        swap                            # (accum+charstr) TokState
        advance-pos-keep-accum string-scan-loop
      then
    then
  then
;

# Advance position while keeping accumulated string
# Stack: accum TokState -- accum TokState'
: advance-pos-keep-accum ( String TokState -- String TokState )
  dup state-input
  over state-pos 1 add
  2 pick state-tok
  3 pick state-list
  make-state nip
;

# Skip comment (everything from ; to end of line)
: handle-comment ( TokState -- TokState )
  # First flush any current token
  dup state-tok string.empty? if
    skip-to-eol
  else
    # Flush token first, then skip
    dup state-input
    over state-pos
    2 pick state-list
    3 pick state-tok
    swap tcons
    "" swap
    make-state nip
    skip-to-eol
  then
;

# Skip characters until newline or end of input
: skip-to-eol ( TokState -- TokState )
  dup state-input string.length
  over state-pos <= if
    # End of input, done
  else
    dup state-input over state-pos string.char-at
    10 = if
      # Found newline, advance past it
      advance-pos
    else
      # Keep skipping
      advance-pos skip-to-eol
    then
  then
;

# Add char to current token, advance
: handle-char ( TokState -- TokState )
  # Build (Input, Pos+1, Tok++Char, List)
  dup state-input
  over state-pos 1 add
  2 pick state-list
  3 pick state-tok
  4 pick state-input
  5 pick state-pos
  1 string.substring
  string.concat
  swap
  make-state nip
;

# Just advance position
: advance-pos ( TokState -- TokState )
  dup state-input
  over state-pos 1 add
  2 pick state-tok
  3 pick state-list
  make-state nip
;

# ============================================
# Debug
# ============================================

: print-tokens ( TokenList -- )
  dup tnil? if drop else
    dup tcar tok-text io.write-line tcdr print-tokens
  then
;
