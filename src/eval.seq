# Evaluator for SeqLisp
#
# Currently supports:
# - Numbers: return as-is
# - Symbols: lookup in environment
# - Arithmetic: +, -, *, /
# - Comparisons: <, >, <=, >=, =
# - let: local binding
# - if: conditional
# - lambda: anonymous functions
# - define: global definitions
# - print: output

include "parser"
include "json"

# Generate a unique symbol name from prefix and number
: make-gensym-name ( String Int -- String )
  int->string string.concat ;

# ============================================
# EvalResult Union Type
#
# All eval functions return EvalResult for consistent error handling.
# This replaces the ad-hoc high-tag approach with a proper union type.
# ============================================

union EvalResult {
  EvalOk { value: Sexpr }
  EvalErr { message: String, span: SourceSpan }
  EvalDefine { name: String, def_value: Sexpr }
}

# Constructors
: eval-ok ( Sexpr -- EvalResult )
  Make-EvalOk ;

# Create error with span
: eval-err-at ( String SourceSpan -- EvalResult )
  Make-EvalErr ;

# Create error without span (backward compatible)
: eval-err ( String -- EvalResult )
  no-span Make-EvalErr ;

: eval-define ( String Sexpr -- EvalResult )
  Make-EvalDefine ;

# Predicates
: eval-ok? ( EvalResult -- Int )
  variant.tag 0 = ;

: eval-err? ( EvalResult -- Int )
  variant.tag 1 = ;

: eval-define? ( EvalResult -- Int )
  variant.tag 2 = ;

# Accessors
: eval-ok-value ( EvalResult -- Sexpr )
  0 variant.field-at ;

: eval-err-message ( EvalResult -- String )
  0 variant.field-at ;

: eval-err-span ( EvalResult -- SourceSpan )
  1 variant.field-at ;

# Create error at the location of a Sexpr
: eval-err-from ( String Sexpr -- EvalResult )
  sexpr-span eval-err-at ;

# Add span to an EvalErr if it doesn't already have one
# Useful for wrapping results from functions that don't track spans
: eval-result-add-span ( EvalResult SourceSpan -- EvalResult )
  over eval-err? if
    # It's an error - check if it already has a span
    over eval-err-span no-span? if
      # No span - add the provided one
      swap eval-err-message swap eval-err-at
    else
      # Already has span - keep it
      drop
    then
  else
    # Not an error - return as-is
    drop
  then
;

: eval-define-name ( EvalResult -- String )
  0 variant.field-at ;

: eval-define-value ( EvalResult -- Sexpr )
  1 variant.field-at ;


# ============================================
# Arity Checking Helpers
# ============================================

# Count elements in an SexprList
: list-length ( SexprList -- Int )
  0 swap list-length-loop ;

: list-length-loop ( Int SexprList -- Int )
  dup snil? if
    drop
  else
    scdr swap 1 add swap list-length-loop
  then ;

# Count arguments in a list (excluding the function name)
: count-args ( SexprList -- Int )
  scdr  # Skip function name
  list-length ;

# Check if argument count equals expected
# Returns: EvalOk with unit value (empty list) on success, EvalErr on failure
# The original List is left on stack in both cases for caller to clean up
# Usage pattern in caller:
#   over 1 "funcname" check-arity    # List Env List EvalResult
#   dup eval-err? if
#     nip nip nip                    # EvalErr
#   else
#     drop drop                      # List Env (drop List copy and EvalOk)
#     ... normal implementation
#   then
: check-arity ( SexprList Int String -- SexprList EvalResult )
  # Stack: List Expected FuncName
  2 pick count-args  # Stack: List Expected FuncName Actual
  2 pick = if        # Compares Actual with Expected (copy), consumes both
    # Stack: List Expected FuncName - arity matches
    drop drop        # Stack: List
    snil slist eval-ok  # Return List and EvalOk
  else
    # Stack: List Expected FuncName - arity mismatch
    " expects " string.concat  # "funcname expects "
    swap int->string string.concat  # "funcname expects N"
    " argument(s)" string.concat  # "funcname expects N argument(s)"
    eval-err  # Stack: List EvalErr
  then ;

# Check minimum arity (for variadic forms like function define)
: check-min-arity ( SexprList Int String -- SexprList EvalResult )
  # Stack: List MinExpected FuncName
  2 pick count-args  # Stack: List MinExpected FuncName Actual
  2 pick >= if       # Actual >= MinExpected
    # Stack: List MinExpected FuncName - arity ok
    drop drop        # Stack: List
    snil slist eval-ok  # Return List and EvalOk
  else
    # Stack: List MinExpected FuncName - not enough args
    " expects at least " string.concat
    swap int->string string.concat
    " argument(s)" string.concat
    eval-err  # Stack: List EvalErr
  then ;

# ============================================
# Symbol Suggestion System
#
# When a symbol is not found, suggest similar names from:
# 1. Environment bindings (user-defined symbols)
# 2. Built-in functions and special forms
#
# Uses a simple similarity heuristic based on length difference.
# ============================================

# Absolute value
: int-abs ( Int -- Int )
  dup 0 < if 0 swap subtract then ;

# Check chars at position 0
: first-char-matches? ( String String -- Int )
  # s1 s2 -> bool
  over string.length 0 = if
    drop drop 0  # s1 is empty
  else
    dup string.length 0 = if
      drop drop 0  # s2 is empty
    else
      # Both non-empty, compare char at position 0
      over 0 string.char-at  # s1 s2 c1
      over 0 string.char-at  # s1 s2 c1 c2
      =                      # s1 s2 bool
      nip nip                # bool
    then
  then
;

# Check chars at position 1
: second-char-matches? ( String String -- Int )
  # s1 s2 -> bool
  over string.length 2 < if
    drop drop 0  # s1 too short
  else
    dup string.length 2 < if
      drop drop 0  # s2 too short
    else
      # Both long enough, compare char at position 1
      over 1 string.char-at  # s1 s2 c1
      over 1 string.char-at  # s1 s2 c1 c2
      =                      # s1 s2 bool
      nip nip                # bool
    then
  then
;

# Check chars at position 2
: third-char-matches? ( String String -- Int )
  # s1 s2 -> bool
  over string.length 3 < if
    drop drop 0  # s1 too short
  else
    dup string.length 3 < if
      drop drop 0  # s2 too short
    else
      # Both long enough, compare char at position 2
      over 2 string.char-at  # s1 s2 c1
      over 2 string.char-at  # s1 s2 c1 c2
      =                      # s1 s2 bool
      nip nip                # bool
    then
  then
;

# Simple similarity score: lower is better, 999 = no match
# Checks first 3 characters for better accuracy
# Scoring: 3 chars match = length_diff, 2 chars = 10+diff, 1 char = 50+diff
: simple-similarity ( String String -- Int )
  # Check for exact match first
  2dup string.equal? if
    drop drop 0
  else
    # Check if first character matches (required for any suggestion)
    2dup first-char-matches? if
      # Check second char
      2dup second-char-matches? if
        # Check third char
        2dup third-char-matches? if
          # First 3 chars match - excellent candidate
          string.length swap string.length subtract int-abs
          # score = length_diff (0-based, best possible for non-exact)
        else
          # First 2 chars match - good candidate
          string.length swap string.length subtract int-abs
          10 add  # score = 10 + length_diff
        then
      else
        # Only first char matches - weak candidate
        string.length swap string.length subtract int-abs
        50 add  # score = 50 + length_diff
      then
    else
      # First char doesn't match - no suggestion
      drop drop 999
    then
  then
;

# Find minimum of two integers
: min ( Int Int -- Int )
  2dup > if nip else drop then ;

# Check if candidate is better than current best
# Stack: target best_name best_dist candidate -> target best_name best_dist
: check-candidate ( String String Int String -- String String Int )
  # Stack: target best_name best_dist candidate
  3 pick over  # target best_name best_dist candidate target candidate
  simple-similarity  # target best_name best_dist candidate new_dist
  dup 3 pick < if
    # New candidate is better
    # Stack: target best_name best_dist candidate new_dist
    rot drop rot drop  # target candidate new_dist
  else
    # Keep current best
    drop drop  # target best_name best_dist
  then
;

# Find best matching builtin for a target symbol
# Stack: target -> best_name best_dist (or "" 999 if none close)
: find-best-builtin ( String -- String Int )
  "" 999  # target best_name best_dist

  # Check each builtin
  # Arithmetic
  "+" check-candidate
  "-" check-candidate
  "*" check-candidate
  "/" check-candidate
  "abs" check-candidate
  "min" check-candidate
  "max" check-candidate
  "modulo" check-candidate
  # Comparison
  "<" check-candidate
  ">" check-candidate
  "<=" check-candidate
  ">=" check-candidate
  "=" check-candidate
  # Special forms
  "if" check-candidate
  "else" check-candidate
  "let" check-candidate
  "lambda" check-candidate
  "define" check-candidate
  "quote" check-candidate
  "begin" check-candidate
  "cond" check-candidate
  "cons" check-candidate
  "car" check-candidate
  "cdr" check-candidate
  "list" check-candidate
  "append" check-candidate
  "reverse" check-candidate
  "length" check-candidate
  "nth" check-candidate
  "last" check-candidate
  "take" check-candidate
  "drop" check-candidate
  "null?" check-candidate
  "number?" check-candidate
  "integer?" check-candidate
  "float?" check-candidate
  "string?" check-candidate
  "symbol?" check-candidate
  "list?" check-candidate
  "boolean?" check-candidate
  "equal?" check-candidate
  "map" check-candidate
  "filter" check-candidate
  "fold" check-candidate
  "apply" check-candidate
  "print" check-candidate
  "read-line" check-candidate
  "read-n" check-candidate
  "string-length" check-candidate
  "substring" check-candidate
  "string-append" check-candidate
  "exit" check-candidate
  "try" check-candidate
  "quasiquote" check-candidate
  "defmacro" check-candidate
  "gensym" check-candidate
  "eval-with-errors" check-candidate
  "eval-all-with-errors" check-candidate

  rot drop  # best_name best_dist
;

# Find best matching symbol (checks builtins only for simplicity)
# Stack: target env -> suggestion (or "" if none close enough)
: find-suggestion ( String Env -- String )
  drop  # Don't search env, just builtins
  find-best-builtin  # best_name best_dist

  # Only suggest if distance <= 15 (allows 2+ char prefix matches)
  # 3 chars match: 0-5, 2 chars match: 10-15, 1 char match: 50+ (rejected)
  dup 15 > if
    drop drop ""  # No good suggestion
  else
    drop  # Return best_name
  then
;

# Format error message with optional suggestion
: format-undefined-error ( String String -- String )
  # Stack: symbol_name suggestion
  dup string.length 0 = if
    # No suggestion
    drop "undefined symbol: " swap string.concat
  else
    # Has suggestion
    swap "undefined symbol: " swap string.concat
    ". Did you mean '" string.concat
    swap string.concat
    "'?" string.concat
  then
;

# ============================================
# Environment Operations
#
# Types are defined in sexpr.seq:
#   Binding, Env, Closure are now part of the core type system
# ============================================

: env-lookup ( String Env -- EvalResult )
  # Returns EvalOk with the value, or EvalErr with suggestion if not found
  #
  # Stack trace for error path:
  #   Name Env                        -- input
  #   Name Env Name Env               -- after 2dup
  #   Name Env Result                 -- after env-lookup-raw
  #   Name Env                        -- after drop (removing error result)
  #   Name Env Name Env               -- after 2dup
  #   Name Env Suggestion             -- after find-suggestion
  #   Env Name Suggestion             -- after rot swap
  #   Env ErrorMsg                    -- after format-undefined-error
  #   EvalResult                      -- after nip eval-err
  #
  2dup env-lookup-raw
  dup eval-err? if
    # Not found - try to add suggestion
    drop
    2dup find-suggestion
    rot swap
    format-undefined-error
    nip eval-err
  else
    # Found - return the successful result
    nip nip
  then
;

# Raw lookup without suggestion (used internally)
: env-lookup-raw ( String Env -- EvalResult )
  # Stack: Name Env
  # Returns EvalOk with the value, or EvalErr if not found
  dup variant.tag 0 = if
    # EnvEmpty - not found, return error
    drop "undefined symbol: " swap string.concat eval-err
  else
    # EnvExtend - extract binding and parent
    dup 0 variant.field-at  # Name Env Binding
    dup binding-name        # Name Env Binding BindingName
    3 pick string.equal? if
      # Found it
      binding-value         # Name Env Value
      nip nip               # Value
      eval-ok
    else
      # Keep looking
      drop                  # Name Env
      1 variant.field-at    # Name Parent
      env-lookup-raw
    then
  then ;

# Concatenate two environments (Env1 bindings prepended to Env2)
: env-concat ( Env Env -- Env )
  # Stack: Env1 Env2 -> Result where Env1 bindings come first
  swap  # Env2 Env1
  dup variant.tag 0 = if
    # EnvEmpty - just return Env2
    drop
  else
    # EnvExtend - extract binding and parent
    dup 0 variant.field-at  # Env2 Env1 Binding
    swap 1 variant.field-at # Env2 Binding Parent
    rot                     # Binding Parent Env2
    env-concat              # Binding ConcatResult
    Make-EnvExtend          # Result
  then ;

# ============================================
# Main Evaluator
# ============================================

# Simple eval without environment (for backward compatibility)
# Returns raw Sexpr for convenience - unwraps EvalOk, returns snil on error
: eval ( Sexpr -- Sexpr )
  env-empty eval-with-env
  dup eval-ok? if
    eval-ok-value
  else
    drop snil slist  # Return empty list on error
  then ;

# Eval with explicit environment
# Returns: EvalResult (EvalOk, EvalErr, or EvalDefine)
: eval-with-env ( Sexpr Env -- EvalResult )
  # Stack: Expr Env
  over variant.tag
  dup 0 = if
    # SNum - return as-is wrapped in EvalOk
    drop drop eval-ok
  else
    dup 1 = if
      # SSym - check for self-evaluating symbols (#t, #f) or lookup
      drop swap dup ssym-val
      dup "#t" string.equal? over "#f" string.equal? or if
        # Boolean literal - return as-is
        drop nip eval-ok
      else
        # Regular symbol - lookup in environment
        # Stack: Env Expr SymName
        over sexpr-span    # Env Expr SymName ExprSpan
        rot drop           # Env SymName ExprSpan
        rot rot            # ExprSpan Env SymName
        swap env-lookup    # ExprSpan EvalResult
        swap eval-result-add-span  # Add span to any error
      then
    else
      2 = if
        # SList - function application
        eval-list-with-env
      else
        # Other types (SString, SFloat, SClosure, SMacro) - self-evaluating
        drop eval-ok
      then
    then
  then
;

# ============================================
# List Evaluation (Function Application)
# ============================================

: eval-list-with-env ( Sexpr Env -- EvalResult )
  # Stack: Expr Env
  swap slist-val
  dup snil? if
    # Empty list - return empty list
    nip slist eval-ok
  else
    # Non-empty list: first element is function
    dup scar
    dup ssym? if
      # Symbol - check for built-in functions
      # Stack: Env List Head
      ssym-val swap rot eval-builtin-with-env
    else
      dup slist? if
        # List in function position - evaluate it (likely a lambda)
        # Stack: Env List Head
        2 pick eval-with-env  # -> Env List EvalResult
        dup eval-err? if
          # Error - propagate it
          nip nip nip
        else
          eval-ok-value  # Unwrap to get the Sexpr
          dup sclosure? if
            # It's a closure - apply it
            # Stack: Env List ClosureSexpr
            rot rot  # -> ClosureSexpr Env List
            scdr     # -> ClosureSexpr Env Args
            swap     # -> ClosureSexpr Args Env
            apply-closure
          else
            # Not a closure - error
            # Stack: Env List ClosureSexpr - use expr span for error
            nip nip "not a function" swap eval-err-from
          then
        then
      else
        # Non-symbol, non-list in function position
        # Stack: Env List Head - use Head's span for error
        nip nip "invalid function position" swap eval-err-from
      then
    then
  then
;

# ============================================
# Built-in Function Dispatch
#
# Dispatch is organized into logical groups to reduce nesting.
# Each group handles related builtins and delegates to the next
# group if no match is found.
#
# Groups:
#   1. Arithmetic: + - * /
#   2. Comparison: < > <= >= =
#   3. Special forms: if let lambda define quote
#   4. List operations: cons car cdr list
#   5. Predicates: null? number? symbol? list? boolean?
#   6. Control flow: begin cond
#   7. I/O: print
#   8. Fallback: environment lookup for user-defined functions
# ============================================

: eval-builtin-with-env ( String SexprList Env -- EvalResult )
  # Stack: FuncName List Env
  rot  # -> List Env FuncName
  dispatch-arithmetic
;

# ----------------------------------------
# Group 1: Arithmetic (+, -, *, /, abs, min, max, modulo)
# ----------------------------------------
: dispatch-arithmetic ( SexprList Env String -- EvalResult )
  dup "+" string.equal? if
    drop eval-add-with-env
  else dup "-" string.equal? if
    drop eval-sub-with-env
  else dup "*" string.equal? if
    drop eval-mul-with-env
  else dup "/" string.equal? if
    drop eval-div-with-env
  else dup "abs" string.equal? if
    drop eval-abs-with-env
  else dup "min" string.equal? if
    drop eval-min-with-env
  else dup "max" string.equal? if
    drop eval-max-with-env
  else dup "modulo" string.equal? if
    drop eval-modulo-with-env
  else
    dispatch-comparison
  then then then then then then then then
;

# ----------------------------------------
# Group 2: Comparison (<, >, <=, >=, =)
# ----------------------------------------
: dispatch-comparison ( SexprList Env String -- EvalResult )
  dup "<" string.equal? if
    drop eval-lt-with-env
  else dup ">" string.equal? if
    drop eval-gt-with-env
  else dup "<=" string.equal? if
    drop eval-lte-with-env
  else dup ">=" string.equal? if
    drop eval-gte-with-env
  else dup "=" string.equal? if
    drop eval-eq-with-env
  else
    dispatch-special-forms
  then then then then then
;

# ----------------------------------------
# Group 3: Special Forms (if, let, lambda, define, quote, defmacro)
# ----------------------------------------
: dispatch-special-forms ( SexprList Env String -- EvalResult )
  dup "if" string.equal? if
    drop eval-if-with-env
  else dup "let" string.equal? if
    drop eval-let-with-env
  else dup "lambda" string.equal? if
    drop eval-lambda-with-env
  else dup "define" string.equal? if
    drop eval-define-with-env
  else dup "quote" string.equal? if
    drop eval-quote-with-env
  else dup "quasiquote" string.equal? if
    drop eval-quasiquote-with-env
  else dup "defmacro" string.equal? if
    drop eval-defmacro-with-env
  else
    dispatch-list-ops
  then then then then then then then
;

# ----------------------------------------
# Group 4: List Operations (cons, car, cdr, list, append, reverse, length, nth, last, take, drop, map, filter, fold)
# ----------------------------------------
: dispatch-list-ops ( SexprList Env String -- EvalResult )
  dup "cons" string.equal? if
    drop eval-cons-with-env
  else dup "car" string.equal? if
    drop eval-car-with-env
  else dup "cdr" string.equal? if
    drop eval-cdr-with-env
  else dup "list" string.equal? if
    drop eval-list-builtin-with-env
  else dup "append" string.equal? if
    drop eval-append-with-env
  else dup "reverse" string.equal? if
    drop eval-reverse-with-env
  else dup "length" string.equal? if
    drop eval-length-with-env
  else dup "nth" string.equal? if
    drop eval-nth-with-env
  else dup "last" string.equal? if
    drop eval-last-with-env
  else dup "take" string.equal? if
    drop eval-take-with-env
  else dup "drop" string.equal? if
    drop eval-drop-with-env
  else dup "map" string.equal? if
    drop eval-map-with-env
  else dup "filter" string.equal? if
    drop eval-filter-with-env
  else dup "fold" string.equal? if
    drop eval-fold-with-env
  else dup "apply" string.equal? if
    drop eval-apply-with-env
  else
    dispatch-predicates
  then then then then then then then then then then then then then then then
;

# ----------------------------------------
# Group 5: Predicates and Utilities (null?, number?, symbol?, list?, boolean?, equal?, gensym)
# ----------------------------------------
: dispatch-predicates ( SexprList Env String -- EvalResult )
  dup "null?" string.equal? if
    drop eval-null?-with-env
  else dup "number?" string.equal? if
    drop eval-number?-with-env
  else dup "integer?" string.equal? if
    drop eval-integer?-with-env
  else dup "float?" string.equal? if
    drop eval-float?-with-env
  else dup "string?" string.equal? if
    drop eval-string?-with-env
  else dup "symbol?" string.equal? if
    drop eval-symbol?-with-env
  else dup "list?" string.equal? if
    drop eval-list?-with-env
  else dup "boolean?" string.equal? if
    drop eval-boolean?-with-env
  else dup "equal?" string.equal? if
    drop eval-equal?-with-env
  else dup "gensym" string.equal? if
    drop eval-gensym-with-env
  else
    dispatch-control-flow
  then then then then then then then then then then
;

# ----------------------------------------
# Group 6: Control Flow (begin, cond, try)
# ----------------------------------------
: dispatch-control-flow ( SexprList Env String -- EvalResult )
  dup "begin" string.equal? if
    drop eval-begin-with-env
  else dup "cond" string.equal? if
    drop eval-cond-with-env
  else dup "try" string.equal? if
    drop eval-try-with-env
  else
    dispatch-string-ops
  then then then
;

# ----------------------------------------
# Group 6b: String Operations
# ----------------------------------------
: dispatch-string-ops ( SexprList Env String -- EvalResult )
  dup "string-length" string.equal? if
    drop eval-string-length-with-env
  else dup "substring" string.equal? if
    drop eval-substring-with-env
  else dup "string-append" string.equal? if
    drop eval-string-append-with-env
  else
    dispatch-io
  then then then
;

# ----------------------------------------
# Group 7: I/O (print, read-line, exit)
# ----------------------------------------
: dispatch-io ( SexprList Env String -- EvalResult )
  dup "print" string.equal? if
    drop eval-print-with-env
  else dup "display" string.equal? if
    drop eval-display-with-env
  else dup "read-line" string.equal? if
    drop eval-read-line-with-env
  else dup "read-n" string.equal? if
    drop eval-read-n-with-env
  else dup "exit" string.equal? if
    drop eval-exit-with-env
  else
    dispatch-json
  then then then then then
;

# ----------------------------------------
# Group 7b: JSON operations
# ----------------------------------------
: dispatch-json ( SexprList Env String -- EvalResult )
  dup "json-parse" string.equal? if
    drop eval-json-parse-with-env
  else dup "json-encode" string.equal? if
    drop eval-json-encode-with-env
  else
    dispatch-lsp
  then then
;

# ----------------------------------------
# Group 7c: LSP support (parse-with-errors, eval-with-errors)
# ----------------------------------------
: dispatch-lsp ( SexprList Env String -- EvalResult )
  dup "parse-with-errors" string.equal? if
    drop eval-parse-with-errors
  else dup "eval-with-errors" string.equal? if
    drop eval-eval-with-errors
  else dup "eval-all-with-errors" string.equal? if
    drop eval-eval-all-with-errors
  else
    dispatch-user-defined
  then then then
;

# ----------------------------------------
# Group 8: User-defined functions and macros (environment lookup)
# ----------------------------------------
: dispatch-user-defined ( SexprList Env String -- EvalResult )
  # Stack: List Env FuncName
  over  # List Env FuncName Env
  env-lookup  # List Env EvalResult
  dup eval-err? if
    # Symbol not found - add span from function name in list
    # Stack: List Env EvalResult
    rot scar sexpr-span  # Env EvalResult FuncNameSpan
    eval-result-add-span  # Env EvalResult (signature is EvalResult SourceSpan -> EvalResult)
    nip
  else
    # Found something
    eval-ok-value  # List Env Value
    dup sclosure? if
      # Apply the closure
      # Stack: List Env ClosureSexpr
      rot  # Env ClosureSexpr List
      scdr  # Env ClosureSexpr Args (skip function name)
      rot  # ClosureSexpr Args Env
      apply-closure
    else dup smacro? if
      # Apply the macro
      # Stack: List Env MacroSexpr
      rot  # Env MacroSexpr List
      scdr  # Env MacroSexpr Args (skip macro name) - args are UNEVALUATED
      rot  # MacroSexpr Args Env
      apply-macro
    else
      # Not a closure or macro - type error
      # Stack: List Env FuncSexpr - use FuncSexpr span for error
      nip nip "not a function or macro" swap eval-err-from
    then then
  then
;

# ============================================
# Numeric Type Helpers
# ============================================

# Check if Sexpr is a number (int or float)
: is-numeric? ( Sexpr -- Int )
  dup snum? swap sfloat? or ;

# Convert numeric Sexpr to Float (assumes is-numeric? is true)
: sexpr->float ( Sexpr -- Float )
  dup snum? if
    snum-val int->float
  else
    sfloat-val
  then ;

# ============================================
# Arithmetic Operations
# ============================================

: eval-add-with-env ( SexprList Env -- EvalResult )
  # Stack: List Env
  swap scdr swap  # Skip the + -> RestList Env
  0 swap eval-fold-add-int-with-env
;

# Fold add with Int accumulator - switches to float if needed
: eval-fold-add-int-with-env ( SexprList Int Env -- EvalResult )
  # Stack: List Acc Env
  2 pick snil? if
    # List is empty, return Acc as SNum
    drop nip snum eval-ok
  else
    # Get first element and eval it
    2 pick scar over eval-with-env
    # Stack: List Acc Env EvalResult
    dup eval-err? if
      nip nip nip
    else
      eval-ok-value
      # Stack: List Acc Env Value
      dup snum? if
        snum-val
        # Stack: List Acc Env FirstVal
        rot add
        # Stack: List Env NewAcc
        swap rot scdr rot rot
        # Stack: RestList NewAcc Env
        eval-fold-add-int-with-env
      else
        dup sfloat? if
          sfloat-val
          # Stack: List Acc Env FloatVal
          # Convert Acc to float and switch to float fold
          rot int->float f.add
          # Stack: List Env FloatAcc
          swap rot scdr rot rot
          eval-fold-add-float-with-env
        else
          drop drop drop drop "+: argument must be a number" eval-err
        then
      then
    then
  then
;

# Fold add with Float accumulator
: eval-fold-add-float-with-env ( SexprList Float Env -- EvalResult )
  # Stack: List Acc Env
  2 pick snil? if
    # List is empty, return Acc as SFloat
    drop nip sfloat eval-ok
  else
    # Get first element and eval it
    2 pick scar over eval-with-env
    # Stack: List Acc Env EvalResult
    dup eval-err? if
      nip nip nip
    else
      eval-ok-value
      # Stack: List Acc Env Value
      dup is-numeric? if
        sexpr->float
        # Stack: List Acc Env FloatVal
        rot f.add
        # Stack: List Env NewAcc
        swap rot scdr rot rot
        eval-fold-add-float-with-env
      else
        drop drop drop drop "+: argument must be a number" eval-err
      then
    then
  then
;

: eval-sub-with-env ( SexprList Env -- EvalResult )
  # Stack: List Env
  swap scdr
  dup snil? if
    drop drop 0 snum eval-ok
  else
    dup scar 2 pick eval-with-env
    dup eval-err? if
      nip nip nip
    else
      eval-ok-value
      dup snum? if
        snum-val
        swap scdr
        dup snil? if
          # Unary minus: negate
          drop nip 0 swap subtract snum eval-ok
        else
          # Binary minus: first - rest
          # Stack: Env FirstVal RestList -> need RestList FirstVal Env
          rot rot swap eval-fold-sub-int-with-env
        then
      else
        dup sfloat? if
          sfloat-val
          swap scdr
          dup snil? if
            # Unary minus: negate float
            drop nip 0.0 swap f.subtract sfloat eval-ok
          else
            rot rot swap eval-fold-sub-float-with-env
          then
        else
          drop drop drop "-: argument must be a number" eval-err
        then
      then
    then
  then
;

: eval-fold-sub-int-with-env ( SexprList Int Env -- EvalResult )
  # Stack: List Acc Env
  2 pick snil? if
    drop nip snum eval-ok
  else
    2 pick scar over eval-with-env
    dup eval-err? if
      nip nip nip
    else
      eval-ok-value
      dup snum? if
        snum-val
        rot swap subtract
        swap rot scdr rot rot
        eval-fold-sub-int-with-env
      else
        dup sfloat? if
          sfloat-val
          rot int->float swap f.subtract
          swap rot scdr rot rot
          eval-fold-sub-float-with-env
        else
          drop drop drop drop "-: argument must be a number" eval-err
        then
      then
    then
  then
;

: eval-fold-sub-float-with-env ( SexprList Float Env -- EvalResult )
  2 pick snil? if
    drop nip sfloat eval-ok
  else
    2 pick scar over eval-with-env
    dup eval-err? if
      nip nip nip
    else
      eval-ok-value
      dup is-numeric? if
        sexpr->float
        rot swap f.subtract
        swap rot scdr rot rot
        eval-fold-sub-float-with-env
      else
        drop drop drop drop "-: argument must be a number" eval-err
      then
    then
  then
;

: eval-mul-with-env ( SexprList Env -- EvalResult )
  # Stack: List Env
  swap scdr swap  # Skip the * -> RestList Env
  1 swap eval-fold-mul-int-with-env
;

: eval-fold-mul-int-with-env ( SexprList Int Env -- EvalResult )
  2 pick snil? if
    drop nip snum eval-ok
  else
    2 pick scar over eval-with-env
    dup eval-err? if
      nip nip nip
    else
      eval-ok-value
      dup snum? if
        snum-val
        rot multiply
        swap rot scdr rot rot
        eval-fold-mul-int-with-env
      else
        dup sfloat? if
          sfloat-val
          rot int->float f.multiply
          swap rot scdr rot rot
          eval-fold-mul-float-with-env
        else
          drop drop drop drop "*: argument must be a number" eval-err
        then
      then
    then
  then
;

: eval-fold-mul-float-with-env ( SexprList Float Env -- EvalResult )
  2 pick snil? if
    drop nip sfloat eval-ok
  else
    2 pick scar over eval-with-env
    dup eval-err? if
      nip nip nip
    else
      eval-ok-value
      dup is-numeric? if
        sexpr->float
        rot f.multiply
        swap rot scdr rot rot
        eval-fold-mul-float-with-env
      else
        drop drop drop drop "*: argument must be a number" eval-err
      then
    then
  then
;

: eval-div-with-env ( SexprList Env -- EvalResult )
  # Stack: List Env
  swap scdr
  dup snil? if
    drop drop 0 snum eval-ok
  else
    dup scar 2 pick eval-with-env
    dup eval-err? if
      nip nip nip
    else
      eval-ok-value
      dup snum? if
        snum-val
        swap scdr
        dup snil? if
          drop nip snum eval-ok
        else
          rot rot swap eval-fold-div-int-with-env
        then
      else
        dup sfloat? if
          sfloat-val
          swap scdr
          dup snil? if
            drop nip sfloat eval-ok
          else
            rot rot swap eval-fold-div-float-with-env
          then
        else
          drop drop drop "/: argument must be a number" eval-err
        then
      then
    then
  then
;

: eval-fold-div-int-with-env ( SexprList Int Env -- EvalResult )
  2 pick snil? if
    drop nip snum eval-ok
  else
    2 pick scar over eval-with-env
    dup eval-err? if
      nip nip nip
    else
      eval-ok-value
      dup snum? if
        snum-val
        dup 0 = if
          drop drop drop drop "/: division by zero" eval-err
        else
          rot swap divide
          swap rot scdr rot rot
          eval-fold-div-int-with-env
        then
      else
        dup sfloat? if
          sfloat-val
          dup 0.0 f.= if
            drop drop drop drop "/: division by zero" eval-err
          else
            rot int->float swap f.divide
            swap rot scdr rot rot
            eval-fold-div-float-with-env
          then
        else
          drop drop drop drop "/: argument must be a number" eval-err
        then
      then
    then
  then
;

: eval-fold-div-float-with-env ( SexprList Float Env -- EvalResult )
  2 pick snil? if
    drop nip sfloat eval-ok
  else
    2 pick scar over eval-with-env
    dup eval-err? if
      nip nip nip
    else
      eval-ok-value
      dup is-numeric? if
        sexpr->float
        dup 0.0 f.= if
          drop drop drop drop "/: division by zero" eval-err
        else
          rot swap f.divide
          swap rot scdr rot rot
          eval-fold-div-float-with-env
        then
      else
        drop drop drop drop "/: argument must be a number" eval-err
      then
    then
  then
;

# ============================================
# Numeric Functions (abs, min, max, modulo)
# ============================================

: eval-abs-with-env ( SexprList Env -- EvalResult )
  # (abs n) - returns absolute value of n
  over 1 "abs" check-arity
  dup eval-err? if
    nip nip nip
  else
    drop drop
    swap scdr scar  # Get the argument
    swap eval-with-env
    dup eval-err? if
      # Error - propagate
    else
      eval-ok-value
      dup snum? if
        snum-val dup 0 < if 0 swap subtract then snum eval-ok
      else
        dup sfloat? if
          sfloat-val dup 0.0 f.< if 0.0 swap f.subtract then sfloat eval-ok
        else
          drop "abs: argument must be a number" eval-err
        then
      then
    then
  then
;

: eval-min-with-env ( SexprList Env -- EvalResult )
  # (min a b ...) - returns minimum of arguments
  over 2 "min" check-min-arity
  dup eval-err? if
    nip nip nip
  else
    drop drop
    swap scdr  # Skip 'min' -> Env Args
    dup scar 2 pick eval-with-env
    dup eval-err? if
      nip nip nip
    else
      eval-ok-value
      dup snum? if
        snum-val  # -> Env Args FirstVal
        swap scdr rot rot swap  # -> RestArgs FirstVal Env
        eval-fold-min-int-with-env
      else
        dup sfloat? if
          sfloat-val
          swap scdr rot rot swap
          eval-fold-min-float-with-env
        else
          drop drop drop "min: argument must be a number" eval-err
        then
      then
    then
  then
;

: eval-fold-min-int-with-env ( SexprList Int Env -- EvalResult )
  2 pick snil? if
    drop nip snum eval-ok
  else
    2 pick scar over eval-with-env
    dup eval-err? if
      nip nip nip
    else
      eval-ok-value
      dup snum? if
        snum-val
        rot over over > if nip else drop then
        swap rot scdr rot rot
        eval-fold-min-int-with-env
      else
        dup sfloat? if
          sfloat-val
          rot int->float over over f.> if nip else drop then
          swap rot scdr rot rot
          eval-fold-min-float-with-env
        else
          drop drop drop drop "min: argument must be a number" eval-err
        then
      then
    then
  then
;

: eval-fold-min-float-with-env ( SexprList Float Env -- EvalResult )
  2 pick snil? if
    drop nip sfloat eval-ok
  else
    2 pick scar over eval-with-env
    dup eval-err? if
      nip nip nip
    else
      eval-ok-value
      dup is-numeric? if
        sexpr->float
        rot over over f.> if nip else drop then
        swap rot scdr rot rot
        eval-fold-min-float-with-env
      else
        drop drop drop drop "min: argument must be a number" eval-err
      then
    then
  then
;

: eval-max-with-env ( SexprList Env -- EvalResult )
  # (max a b ...) - returns maximum of arguments
  over 2 "max" check-min-arity
  dup eval-err? if
    nip nip nip
  else
    drop drop
    swap scdr  # Skip 'max' -> Env Args
    dup scar 2 pick eval-with-env
    dup eval-err? if
      nip nip nip
    else
      eval-ok-value
      dup snum? if
        snum-val  # -> Env Args FirstVal
        swap scdr rot rot swap  # -> RestArgs FirstVal Env
        eval-fold-max-int-with-env
      else
        dup sfloat? if
          sfloat-val
          swap scdr rot rot swap
          eval-fold-max-float-with-env
        else
          drop drop drop "max: argument must be a number" eval-err
        then
      then
    then
  then
;

: eval-fold-max-int-with-env ( SexprList Int Env -- EvalResult )
  2 pick snil? if
    drop nip snum eval-ok
  else
    2 pick scar over eval-with-env
    dup eval-err? if
      nip nip nip
    else
      eval-ok-value
      dup snum? if
        snum-val
        rot over over < if nip else drop then
        swap rot scdr rot rot
        eval-fold-max-int-with-env
      else
        dup sfloat? if
          sfloat-val
          rot int->float over over f.< if nip else drop then
          swap rot scdr rot rot
          eval-fold-max-float-with-env
        else
          drop drop drop drop "max: argument must be a number" eval-err
        then
      then
    then
  then
;

: eval-fold-max-float-with-env ( SexprList Float Env -- EvalResult )
  2 pick snil? if
    drop nip sfloat eval-ok
  else
    2 pick scar over eval-with-env
    dup eval-err? if
      nip nip nip
    else
      eval-ok-value
      dup is-numeric? if
        sexpr->float
        rot over over f.< if nip else drop then
        swap rot scdr rot rot
        eval-fold-max-float-with-env
      else
        drop drop drop drop "max: argument must be a number" eval-err
      then
    then
  then
;

: eval-modulo-with-env ( SexprList Env -- EvalResult )
  # (modulo a b) - returns a mod b
  over 2 "modulo" check-arity
  dup eval-err? if
    nip nip nip
  else
    drop drop
    swap scdr  # Skip 'modulo' -> Env Args
    dup scar 2 pick eval-with-env  # Eval first arg
    dup eval-err? if
      nip nip nip
    else
      eval-ok-value
      dup snum? if
        snum-val  # -> Env Args A
        swap scdr scar 2 pick eval-with-env  # Eval second arg
        dup eval-err? if
          nip nip nip
        else
          eval-ok-value
          dup snum? if
            snum-val  # -> Env A B
            dup 0 = if
              drop drop drop "modulo: division by zero" eval-err
            else
              # Proper modulo: result has same sign as divisor
              # Save B for sign comparison, then compute R = A - (A/B)*B
              # Stack: Env A B
              dup rot rot   # -> Env B A B
              over over divide multiply subtract  # -> Env B R
              dup 0 = if
                # R is 0, done
                nip nip snum eval-ok
              else
                # Check if R and B have different signs
                # Stack: Env B R
                over 0 <      # -> Env B R (B<0)
                over 0 <      # -> Env B R (B<0) (R<0)
                = if
                  # Same sign, just return R
                  nip nip snum eval-ok
                else
                  # Different signs, add B to R
                  # Stack: Env B R
                  swap add nip snum eval-ok
                then
              then
            then
          else
            drop drop drop "modulo: argument must be a number" eval-err
          then
        then
      else
        drop drop drop "modulo: argument must be a number" eval-err
      then
    then
  then
;

# ============================================
# Comparison Operations
# ============================================

: eval-lt-with-env ( SexprList Env -- EvalResult )
  # (< a b) returns #t if a < b, else #f
  over 2 "<" check-arity
  dup eval-err? if
    nip nip nip
  else
    drop drop
    swap scdr
    dup scar 2 pick eval-with-env
    dup eval-err? if
      nip nip nip
    else
      eval-ok-value
      dup is-numeric? if
        sexpr->float
        swap scdr scar 2 pick eval-with-env
        dup eval-err? if
          nip nip nip
        else
          eval-ok-value
          dup is-numeric? if
            sexpr->float
            f.< if "#t" else "#f" then ssym eval-ok nip
          else
            drop drop drop "<: arguments must be numbers" eval-err
          then
        then
      else
        drop drop drop "<: arguments must be numbers" eval-err
      then
    then
  then
;

: eval-gt-with-env ( SexprList Env -- EvalResult )
  # (> a b) returns #t if a > b, else #f
  over 2 ">" check-arity
  dup eval-err? if
    nip nip nip
  else
    drop drop
    swap scdr
    dup scar 2 pick eval-with-env
    dup eval-err? if
      nip nip nip
    else
      eval-ok-value
      dup is-numeric? if
        sexpr->float
        swap scdr scar 2 pick eval-with-env
        dup eval-err? if
          nip nip nip
        else
          eval-ok-value
          dup is-numeric? if
            sexpr->float
            f.> if "#t" else "#f" then ssym eval-ok nip
          else
            drop drop drop ">: arguments must be numbers" eval-err
          then
        then
      else
        drop drop drop ">: arguments must be numbers" eval-err
      then
    then
  then
;

: eval-lte-with-env ( SexprList Env -- EvalResult )
  # (<= a b) returns #t if a <= b (NOT a > b), else #f
  over 2 "<=" check-arity
  dup eval-err? if
    nip nip nip
  else
    drop drop
    swap scdr
    dup scar 2 pick eval-with-env
    dup eval-err? if
      nip nip nip
    else
      eval-ok-value
      dup is-numeric? if
        sexpr->float
        swap scdr scar 2 pick eval-with-env
        dup eval-err? if
          nip nip nip
        else
          eval-ok-value
          dup is-numeric? if
            sexpr->float
            f.> if "#f" else "#t" then ssym eval-ok nip
          else
            drop drop drop "<=: arguments must be numbers" eval-err
          then
        then
      else
        drop drop drop "<=: arguments must be numbers" eval-err
      then
    then
  then
;

: eval-gte-with-env ( SexprList Env -- EvalResult )
  # (>= a b) returns #t if a >= b (NOT a < b), else #f
  over 2 ">=" check-arity
  dup eval-err? if
    nip nip nip
  else
    drop drop
    swap scdr
    dup scar 2 pick eval-with-env
    dup eval-err? if
      nip nip nip
    else
      eval-ok-value
      dup is-numeric? if
        sexpr->float
        swap scdr scar 2 pick eval-with-env
        dup eval-err? if
          nip nip nip
        else
          eval-ok-value
          dup is-numeric? if
            sexpr->float
            f.< if "#f" else "#t" then ssym eval-ok nip
          else
            drop drop drop ">=: arguments must be numbers" eval-err
          then
        then
      else
        drop drop drop ">=: arguments must be numbers" eval-err
      then
    then
  then
;

: eval-eq-with-env ( SexprList Env -- EvalResult )
  # (= a b) returns #t if a equals b, else #f
  over 2 "=" check-arity
  dup eval-err? if
    nip nip nip
  else
    drop drop
    swap scdr
    dup scar 2 pick eval-with-env
    dup eval-err? if
      nip nip nip
    else
      eval-ok-value
      dup is-numeric? if
        sexpr->float
        swap scdr scar 2 pick eval-with-env
        dup eval-err? if
          nip nip nip
        else
          eval-ok-value
          dup is-numeric? if
            sexpr->float
            f.= if "#t" else "#f" then ssym eval-ok nip
          else
            drop drop drop "=: arguments must be numbers" eval-err
          then
        then
      else
        drop drop drop "=: arguments must be numbers" eval-err
      then
    then
  then
;

# ============================================
# Print
# ============================================

: eval-print-with-env ( SexprList Env -- EvalResult )
  # Stack: List Env
  # (print expr) - evaluate expr, print result, return the value
  swap scdr scar  # Get the expression to print
  swap eval-with-env  # Evaluate it -> EvalResult
  dup eval-err? if
    # Error - just return it
  else
    dup eval-ok-value sexpr-to-string io.write-line  # Print it
    # Return the printed value (enables chaining like (+ 1 (print 2)))
  then
;

# Display: like print but outputs strings without quotes (for raw output)
: sexpr-to-display-string ( Sexpr -- String )
  dup sstring? if
    sstring-val  # Raw string without quotes
  else
    sexpr-to-string  # Other types use normal conversion
  then
;

: eval-display-with-env ( SexprList Env -- EvalResult )
  # (display expr) - like print but outputs strings raw (no quotes)
  swap scdr scar
  swap eval-with-env
  dup eval-err? if
    # Error - return it
  else
    dup eval-ok-value sexpr-to-display-string io.write-line
  then
;

# ============================================
# Read-Line (read a line from stdin)
#
# Usage:
#   (read-line)  ; Returns string with newline, or #f on EOF
# ============================================

: eval-read-line-with-env ( SexprList Env -- EvalResult )
  # (read-line) - no arguments, reads one line from stdin
  over 0 "read-line" check-arity
  dup eval-err? if
    nip nip nip
  else
    drop drop drop drop
    io.read-line+
    0 = if
      # EOF - return #f
      drop "#f" ssym eval-ok
    else
      # Got a line - return as string
      sstring eval-ok
    then
  then
;

# ============================================
# Read-N (read exactly N bytes from stdin)
#
# Usage:
#   (read-n 58)  ; Returns string of 58 bytes, or #f on EOF/partial read
# ============================================

: eval-read-n-with-env ( SexprList Env -- EvalResult )
  # (read-n n) - reads exactly n bytes from stdin
  # io.read-n primitive: ( n -- string count )
  #   - Always returns both string and count on stack (count on top)
  #   - On success: count = n, string contains the bytes
  #   - On EOF/partial: count = 0, string may be empty or partial (we discard it)
  over 1 "read-n" check-arity
  dup eval-err? if
    nip nip nip
  else
    drop drop
    swap scdr scar  # Get the n argument
    swap eval-with-env
    dup eval-err? if
      # Error evaluating n
    else
      eval-ok-value
      dup snum? if
        # Got a number - read that many bytes
        snum-val
        io.read-n        # Stack: string count
        0 = if           # Stack: string (count was 0, consumed by comparison)
          # EOF or partial read - discard partial string and return #f
          drop "#f" ssym eval-ok
        else             # Stack: string (count was non-zero, consumed by comparison)
          # Got all bytes - wrap string as Sexpr and return
          sstring eval-ok
        then
      else
        drop "read-n: expected number" eval-err
      then
    then
  then
;

# ============================================
# String Operations
# ============================================

# (string-length str) - returns length of string
: eval-string-length-with-env ( SexprList Env -- EvalResult )
  over 1 "string-length" check-arity
  dup eval-err? if
    nip nip nip
  else
    drop drop
    swap scdr scar  # Get string arg
    swap eval-with-env
    dup eval-err? if
      # Error - propagate
    else
      eval-ok-value
      dup sstring? if
        sstring-val string.length snum eval-ok
      else
        drop "string-length: argument must be a string" eval-err
      then
    then
  then
;

# (substring str start length) - returns substring starting at 'start' with 'length' characters
# Out of bounds: returns empty string or as many characters as available (graceful clamping)
: eval-substring-with-env ( SexprList Env -- EvalResult )
  over 3 "substring" check-arity
  dup eval-err? if
    nip nip nip
  else
    drop drop
    # Stack: List Env
    # Evaluate all 3 args first, then check types
    over scdr dup scar swap scdr dup scar swap scdr scar
    # Stack: List Env StrExpr StartExpr LengthExpr
    # positions: 0=LengthExpr, 1=StartExpr, 2=StrExpr, 3=Env, 4=List
    3 pick  # -> List Env StrExpr StartExpr LengthExpr Env
    eval-with-env  # -> List Env StrExpr StartExpr LengthResult
    dup eval-err? if
      nip nip nip nip
    else
      eval-ok-value  # -> List Env StrExpr StartExpr LengthVal
      dup snum? if
        snum-val  # -> List Env StrExpr StartExpr LengthInt
        # positions: 0=LengthInt, 1=StartExpr, 2=StrExpr, 3=Env, 4=List
        swap 3 pick eval-with-env  # -> List Env StrExpr LengthInt StartResult
        dup eval-err? if
          nip nip nip nip
        else
          eval-ok-value  # -> List Env StrExpr LengthInt StartVal
          dup snum? if
            snum-val  # -> List Env StrExpr LengthInt StartInt
            # positions: 0=StartInt, 1=LengthInt, 2=StrExpr, 3=Env, 4=List
            rot 3 pick eval-with-env  # -> List Env LengthInt StartInt StrResult
            dup eval-err? if
              nip nip nip nip
            else
              eval-ok-value  # -> List Env LengthInt StartInt StrVal
              dup sstring? if
                sstring-val  # -> List Env LengthInt StartInt StrString
                rot rot  # -> List Env StrString LengthInt StartInt
                swap  # -> List Env StrString StartInt LengthInt
                string.substring sstring  # -> List Env ResultStr
                nip nip eval-ok
              else
                drop drop drop drop drop "substring: first argument must be a string" eval-err
              then
            then
          else
            drop drop drop drop drop "substring: start must be a number" eval-err
          then
        then
      else
        drop drop drop drop drop "substring: length must be a number" eval-err
      then
    then
  then
;

# (string-append str1 str2 ...) - concatenate strings
: eval-string-append-with-env ( SexprList Env -- EvalResult )
  # Stack: List Env
  over scdr  # Skip function name, get args -> List Env Args
  rot drop   # -> Env Args
  "" eval-string-append-loop
;

: eval-string-append-loop ( Env SexprList String -- EvalResult )
  # Stack: Env Args Acc
  over snil? if
    # Done - return accumulated string
    nip nip sstring eval-ok
  else
    # Evaluate next arg
    over scar  # -> Env Args Acc ArgExpr
    3 pick eval-with-env  # -> Env Args Acc Result
    dup eval-err? if
      # Error - propagate
      nip nip nip
    else
      eval-ok-value  # -> Env Args Acc Val
      dup sstring? if
        sstring-val  # -> Env Args Acc StrVal
        string.concat  # -> Env Args NewAcc
        swap scdr swap  # -> Env RestArgs NewAcc
        eval-string-append-loop
      else
        drop drop drop drop "string-append: all arguments must be strings" eval-err
      then
    then
  then
;

# ============================================
# Exit (terminate process with exit code)
#
# Usage:
#   (exit 0)  ; Exit with success
#   (exit 1)  ; Exit with failure
# ============================================

: eval-exit-with-env ( SexprList Env -- EvalResult )
  # Stack: List Env
  # (exit n) - exit process with code n
  over 1 "exit" check-arity
  dup eval-err? if
    nip nip nip
  else
    drop drop  # -> List Env
    swap scdr scar  # Get the exit code expression -> Env Arg
    swap eval-with-env  # Evaluate it -> EvalResult
    dup eval-err? if
      # Error - propagate
    else
      eval-ok-value
      dup snum? if
        snum-val os.exit
        # Never reaches here - os.exit terminates process
        snil slist eval-ok
      else
        drop "exit: argument must be a number" eval-err
      then
    then
  then
;

# ============================================
# JSON Parsing
# ============================================

: eval-json-parse-with-env ( SexprList Env -- EvalResult )
  # (json-parse str) - parse JSON string into S-expression
  over 1 "json-parse" check-arity
  dup eval-err? if
    nip nip nip
  else
    drop drop  # -> List Env
    swap scdr scar  # Get the string argument -> Env Arg
    swap eval-with-env  # Evaluate it -> EvalResult
    dup eval-err? if
      # Error - propagate
    else
      eval-ok-value
      dup sstring? if
        sstring-val json-parse-string-to-sexpr
        dup json-ok? if
          json-ok-value eval-ok
        else
          json-err-msg eval-err
        then
      else
        drop "json-parse: argument must be a string" eval-err
      then
    then
  then
;

# ============================================
# JSON Encoding
# ============================================

: eval-json-encode-with-env ( SexprList Env -- EvalResult )
  # (json-encode sexpr) - encode S-expression as JSON string
  over 1 "json-encode" check-arity
  dup eval-err? if
    nip nip nip
  else
    drop drop  # -> List Env
    swap scdr scar  # Get the argument -> Env Arg
    swap eval-with-env  # Evaluate it -> EvalResult
    dup eval-err? if
      # Error - propagate
    else
      eval-ok-value
      sexpr-to-json sstring eval-ok
    then
  then
;

# Convert Sexpr to JSON string
: sexpr-to-json ( Sexpr -- String )
  dup snum? if
    snum-val int->string
  else dup sfloat? if
    sfloat-val float->string
  else dup sstring? if
    sstring-val json-encode-string
  else dup ssym? if
    ssym-val
    dup "#t" string.equal? if
      drop "true"
    else dup "#f" string.equal? if
      drop "false"
    else dup "null" string.equal? if
      drop "null"
    else
      # Regular symbol - encode as string
      json-encode-string
    then then then
  else dup slist? if
    slist-val
    dup snil? if
      drop "[]"
    else
      # Check if it looks like an object (list of (key value) pairs)
      dup json-is-object-list? if
        json-encode-object
      else
        json-encode-array
      then
    then
  else
    drop "null"  # Default for closures, macros, etc.
  then then then then then
;

# Check if a list looks like an object (all elements are 2-element lists)
: json-is-object-list? ( SexprList -- Int )
  dup snil? if
    drop 1  # Empty list could be object
  else
    dup scar
    dup slist? if
      slist-val
      dup snil? if
        drop drop 0  # Empty pair - not valid
      else
        scdr
        dup snil? if
          drop drop 0  # Single element - not valid
        else
          scdr snil? if
            # Exactly 2 elements - check rest
            scdr json-is-object-list?
          else
            drop 0  # More than 2 elements - not valid
          then
        then
      then
    else
      drop drop 0  # Not a list - not valid pair
    then
  then
;

# Encode an array (list that's not object-like)
: json-encode-array ( SexprList -- String )
  "[" swap json-encode-array-items "]" string.concat string.concat ;

: json-encode-array-items ( SexprList -- String )
  dup snil? if
    drop ""
  else
    dup scar sexpr-to-json
    swap scdr
    dup snil? if
      drop
    else
      "," swap json-encode-array-items string.concat string.concat
    then
  then
;

# Encode an object (list of (key value) pairs)
: json-encode-object ( SexprList -- String )
  "{" swap json-encode-object-items "}" string.concat string.concat ;

: json-encode-object-items ( SexprList -- String )
  dup snil? if
    drop ""
  else
    dup scar slist-val  # Get the pair
    dup scar  # Get key
    dup ssym? if ssym-val else sstring-val then
    json-encode-string
    ":" string.concat
    swap scdr scar sexpr-to-json  # Get value and encode
    string.concat
    swap scdr
    dup snil? if
      drop
    else
      "," swap json-encode-object-items string.concat string.concat
    then
  then
;

# Encode a string with proper escaping
: json-encode-string ( String -- String )
  34 char->string  # Opening quote
  swap json-encode-string-chars
  34 char->string string.concat  # Closing quote
  string.concat
;

: json-encode-string-chars ( String -- String )
  0 "" json-encode-string-loop ;

: json-encode-string-loop ( String Int String -- String )
  # Stack: input pos acc
  2 pick string.length 2 pick <= if
    nip nip  # Return accumulated string (drop input and pos)
  else
    2 pick 2 pick string.char-at  # Get char at input[pos]
    dup 34 = if  # Quote - escape with backslash
      drop  # input pos acc (char dropped)
      92 char->string 34 char->string string.concat  # build escape
      string.concat  # input pos (acc + escape)
      swap 1 add swap  # Increment pos
      json-encode-string-loop
    else dup 92 = if  # Backslash - double it
      drop
      92 char->string 92 char->string string.concat
      string.concat
      swap 1 add swap
      json-encode-string-loop
    else dup 10 = if  # Newline - backslash n
      drop
      92 char->string 110 char->string string.concat
      string.concat
      swap 1 add swap
      json-encode-string-loop
    else dup 9 = if  # Tab - backslash t
      drop
      92 char->string 116 char->string string.concat
      string.concat
      swap 1 add swap
      json-encode-string-loop
    else dup 13 = if  # Carriage return - backslash r
      drop
      92 char->string 114 char->string string.concat
      string.concat
      swap 1 add swap
      json-encode-string-loop
    else
      # Regular char - append to acc
      char->string string.concat  # input pos (acc + charStr)
      swap 1 add swap  # Increment pos
      json-encode-string-loop
    then then then then then
  then
;

# ============================================
# LSP Support Builtins
# ============================================

# Build result list: (ok value)
: make-ok-result ( Sexpr -- Sexpr )
  snil scons                    # (value)
  "ok" ssym swap scons          # (ok value)
  slist
;

# Build error result: (error message line col end-line end-col)
: make-error-result ( String SourceSpan -- Sexpr )
  dup span? if
    # Has span - include position info
    dup span-end-col snum snil scons      # (end-col)
    over span-end-line snum swap scons    # (end-line end-col)
    over span-start-col snum swap scons   # (col end-line end-col)
    over span-start-line snum swap scons  # (line col end-line end-col)
    nip                                   # msg (line col end-line end-col)
    swap sstring swap scons               # (msg line col end-line end-col)
    "error" ssym swap scons               # (error msg line col end-line end-col)
    slist
  else
    # No span - just message with zeros
    drop
    0 snum snil scons                     # (0)
    0 snum swap scons                     # (0 0)
    0 snum swap scons                     # (0 0 0)
    0 snum swap scons                     # (0 0 0 0)
    swap sstring swap scons               # (msg 0 0 0 0)
    "error" ssym swap scons               # (error msg 0 0 0 0)
    slist
  then
;

# (parse-with-errors text) - parse text and return (ok sexpr) or (error ...)
# Note: Current parser doesn't return errors, so this always succeeds
: eval-parse-with-errors ( SexprList Env -- EvalResult )
  over 1 "parse-with-errors" check-arity
  dup eval-err? if
    nip nip nip
  else
    drop drop  # -> List Env
    swap scdr scar  # Get the string argument -> Env Arg
    swap eval-with-env  # Evaluate it -> EvalResult
    dup eval-err? if
      # Error evaluating argument - propagate
    else
      eval-ok-value
      dup sstring? if
        sstring-val parse  # Parse the string -> Sexpr
        make-ok-result eval-ok
      else
        drop "parse-with-errors: argument must be a string" eval-err
      then
    then
  then
;

# (eval-with-errors text) - parse and evaluate text, return (ok value) or (error ...)
: eval-eval-with-errors ( SexprList Env -- EvalResult )
  over 1 "eval-with-errors" check-arity
  dup eval-err? if
    nip nip nip
  else
    drop drop  # -> List Env
    swap scdr scar  # Get the string argument -> Env Arg
    swap eval-with-env  # Evaluate it -> EvalResult
    dup eval-err? if
      # Error evaluating argument - propagate
    else
      eval-ok-value
      dup sstring? if
        sstring-val parse  # Parse the string -> Sexpr
        # Now evaluate the parsed expression with empty env
        env-empty eval-with-env
        dup eval-ok? if
          eval-ok-value make-ok-result eval-ok
        else dup eval-err? if
          # Error during evaluation - extract message and span
          dup eval-err-message
          swap eval-err-span
          make-error-result eval-ok
        else
          # EvalDefine - return the defined value wrapped in ok
          eval-define-value make-ok-result eval-ok
        then then
      else
        drop "eval-with-errors: argument must be a string" eval-err
      then
    then
  then
;

# Parse all expressions from token list
: parse-all-for-lsp ( TokenList -- SexprList )
    snil parse-all-for-lsp-loop list-reverse
;

: parse-all-for-lsp-loop ( TokenList SexprList -- SexprList )
    # Stack: Tokens Exprs
    over tnil? if
        nip  # No more tokens, return expressions
    else
        swap parse-tokens  # -> Exprs ParseResult
        dup result-expr swap result-tokens  # -> Exprs Expr RemainingTokens
        rot rot swap scons  # -> RemainingTokens NewExprs
        parse-all-for-lsp-loop
    then
;

# Evaluate a list of expressions with persistent env, return first error or (ok last-value)
# Stack: SexprList Env LastValue -> EvalResult
: eval-all-with-errors-loop ( SexprList Env Sexpr -- EvalResult )
    # Stack: Exprs Env LastValue
    2 pick snil? if
        # No more expressions - return ok with last value
        nip nip  # -> LastValue
        make-ok-result eval-ok
    else
        # Get next expression: Exprs Env LastValue
        2 pick scar   # Exprs Env LastValue Expr
        2 pick        # Exprs Env LastValue Expr Env
        eval-with-env # Exprs Env LastValue EvalResult
        dup eval-ok? if
            # Expression succeeded - continue with its value
            eval-ok-value  # Exprs Env LastValue NewValue
            nip            # Exprs Env NewValue (drop old LastValue)
            rot scdr       # Env NewValue RestExprs
            rot rot        # RestExprs Env NewValue
            eval-all-with-errors-loop
        else dup eval-err? if
            # Error - extract and return it
            dup eval-err-message  # Exprs Env LastValue EvalResult Msg
            swap eval-err-span    # Exprs Env LastValue Msg Span
            make-error-result eval-ok  # Exprs Env LastValue ErrorResult
            nip nip nip  # Drop Exprs Env LastValue
        else
            # EvalDefine - update env and continue
            # Stack: Exprs Env LastValue EvalResult
            dup eval-define-name    # Exprs Env LastValue EvalDef Name
            swap eval-define-value  # Exprs Env LastValue Name Value
            3 pick env-extend       # Exprs Env LastValue Name Value Env -> Exprs Env LastValue NewEnv
            # Now need: RestExprs NewEnv snil
            # Stack: Exprs Env LastValue NewEnv
            nip nip                 # Exprs NewEnv (drop LastValue and old Env)
            swap scdr               # NewEnv RestExprs
            swap snil               # RestExprs NewEnv snil
            eval-all-with-errors-loop
        then then
    then
;

# (eval-all-with-errors text) - parse and evaluate all exprs, return first error or (ok last)
: eval-eval-all-with-errors ( SexprList Env -- EvalResult )
  over 1 "eval-all-with-errors" check-arity
  dup eval-err? if
    nip nip nip
  else
    drop drop  # -> List Env
    swap scdr scar  # Get the string argument -> Env Arg
    swap eval-with-env  # Evaluate it -> EvalResult
    dup eval-err? if
      # Error evaluating argument - propagate
    else
      eval-ok-value
      dup sstring? if
        sstring-val  # Get the string
        tokenize parse-all-for-lsp  # Parse all expressions -> SexprList
        dup snil? if
          # Empty - return (ok ())
          drop snil make-ok-result eval-ok
        else
          # Evaluate all with empty initial env
          env-empty snil eval-all-with-errors-loop
        then
      else
        drop "eval-all-with-errors: argument must be a string" eval-err
      then
    then
  then
;

# ============================================
# Define (returns a special result for REPL)
# ============================================

# Simple value binding: (define name value)
: eval-define-simple ( SexprList Env -- EvalResult )
  # Stack: Args Env (Args = (name value))
  over scar ssym-val  # -> Args Env Name
  rot scdr scar  # -> Env Name ValueExpr
  rot  # -> Name ValueExpr Env
  eval-with-env  # -> Name EvalResult
  dup eval-err? if
    nip  # -> EvalResult
  else
    eval-ok-value  # -> Name Value
    eval-define  # -> EvalDefine
  then
;

# Function shorthand: (define (name params...) body)
# Creates a named closure so the function can call itself recursively
# without O(n) environment growth from env-concat
: eval-define-function ( SexprList Env -- EvalResult )
  # Stack: Args Env (Args = ((name params...) body))
  # For (define (square n) (* n n)):
  #   Args = ((square n) (* n n))
  #   Extract: name="square", params=(n), body=(* n n)

  # Validate that the name/params list is not empty
  over scar slist-val snil? if
    drop drop "define: empty function name" eval-err
  else
    # Get name first and keep it safe at bottom
    over scar slist-val scar ssym-val  # -> Args Env Name
    rot rot  # -> Name Args Env

    # Now build named closure: need Params Body Env Name
    swap  # -> Name Env Args
    dup scar slist-val scdr slist  # -> Name Env Args Params (skip name, wrap as Sexpr)
    swap scdr scar  # -> Name Env Params Body
    rot  # -> Name Params Body Env
    3 pick  # -> Name Params Body Env Name (copy for named closure)
    make-named-closure  # -> Name Closure
    sclosure  # -> Name ClosureSexpr
    eval-define  # -> EvalDefine
  then
;

: eval-define-with-env ( SexprList Env -- EvalResult )
  # Stack: List Env
  # Two forms:
  #   (define name value) - simple binding
  #   (define (name params...) body) - function shorthand
  # First check we have at least 2 args before accessing them
  over 2 "define" check-min-arity
  dup eval-err? if
    nip nip nip
  else
    drop drop  # -> List Env
    over scdr scar  # -> List Env FirstArg
    dup slist? if
      # Function shorthand
      drop
      swap scdr swap  # -> Args Env
      eval-define-function
    else
      # Value binding - need exactly 2 args (name and value)
      drop
      # Check: skip 'define', skip name, skip value, should be nil
      over scdr scdr scdr snil? if
        swap scdr swap  # -> Args Env
        eval-define-simple
      else
        drop drop "define expects 2 argument(s)" eval-err
      then
    then
  then
;

# ============================================
# Defmacro (creates a macro)
#
# IMPORTANT: Macros in SeqLisp are UNHYGIENIC
# This means macro-introduced bindings can accidentally capture
# variables from the calling context. Use gensym to generate
# unique symbol names to avoid variable capture.
#
# Example of variable capture problem:
#   (defmacro (swap a b) `(let tmp ,a (begin (define ,a ,b) (define ,b tmp))))
#   (let tmp 10 (swap x tmp))  ; BUG: macro's 'tmp' captures caller's 'tmp'
#
# Solution using gensym:
#   (defmacro (swap a b)
#     (let t (gensym 0)  ; generate unique name
#       `(let ,t ,a (begin (define ,a ,b) (define ,b ,t)))))
# ============================================

# Defmacro function shorthand: (defmacro (name params...) body)
: eval-defmacro-function ( SexprList Env -- EvalResult )
  # Stack: Args Env (Args = ((name params...) body))
  # Validate that the name/params list is not empty
  over scar slist-val snil? if
    drop drop "defmacro: empty macro name" eval-err
  else
    # Get params list for validation
    over scar slist-val scdr  # -> Args Env ParamsList
    validate-rest-params      # -> Args Env IsValid ErrorMsg
    swap if
      # Valid params - proceed
      drop  # -> Args Env
      # Get name first and keep it safe at bottom
      over scar slist-val scar ssym-val  # -> Args Env Name
      rot rot  # -> Name Args Env

      # Now build macro: need Params Body Env
      swap  # -> Name Env Args
      dup scar slist-val scdr slist  # -> Name Env Args Params (skip name, wrap as Sexpr)
      swap scdr scar  # -> Name Env Params Body
      rot  # -> Name Params Body Env
      make-closure  # -> Name MacroClosure
      smacro  # -> Name MacroSexpr
      eval-define  # -> EvalDefine
    else
      # Invalid params - return error
      eval-err nip nip  # -> EvalErr
    then
  then
;

: eval-defmacro-with-env ( SexprList Env -- EvalResult )
  # Stack: List Env
  # (defmacro (name params...) body) - function shorthand
  # First check we have at least 2 args before accessing them
  over 2 "defmacro" check-min-arity
  dup eval-err? if
    nip nip nip
  else
    drop drop  # -> List Env
    over scdr scar  # -> List Env FirstArg
    dup slist? if
      # Function shorthand (the expected form)
      drop
      swap scdr swap  # -> Args Env
      eval-defmacro-function
    else
      # Not a list - error (we only support function shorthand)
      drop drop drop "defmacro expects (defmacro (name params...) body)" eval-err
    then
  then
;

# ============================================
# Quote (returns argument unevaluated)
# ============================================

: eval-quote-with-env ( SexprList Env -- EvalResult )
  # Stack: List Env
  # (quote expr) - return expr without evaluating
  over 1 "quote" check-arity  # -> List Env List EvalResult
  dup eval-err? if
    nip nip nip  # -> EvalResult
  else
    drop drop  # -> List Env
    drop  # -> List (drop environment, not needed)
    scdr scar  # -> Expr (skip 'quote', get the expression)
    eval-ok  # -> EvalResult
  then
;

# ============================================
# Quasiquote Evaluation
# ============================================

: eval-quasiquote-with-env ( SexprList Env -- EvalResult )
  # Stack: Args Env
  # (quasiquote expr) - process template with unquote/unquote-splicing
  over 1 "quasiquote" check-arity
  dup eval-err? if
    nip nip nip
  else
    drop drop  # -> Args Env
    swap scdr scar  # -> Env Expr (get the expression)
    swap  # -> Expr Env
    qq-process
  then
;

# Process a quasiquote template
: qq-process ( Sexpr Env -- EvalResult )
  # Stack: Expr Env
  over snum? if
    drop eval-ok
  else over ssym? if
    drop eval-ok
  else over sclosure? if
    drop eval-ok
  else
    # It's a list
    over slist-val dup snil? if
      drop drop eval-ok
    else
      # Check for (unquote x)
      dup scar dup ssym? if
        ssym-val dup "unquote" string.equal? if
          # (unquote x) - evaluate x
          drop scdr scar  # -> Expr Env UnquotedExpr
          swap eval-with-env nip
        else
          "unquote-splicing" string.equal? if
            drop drop drop "unquote-splicing: invalid outside list context" eval-err
          else
            # Regular list - process elements
            drop  # -> Expr Env
            over slist-val swap qq-list nip  # qq-list now returns EvalResult
          then
        then
      else
        # First elem not symbol - process list elements
        drop drop  # -> Expr Env
        over slist-val swap qq-list nip  # qq-list now returns EvalResult
      then
    then
  then then then
;

# Process list elements for quasiquote, returns EvalResult with SList
# Simple recursive approach: process each element, cons onto result
: qq-list ( SexprList Env -- EvalResult )
  over snil? if
    drop drop snil slist eval-ok  # Return empty list, drop both List and Env
  else
    # Process first element
    over scar over           # -> List Env First Env
    qq-elem-one              # -> List Env EvalResult IsSplice
    # Stack: List Env EvalResult IsSplice
    over eval-err? if
      # Error - propagate it
      drop nip nip           # -> EvalResult
    else
      # Got first result, now process rest
      swap eval-ok-value     # -> List Env IsSplice FirstProcessed
      3 pick scdr 3 pick     # -> List Env IsSplice FirstProcessed RestList Env
      qq-list                # -> List Env IsSplice FirstProcessed RestResult
      dup eval-err? if
        # Error in rest - propagate
        nip nip nip nip      # -> EvalResult
      else
        eval-ok-value slist-val  # -> List Env IsSplice FirstProcessed RestList
        # Combine first with rest based on splice flag
        rot if
          # Splice: append FirstProcessed (a list) in front of RestList
          # Stack after rot/if: List Env FirstProcessed RestList
          # qq-append-lists needs (Sexpr SexprList): second=Sexpr, top=SexprList
          # Current: second=FirstProcessed (Sexpr), top=RestList (SexprList) - correct order!
          qq-append-lists        # -> List Env ResultList
        else
          # Single element: cons onto RestList
          # scons needs (Sexpr SexprList): second=Sexpr, top=SexprList
          # Current: second=FirstProcessed, top=RestList - correct order!
          scons                  # -> List Env ResultList
        then
        slist eval-ok nip nip    # -> EvalResult
      then
    then
  then
;

# Process single element, returns (EvalResult, IsSplice) where IsSplice is 0 or 1
# If error, IsSplice is undefined (caller should check error first)
: qq-elem-one ( Sexpr Env -- EvalResult Int )
  over qq-is-unquote? if
    # (unquote x) - evaluate x
    swap slist-val scdr scar swap eval-with-env
    0  # Not a splice
  else over qq-is-splice? if
    # (unquote-splicing x) - evaluate x, must be a list
    swap slist-val scdr scar swap eval-with-env
    dup eval-err? if
      1  # Mark as splice (error will be propagated anyway)
    else
      dup eval-ok-value slist? if
        1  # Return list value, marked as splice
      else
        # Not a list - return error
        drop "unquote-splicing: value must be a list" eval-err
        1  # Marked as splice
      then
    then
  else
    # Regular element - recursively process
    qq-process
    0  # Not a splice
  then then
;

# Append first list to front of second list (first comes before second)
: qq-append-lists ( Sexpr SexprList -- SexprList )
  # First is an SList Sexpr, need to extract and append
  swap dup slist? if
    slist-val             # -> Rest FirstList
    swap qq-append-helper
  else
    drop                  # Not a list, just return Rest
  then
;

: qq-append-helper ( SexprList SexprList -- SexprList )
  # Stack: FirstList Rest -> Combined (FirstList elements then Rest)
  over snil? if
    nip  # FirstList empty, return Rest
  else
    # Recurse on rest of FirstList, then cons first element
    over scdr over qq-append-helper  # -> FirstList Rest Combined
    rot scar swap scons              # -> FirstList (First :: Combined)
    nip                              # -> Result
  then
;

# Check if expr is (unquote x)
: qq-is-unquote? ( Sexpr -- Int )
  dup slist? if
    slist-val dup snil? if
      drop 0
    else
      scar dup ssym? if
        ssym-val "unquote" string.equal?
      else
        drop 0
      then
    then
  else
    drop 0
  then
;

# Check if expr is (unquote-splicing x)
: qq-is-splice? ( Sexpr -- Int )
  dup slist? if
    slist-val dup snil? if
      drop 0
    else
      scar dup ssym? if
        ssym-val "unquote-splicing" string.equal?
      else
        drop 0
      then
    then
  else
    drop 0
  then
;

# ============================================
# List Operations (cons, car, cdr, list)
# ============================================

: eval-cons-with-env ( SexprList Env -- EvalResult )
  # Stack: List Env
  # (cons head tail) - create new cons cell
  over 2 "cons" check-arity  # -> List Env List EvalResult
  dup eval-err? if
    nip nip nip
  else
    drop drop  # -> List Env
    swap scdr  # Skip 'cons' -> Env Args
    dup scar 2 pick eval-with-env  # Eval head -> Env Args EvalResult
    dup eval-err? if
      nip nip nip
    else
      eval-ok-value  # -> Env Args Head
      swap scdr scar 2 pick eval-with-env  # Eval tail -> Env Head EvalResult
      dup eval-err? if
        nip nip nip
      else
        eval-ok-value  # -> Env Head Tail
        # Tail must be a list (SList)
        dup slist? if
          slist-val  # -> Env Head TailList
          scons slist nip eval-ok  # -> (Head . TailList) as EvalOk
        else
          # Error: tail is not a list
          drop drop drop "cons: second argument must be a list" eval-err
        then
      then
    then
  then
;

: eval-car-with-env ( SexprList Env -- EvalResult )
  # Stack: List Env
  # (car lst) - get first element of list
  over  # -> List Env List
  1 "car" check-arity  # -> List Env List EvalResult
  dup eval-err? if
    # Arity error - return it, drop List copy, List and Env
    nip nip nip
  else
    # Arity OK - drop EvalOk and List copy, proceed with evaluation
    drop drop
    swap scdr scar  # Skip 'car', get arg -> Env Arg
    swap eval-with-env  # Eval arg -> EvalResult
    dup eval-err? if
      # Error - propagate
    else
      eval-ok-value  # Unwrap
      dup slist? if
        slist-val  # -> SexprList
        dup snil? if
          # Empty list - error
          drop "car: cannot take car of empty list" eval-err
        else
          scar eval-ok  # -> First element
        then
      else
        # Not a list - type error
        drop "car: argument must be a list" eval-err
      then
    then
  then
;

: eval-cdr-with-env ( SexprList Env -- EvalResult )
  # Stack: List Env
  # (cdr lst) - get rest of list (tail)
  over  # -> List Env List
  1 "cdr" check-arity  # -> List Env List EvalResult
  dup eval-err? if
    # Arity error - return it, drop List copy, List and Env
    nip nip nip
  else
    # Arity OK - drop EvalOk and List copy, proceed with evaluation
    drop drop
    swap scdr scar  # Skip 'cdr', get arg -> Env Arg
    swap eval-with-env  # Eval arg -> EvalResult
    dup eval-err? if
      # Error - propagate
    else
      eval-ok-value  # Unwrap
      dup slist? if
        slist-val  # -> SexprList
        dup snil? if
          # Empty list - error
          drop "cdr: cannot take cdr of empty list" eval-err
        else
          scdr slist eval-ok  # -> Rest as EvalOk
        then
      else
        # Not a list - type error
        drop "cdr: argument must be a list" eval-err
      then
    then
  then
;

: eval-list-builtin-with-env ( SexprList Env -- EvalResult )
  # Stack: List Env
  # (list a b c ...) - create list from evaluated arguments
  swap scdr  # Skip 'list' -> Env Args
  swap  # -> Args Env
  snil swap  # -> Args Acc Env (Acc starts empty)
  eval-list-items
;

: eval-list-items ( SexprList SexprList Env -- EvalResult )
  # Stack: Args Acc Env
  # Evaluate each arg and cons onto accumulator (in reverse)
  2 pick snil? if
    # Done - reverse accumulator and wrap in SList
    drop nip list-reverse slist eval-ok
  else
    # Eval first arg
    2 pick scar over eval-with-env  # -> Args Acc Env EvalResult
    dup eval-err? if
      nip nip nip  # Error - propagate
    else
      eval-ok-value  # Unwrap -> Args Acc Env Sexpr
      rot scons  # -> Args Env NewAcc
      swap  # -> Args NewAcc Env
      rot scdr rot rot  # -> RestArgs NewAcc Env
      eval-list-items
    then
  then
;

: eval-append-with-env ( SexprList Env -- EvalResult )
  # Stack: List Env
  # (append list1 list2) - concatenates two lists
  over 2 "append" check-arity  # -> List Env List EvalResult
  dup eval-err? if
    nip nip nip
  else
    drop drop  # -> List Env
    swap scdr  # -> Env Args (skip 'append')
    dup scar 2 pick eval-with-env  # Eval first arg -> Env Args EvalResult
    dup eval-err? if
      nip nip nip  # Error - propagate
    else
      eval-ok-value  # -> Env Args List1Val
      dup slist? if
        slist-val  # -> Env Args List1
        swap scdr scar 2 pick eval-with-env  # Eval second arg -> Env List1 EvalResult
        dup eval-err? if
          nip nip nip  # Error - propagate
        else
          eval-ok-value  # -> Env List1 List2Val
          dup slist? if
            slist-val  # -> Env List1 List2
            append-lists slist nip eval-ok
          else
            drop drop drop "append: arguments must be lists" eval-err
          then
        then
      else
        drop drop drop "append: arguments must be lists" eval-err
      then
    then
  then
;

# Helper: append two SexprLists
: append-lists ( SexprList SexprList -- SexprList )
  # Stack: List1 List2
  # Reverse List1, then prepend each element to List2
  swap list-reverse swap append-loop
;

: append-loop ( SexprList SexprList -- SexprList )
  # Stack: ReversedList1 List2
  over snil? if
    nip  # List1 empty - return List2
  else
    over scar swap scons  # -> RevList1 (car :: List2)
    swap scdr swap  # -> RestRevList1 NewList2
    append-loop
  then
;

: eval-reverse-with-env ( SexprList Env -- EvalResult )
  # Stack: List Env
  # (reverse list) - reverses a list
  over 1 "reverse" check-arity  # -> List Env List EvalResult
  dup eval-err? if
    nip nip nip
  else
    drop drop  # -> List Env
    swap scdr scar  # -> Env Arg (skip 'reverse', get arg)
    swap eval-with-env  # Eval arg -> EvalResult
    dup eval-err? if
      # Error - propagate
    else
      eval-ok-value  # -> ListVal
      dup slist? if
        slist-val list-reverse slist eval-ok
      else
        drop "reverse: argument must be a list" eval-err
      then
    then
  then
;

# ============================================
# List Utilities (length, nth, last, take, drop)
# ============================================

: eval-length-with-env ( SexprList Env -- EvalResult )
  # Stack: List Env
  # (length list) - returns the length of a list
  over 1 "length" check-arity
  dup eval-err? if
    nip nip nip
  else
    drop drop  # -> List Env
    swap scdr scar  # -> Env Arg (skip 'length', get arg)
    swap eval-with-env  # Eval arg -> EvalResult
    dup eval-err? if
      # Error - propagate
    else
      eval-ok-value  # -> ListVal
      dup slist? if
        slist-val list-length snum eval-ok
      else
        drop "length: argument must be a list" eval-err
      then
    then
  then
;

: eval-nth-with-env ( SexprList Env -- EvalResult )
  # Stack: List Env
  # (nth n list) - returns the nth element (0-indexed)
  over 2 "nth" check-arity
  dup eval-err? if
    nip nip nip
  else
    drop drop  # -> List Env
    swap scdr  # -> Env Args (skip 'nth')
    dup scar 2 pick eval-with-env  # Eval first arg (n) -> Env Args EvalResult
    dup eval-err? if
      nip nip nip
    else
      eval-ok-value  # -> Env Args NVal
      dup snum? if
        snum-val  # -> Env Args N
        dup 0 < if
          drop drop drop "nth: index must be non-negative" eval-err
        else
          swap scdr scar 2 pick eval-with-env  # Eval second arg -> Env N EvalResult
          dup eval-err? if
            nip nip nip
          else
            eval-ok-value  # -> Env N ListVal
            dup slist? if
              slist-val  # -> Env N List
              swap nth-helper
              nip  # -> EvalResult
            else
              drop drop drop "nth: second argument must be a list" eval-err
            then
          then
        then
      else
        drop drop drop "nth: first argument must be a number" eval-err
      then
    then
  then
;

# Helper: get nth element from SexprList (0-indexed)
: nth-helper ( SexprList Int -- EvalResult )
  # Stack: List N
  over snil? if
    drop drop "nth: index out of bounds" eval-err
  else
    dup 0 = if
      drop scar eval-ok
    else
      1 subtract  # -> List N-1
      swap scdr swap  # -> RestList N-1
      nth-helper
    then
  then
;

: eval-last-with-env ( SexprList Env -- EvalResult )
  # Stack: List Env
  # (last list) - returns the last element of a list
  over 1 "last" check-arity
  dup eval-err? if
    nip nip nip
  else
    drop drop  # -> List Env
    swap scdr scar  # -> Env Arg (skip 'last', get arg)
    swap eval-with-env  # Eval arg -> EvalResult
    dup eval-err? if
      # Error - propagate
    else
      eval-ok-value  # -> ListVal
      dup slist? if
        slist-val  # -> List
        dup snil? if
          drop "last: empty list" eval-err
        else
          last-helper eval-ok
        then
      else
        drop "last: argument must be a list" eval-err
      then
    then
  then
;

# Helper: get last element from non-empty SexprList
: last-helper ( SexprList -- Sexpr )
  # Stack: List (non-empty)
  dup scdr snil? if
    scar  # This is the last element
  else
    scdr last-helper
  then
;

: eval-take-with-env ( SexprList Env -- EvalResult )
  # Stack: List Env
  # (take n list) - returns first n elements
  over 2 "take" check-arity
  dup eval-err? if
    nip nip nip
  else
    drop drop  # -> List Env
    swap scdr  # -> Env Args (skip 'take')
    dup scar 2 pick eval-with-env  # Eval first arg (n) -> Env Args EvalResult
    dup eval-err? if
      nip nip nip
    else
      eval-ok-value  # -> Env Args NVal
      dup snum? if
        snum-val  # -> Env Args N
        dup 0 < if
          drop drop drop "take: count must be non-negative" eval-err
        else
          swap scdr scar 2 pick eval-with-env  # Eval second arg -> Env N EvalResult
          dup eval-err? if
            nip nip nip
          else
            eval-ok-value  # -> Env N ListVal
            dup slist? if
              slist-val  # -> Env N List
              swap take-helper slist
              nip eval-ok
            else
              drop drop drop "take: second argument must be a list" eval-err
            then
          then
        then
      else
        drop drop drop "take: first argument must be a number" eval-err
      then
    then
  then
;

# Helper: take first N elements from SexprList
: take-helper ( SexprList Int -- SexprList )
  # Stack: List N
  dup 0 <= if
    drop drop snil
  else
    over snil? if
      drop drop snil
    else
      # Get first element and recurse on rest with N-1
      over scar      # -> List N First
      rot scdr       # -> N First Rest
      rot 1 subtract # -> First Rest N-1
      take-helper    # -> First TakenRest
      scons
    then
  then
;

: eval-drop-with-env ( SexprList Env -- EvalResult )
  # Stack: List Env
  # (drop n list) - drops first n elements, returns rest
  over 2 "drop" check-arity
  dup eval-err? if
    nip nip nip
  else
    drop drop  # -> List Env
    swap scdr  # -> Env Args (skip 'drop')
    dup scar 2 pick eval-with-env  # Eval first arg (n) -> Env Args EvalResult
    dup eval-err? if
      nip nip nip
    else
      eval-ok-value  # -> Env Args NVal
      dup snum? if
        snum-val  # -> Env Args N
        dup 0 < if
          drop drop drop "drop: count must be non-negative" eval-err
        else
          swap scdr scar 2 pick eval-with-env  # Eval second arg -> Env N EvalResult
          dup eval-err? if
            nip nip nip
          else
            eval-ok-value  # -> Env N ListVal
            dup slist? if
              slist-val  # -> Env N List
              swap drop-helper slist
              nip eval-ok
            else
              drop drop drop "drop: second argument must be a list" eval-err
            then
          then
        then
      else
        drop drop drop "drop: first argument must be a number" eval-err
      then
    then
  then
;

# Helper: drop first N elements from SexprList
: drop-helper ( SexprList Int -- SexprList )
  # Stack: List N
  dup 0 <= if
    drop  # Return whole list
  else
    over snil? if
      drop drop snil  # List exhausted
    else
      1 subtract  # -> List N-1
      swap scdr swap  # -> Rest N-1
      drop-helper
    then
  then
;

# ============================================
# Higher-Order Functions (map, filter, fold)
# ============================================

: eval-map-with-env ( SexprList Env -- EvalResult )
  # Stack: List Env
  # (map fn list) - applies fn to each element, returns new list
  over 2 "map" check-arity  # -> List Env List EvalResult
  dup eval-err? if
    nip nip nip
  else
    drop drop  # -> List Env
    swap scdr  # -> Env Args (skip 'map')
    dup scar 2 pick eval-with-env  # Eval fn -> Env Args EvalResult
    dup eval-err? if
      nip nip nip  # Error - propagate
    else
      eval-ok-value  # -> Env Args FnVal
      dup sclosure? if
        sclosure-val  # -> Env Args Closure (unwrap from Sexpr)
        swap scdr scar 2 pick eval-with-env  # Eval list arg -> Env Closure EvalResult
        dup eval-err? if
          nip nip nip  # Error - propagate
        else
          eval-ok-value  # -> Env Closure ListVal
          dup slist? if
            slist-val  # -> Env Closure SexprList
            snil swap  # -> Env Closure Acc InputList
            map-loop
          else
            drop drop drop "map: second argument must be a list" eval-err
          then
        then
      else
        drop drop drop "map: first argument must be a function" eval-err
      then
    then
  then
;

: map-loop ( Env LispClosure SexprList SexprList -- EvalResult )
  # Stack: Env Closure Acc InputList
  dup snil? if
    # Done - reverse accumulator and return
    drop nip nip list-reverse slist eval-ok
  else
    # Apply closure to car of input (value, not expression)
    dup scar  # -> Env Closure Acc InputList Elem
    # Stack positions: 0:Elem 1:InputList 2:Acc 3:Closure 4:Env
    3 pick  # -> ... Elem Closure
    swap  # -> ... Closure Elem
    5 pick  # -> ... Closure Elem Env
    apply-closure-val  # -> Env Closure Acc InputList EvalResult
    dup eval-err? if
      nip nip nip nip nip  # Error - propagate
    else
      eval-ok-value  # -> Env Closure Acc InputList MappedVal
      rot scons  # -> Env Closure InputList NewAcc
      swap scdr  # -> Env Closure NewAcc RestInput
      map-loop
    then
  then
;

: eval-filter-with-env ( SexprList Env -- EvalResult )
  # Stack: List Env
  # (filter pred list) - keeps elements where (pred elem) is truthy
  over 2 "filter" check-arity  # -> List Env List EvalResult
  dup eval-err? if
    nip nip nip
  else
    drop drop  # -> List Env
    swap scdr  # -> Env Args (skip 'filter')
    dup scar 2 pick eval-with-env  # Eval pred -> Env Args EvalResult
    dup eval-err? if
      nip nip nip  # Error - propagate
    else
      eval-ok-value  # -> Env Args PredVal
      dup sclosure? if
        sclosure-val  # -> Env Args Closure (unwrap from Sexpr)
        swap scdr scar 2 pick eval-with-env  # Eval list arg -> Env Closure EvalResult
        dup eval-err? if
          nip nip nip  # Error - propagate
        else
          eval-ok-value  # -> Env Closure ListVal
          dup slist? if
            slist-val  # -> Env Closure SexprList
            snil swap  # -> Env Closure Acc InputList
            filter-loop
          else
            drop drop drop "filter: second argument must be a list" eval-err
          then
        then
      else
        drop drop drop "filter: first argument must be a function" eval-err
      then
    then
  then
;

: filter-loop ( Env LispClosure SexprList SexprList -- EvalResult )
  # Stack: Env Closure Acc InputList
  dup snil? if
    # Done - reverse accumulator and return
    drop nip nip list-reverse slist eval-ok
  else
    # Apply predicate to car of input (value, not expression)
    dup scar  # -> Env Closure Acc InputList Elem
    dup  # Save elem for later -> Env Closure Acc InputList Elem Elem
    # Stack positions: 0:Elem 1:Elem 2:InputList 3:Acc 4:Closure 5:Env
    4 pick  # -> ... Elem Elem Closure
    swap  # -> ... Elem Closure Elem
    6 pick  # -> ... Elem Closure Elem Env
    apply-closure-val  # -> Env Closure Acc InputList Elem EvalResult
    dup eval-err? if
      nip nip nip nip nip nip  # Error - propagate
    else
      eval-ok-value  # -> Env Closure Acc InputList Elem PredResult
      # Check if truthy (not #f and not ())
      dup ssym? if
        ssym-val "#f" string.equal? if
          # False - don't include, drop elem and advance
          # Stack: Env Closure Acc InputList Elem
          drop  # -> Env Closure Acc InputList
          scdr  # -> Env Closure Acc RestInput
          filter-loop
        else
          # Truthy symbol - include elem
          # Stack: Env Closure Acc InputList Elem (result was consumed by ssym-val)
          rot scons  # -> Env Closure InputList NewAcc
          swap scdr  # -> Env Closure NewAcc RestInput
          filter-loop
        then
      else
        dup slist? if
          slist-val snil? if
            # Empty list is falsy - don't include
            # Stack: Env Closure Acc InputList Elem (slist-val consumed result)
            drop  # -> Env Closure Acc InputList
            scdr  # -> Env Closure Acc RestInput
            filter-loop
          else
            # Non-empty list is truthy - include elem
            # Stack: Env Closure Acc InputList Elem
            rot scons  # -> Env Closure InputList NewAcc
            swap scdr  # -> Env Closure NewAcc RestInput
            filter-loop
          then
        else
          # Number or other - truthy, include elem
          # Stack: Env Closure Acc InputList Elem PredResult
          drop  # drop result -> Env Closure Acc InputList Elem
          rot scons  # -> Env Closure InputList NewAcc
          swap scdr  # -> Env Closure NewAcc RestInput
          filter-loop
        then
      then
    then
  then
;

: eval-fold-with-env ( SexprList Env -- EvalResult )
  # Stack: List Env
  # (fold fn init list) - left fold: fn takes (acc elem) returns new acc
  over 3 "fold" check-arity  # -> List Env List EvalResult
  dup eval-err? if
    nip nip nip
  else
    drop drop  # -> List Env
    swap scdr  # -> Env Args (skip 'fold')
    dup scar 2 pick eval-with-env  # Eval fn -> Env Args EvalResult
    dup eval-err? if
      nip nip nip  # Error - propagate
    else
      eval-ok-value  # -> Env Args FnVal
      dup sclosure? if
        sclosure-val  # -> Env Args Closure (unwrap from Sexpr)
        swap scdr  # -> Env Closure RestArgs
        dup scar 2 pick eval-with-env  # Eval init -> Env Closure RestArgs EvalResult
        dup eval-err? if
          nip nip nip nip  # Error - propagate
        else
          eval-ok-value  # -> Env Closure RestArgs InitVal
          swap scdr scar 3 pick eval-with-env  # Eval list -> Env Closure InitVal EvalResult
          dup eval-err? if
            nip nip nip nip  # Error - propagate
          else
            eval-ok-value  # -> Env Closure InitVal ListVal
            dup slist? if
              slist-val  # -> Env Closure Acc InputList
              fold-loop
            else
              drop drop drop drop "fold: third argument must be a list" eval-err
            then
          then
        then
      else
        drop drop drop "fold: first argument must be a function" eval-err
      then
    then
  then
;

: fold-loop ( Env LispClosure Sexpr SexprList -- EvalResult )
  # Stack: Env Closure Acc InputList
  dup snil? if
    # Done - return accumulator
    drop nip nip eval-ok
  else
    # Get current element
    dup scar  # -> Env Closure Acc InputList Elem
    # Build args list (Acc Elem)
    snil scons  # -> Env Closure Acc InputList (Elem)
    # Stack: pos 4:Env 3:Closure 2:Acc 1:InputList 0:(Elem)
    2 pick  # Get Acc
    swap scons  # -> Env Closure Acc InputList (Acc Elem)
    # Stack: pos 4:Env 3:Closure 2:Acc 1:InputList 0:(Acc Elem)
    # Now need: Closure (Acc Elem) Env for apply-closure-2
    # Rearrange to remove old Acc and call apply-closure-2
    3 pick  # Get Closure -> ... (Acc Elem) Closure
    swap    # -> ... Closure (Acc Elem)
    5 pick  # Get Env -> ... Closure (Acc Elem) Env
    apply-closure-2  # -> Env Closure Acc InputList EvalResult
    # Stack: pos 4:Env 3:Closure 2:Acc 1:InputList 0:EvalResult
    dup eval-err? if
      # Error - need to clean up 4 items below result
      nip nip nip nip nip
    else
      eval-ok-value  # -> Env Closure Acc InputList NewAcc
      # Replace old Acc with NewAcc, advance InputList
      # Stack: pos 4:Env 3:Closure 2:Acc 1:InputList 0:NewAcc
      swap scdr  # -> Env Closure Acc NewAcc RestInput
      # Stack: pos 4:Env 3:Closure 2:Acc 1:NewAcc 0:RestInput
      # Need: Env Closure NewAcc RestInput
      rot drop  # Remove old Acc -> Env Closure NewAcc RestInput
      fold-loop
    then
  then
;

# ============================================
# Apply (apply fn args-list)
# ============================================

# Wrap a single Sexpr in a quote expression: arg -> (quote arg)
: wrap-in-quote ( Sexpr -- Sexpr )
  snil scons                      # -> (arg) as SexprList
  "quote" ssym swap scons         # -> (quote arg) as SexprList
  slist                           # -> SList (quote arg) as Sexpr
;

# Quote all elements in a list to prevent re-evaluation
: quote-all-args ( SexprList -- SexprList )
  dup snil? if
    # Empty list, done
  else
    dup scar wrap-in-quote        # -> List QuotedArg
    swap scdr                     # -> QuotedArg Rest
    quote-all-args                # -> QuotedArg QuotedRest
    scons                         # -> (QuotedArg . QuotedRest)
  then
;

: eval-apply-with-env ( SexprList Env -- EvalResult )
  # (apply fn args-list) - apply fn to elements of args-list
  # Stack: L0 Env0
  over 2 "apply" check-arity  # -> L0 Env0 L0 EvalResult
  dup eval-err? if
    nip nip nip  # -> EvalResult (error)
  else
    drop drop  # -> L0 Env0
    # Stack: L0 Env0
    swap scdr                          # -> Env0 L1 where L1=(fn-expr args-list-expr)
    dup scar                           # -> Env0 L1 FnExpr
    over scdr scar                     # -> Env0 L1 FnExpr ArgsListExpr

    # Evaluate args-list-expr in Env0
    # Stack: Env0 L1 FnExpr ArgsListExpr
    3 pick eval-with-env               # -> Env0 L1 FnExpr EvalResult
    dup eval-err? if
      nip nip nip nip                  # -> EvalResult (error)
    else
      eval-ok-value                    # -> Env0 L1 FnExpr ArgsList(Sexpr)
      dup slist? if
        slist-val                      # -> Env0 L1 FnExpr ArgsL(SexprList)
        # Check if FnExpr is a symbol
        over ssym? if
          # Symbol case: FnExpr is a symbol like +, *, list, etc.
          # These are builtins not stored in the environment, so we can't
          # look them up. Instead, we construct a call expression like
          # (+ (quote 1) (quote 2) (quote 3)) and evaluate it.
          # We must quote each arg because the args are already-evaluated
          # values, but builtin evaluation will re-evaluate them.
          # Stack: Env0 L1 FnExpr(Sexpr) ArgsL(SexprList)
          quote-all-args               # -> Env0 L1 FnExpr QuotedArgsL
          scons                        # -> Env0 L1 CallList(SexprList)
          slist                        # -> Env0 L1 CallExpr(Sexpr)
          nip                          # -> Env0 CallExpr
          swap eval-with-env           # -> EvalResult
        else
          # Non-symbol case: evaluate FnExpr first
          # Stack: Env0 L1 FnExpr(Sexpr) ArgsL(SexprList)
          rot                          # -> Env0 FnExpr ArgsL L1
          drop                         # -> Env0 FnExpr ArgsL
          swap                         # -> Env0 ArgsL FnExpr
          2 pick eval-with-env         # -> Env0 ArgsL EvalResult
          dup eval-err? if
            nip nip nip                # -> EvalResult (error)
          else
            eval-ok-value              # -> Env0 ArgsL FnValue(Sexpr)
            dup sclosure? if
              # apply-closure expects: ClosureSexpr SexprList Env
              # Stack: Env0 ArgsL Closure
              rot rot                  # -> Closure Env0 ArgsL
              swap                     # -> Closure ArgsL Env0
              apply-closure
            else
              drop drop drop "apply: first argument must be a function" eval-err
            then
          then
        then
      else
        drop drop drop drop "apply: second argument must be a list" eval-err
      then
    then
  then
;

# ============================================
# Predicates (null?, number?, symbol?, list?)
# ============================================

: eval-null?-with-env ( SexprList Env -- EvalResult )
  # Stack: List Env
  # (null? expr) - returns #t if expr is empty list, #f otherwise
  over 1 "null?" check-arity  # -> List Env List EvalResult
  dup eval-err? if
    nip nip nip
  else
    drop drop  # -> List Env
    swap scdr scar  # Skip 'null?', get arg -> Env Arg
    swap eval-with-env  # Eval arg -> EvalResult
    dup eval-err? if
      # Error - propagate
    else
      eval-ok-value
      dup slist? if
        slist-val snil? if "#t" else "#f" then
      else
        drop "#f"
      then
      ssym eval-ok
    then
  then
;

: eval-number?-with-env ( SexprList Env -- EvalResult )
  # Stack: List Env
  # (number? expr) - returns #t if expr is a number (int or float), #f otherwise
  over 1 "number?" check-arity  # -> List Env List EvalResult
  dup eval-err? if
    nip nip nip
  else
    drop drop  # -> List Env
    swap scdr scar  # Skip 'number?', get arg -> Env Arg
    swap eval-with-env  # Eval arg -> EvalResult
    dup eval-err? if
      # Error - propagate as-is
    else
      eval-ok-value
      dup snum? swap sfloat? or if "#t" else "#f" then ssym eval-ok
    then
  then
;

: eval-integer?-with-env ( SexprList Env -- EvalResult )
  # Stack: List Env
  # (integer? expr) - returns #t if expr is an integer, #f otherwise
  over 1 "integer?" check-arity  # -> List Env List EvalResult
  dup eval-err? if
    nip nip nip
  else
    drop drop  # -> List Env
    swap scdr scar  # Skip 'integer?', get arg -> Env Arg
    swap eval-with-env  # Eval arg -> EvalResult
    dup eval-err? if
      # Error - propagate as-is
    else
      eval-ok-value
      snum? if "#t" else "#f" then ssym eval-ok
    then
  then
;

: eval-float?-with-env ( SexprList Env -- EvalResult )
  # Stack: List Env
  # (float? expr) - returns #t if expr is a float, #f otherwise
  over 1 "float?" check-arity  # -> List Env List EvalResult
  dup eval-err? if
    nip nip nip
  else
    drop drop  # -> List Env
    swap scdr scar  # Skip 'float?', get arg -> Env Arg
    swap eval-with-env  # Eval arg -> EvalResult
    dup eval-err? if
      # Error - propagate as-is
    else
      eval-ok-value
      sfloat? if "#t" else "#f" then ssym eval-ok
    then
  then
;

: eval-string?-with-env ( SexprList Env -- EvalResult )
  # Stack: List Env
  # (string? expr) - returns #t if expr is a string, #f otherwise
  over 1 "string?" check-arity  # -> List Env List EvalResult
  dup eval-err? if
    nip nip nip
  else
    drop drop  # -> List Env
    swap scdr scar  # Skip 'string?', get arg -> Env Arg
    swap eval-with-env  # Eval arg -> EvalResult
    dup eval-err? if
      # Error - propagate as-is
    else
      eval-ok-value
      sstring? if "#t" else "#f" then ssym eval-ok
    then
  then
;

: eval-symbol?-with-env ( SexprList Env -- EvalResult )
  # Stack: List Env
  # (symbol? expr) - returns #t if expr is a symbol, #f otherwise
  over 1 "symbol?" check-arity  # -> List Env List EvalResult
  dup eval-err? if
    nip nip nip
  else
    drop drop  # -> List Env
    swap scdr scar  # Skip 'symbol?', get arg -> Env Arg
    swap eval-with-env  # Eval arg -> EvalResult
    dup eval-err? if
      # Error - propagate as-is
    else
      eval-ok-value
      ssym? if "#t" else "#f" then ssym eval-ok
    then
  then
;

: eval-list?-with-env ( SexprList Env -- EvalResult )
  # Stack: List Env
  # (list? expr) - returns #t if expr is a list, #f otherwise
  over 1 "list?" check-arity  # -> List Env List EvalResult
  dup eval-err? if
    nip nip nip
  else
    drop drop  # -> List Env
    swap scdr scar  # Skip 'list?', get arg -> Env Arg
    swap eval-with-env  # Eval arg -> EvalResult
    dup eval-err? if
      # Error - propagate as-is
    else
      eval-ok-value
      slist? if "#t" else "#f" then ssym eval-ok
    then
  then
;

: eval-boolean?-with-env ( SexprList Env -- EvalResult )
  # Stack: List Env
  # (boolean? expr) - returns #t if expr is #t or #f, #f otherwise
  over 1 "boolean?" check-arity  # -> List Env List EvalResult
  dup eval-err? if
    nip nip nip
  else
    drop drop  # -> List Env
    swap scdr scar  # Skip 'boolean?', get arg -> Env Arg
    swap eval-with-env  # Eval arg -> EvalResult
    dup eval-err? if
      # Error - propagate as-is
    else
      eval-ok-value
      dup ssym? if
        ssym-val dup "#t" string.equal? swap "#f" string.equal? or
        if "#t" else "#f" then
      else
        drop "#f"
      then
      ssym eval-ok
    then
  then
;

# ============================================
# Equal? (structural equality)
#
# Compares two S-expressions for structural equality.
# Works on numbers, symbols, lists, and nested structures.
#
# Usage:
#   (equal? 1 1)           ; -> #t
#   (equal? 'a 'a)         ; -> #t
#   (equal? '(1 2) '(1 2)) ; -> #t
#   (equal? '(1 2) '(1 3)) ; -> #f
# ============================================

# Helper: compare two Sexpr values for structural equality
# Uses depth limit to prevent stack overflow on deeply nested structures
: sexpr-equal? ( Sexpr Sexpr -- Int )
  1000 sexpr-equal-depth?
;

# Depth-limited equality check
# Note: Depth limit of 1000 prevents stack overflow on deeply nested structures.
# Returns false when depth exceeded (safe default for untrusted input).
: sexpr-equal-depth? ( Sexpr Sexpr Int -- Int )
  # Check depth limit
  dup 0 <= if
    drop drop drop 0  # Depth exceeded - return false (safe default)
  else
    # Stack: A B Depth -> Depth A B (after rot rot)
    rot rot
    over variant.tag over variant.tag = if
      # Same type - compare by type
      over snum? if
        # Stack: Depth A B -> Depth ValB ValA -> Depth Bool -> Bool
        snum-val swap snum-val = nip
      else over ssym? if
        # Stack: Depth A B -> Depth StrB StrA -> Depth Bool -> Bool
        ssym-val swap ssym-val string.equal? nip
      else over slist? if
        # Stack: Depth A B -> ListA ListB (Depth-1) -> Bool (recursive)
        slist-val swap slist-val rot 1 subtract sexpr-list-equal-depth?
      else over sstring? if
        # String comparison
        sstring-val swap sstring-val string.equal? nip
      else over sfloat? if
        # Float comparison
        sfloat-val swap sfloat-val f.= nip
      else
        # Closures/macros - compare by identity (always false for now)
        drop drop drop 0
      then then then then then
    else
      # Different types - not equal
      drop drop drop 0
    then
  then
;

# Helper: compare two SexprList values with depth limit
: sexpr-list-equal-depth? ( SexprList SexprList Int -- Int )
  # Check depth limit first
  dup 0 <= if
    drop drop drop 0  # Depth exceeded - return false
  else
    rot rot  # -> Depth L1 L2
    # Check if both empty
    over snil? over snil? and if
      drop drop drop 1  # Both empty = equal
    else over snil? over snil? or if
      drop drop drop 0  # One empty, one not = not equal
    else
      # Both non-empty - compare car and cdr
      # Stack: Depth L1 L2
      over scar over scar  # -> Depth L1 L2 L1.car L2.car
      4 pick 1 subtract    # -> Depth L1 L2 L1.car L2.car (Depth-1)
      sexpr-equal-depth? if
        # Heads equal - compare tails with decremented depth
        scdr swap scdr rot 1 subtract sexpr-list-equal-depth?
      else
        drop drop drop 0  # Heads not equal
      then
    then then
  then
;

: eval-equal?-with-env ( SexprList Env -- EvalResult )
  # Stack: List Env
  # (equal? a b) - returns #t if a and b are structurally equal
  over 2 "equal?" check-arity
  dup eval-err? if
    nip nip nip
  else
    drop drop  # -> List Env
    # Evaluate first argument
    over scdr scar  # -> List Env FirstArg
    over eval-with-env  # -> List Env EvalResult1
    dup eval-err? if
      nip nip  # Error - propagate
    else
      eval-ok-value  # -> List Env Val1
      # Evaluate second argument
      2 pick scdr scdr scar  # -> List Env Val1 SecondArg
      2 pick eval-with-env  # -> List Env Val1 EvalResult2
      dup eval-err? if
        nip nip nip  # Error - propagate
      else
        eval-ok-value  # -> List Env Val1 Val2
        sexpr-equal?  # -> List Env Result
        if "#t" else "#f" then
        ssym eval-ok
        nip nip  # Clean up List Env
      then
    then
  then
;

# ============================================
# Gensym (generate unique symbol)
#
# NOTE: This is a manual gensym - users must manage counters.
# Each call to (gensym n) returns the symbol g<n>.
# Unlike Scheme/CL gensym, this does NOT auto-increment.
#
# Usage:
#   (gensym 0)        ; -> g0
#   (gensym 1)        ; -> g1
#   (gensym 'temp 5)  ; -> temp5
#   (gensym '__or 0)  ; -> __or0 (use unique prefixes for hygiene)
#
# MACRO HYGIENE CONSIDERATIONS:
# - For recursive macros, use unique prefixes to avoid collisions:
#     (gensym '__mymacro 0)  ; Less likely to clash with user code
# - Lexical scoping handles nested expansions correctly
# - The main risk is user code coincidentally using the same symbol
#
# Example with multiple bindings:
#   (defmacro (my-macro x)
#     (let t1 (gensym '__mm 0)
#       (let t2 (gensym '__mm 1)
#         `(let ,t1 ,x (let ,t2 (+ ,t1 1) ,t2)))))
# ============================================

: eval-gensym-with-env ( SexprList Env -- EvalResult )
  # Stack: List Env
  # (gensym n) - returns symbol g<n>
  # (gensym prefix n) - returns symbol <prefix><n>
  over count-args
  dup 1 = if
    # One arg: (gensym n) -> g<n>
    drop
    swap scdr scar  # Skip 'gensym', get arg -> Env Arg
    swap eval-with-env  # Eval arg -> EvalResult
    dup eval-err? if
      # Error - propagate
    else
      eval-ok-value
      dup snum? if
        snum-val "g" swap make-gensym-name ssym eval-ok
      else
        drop "gensym: argument must be a number" eval-err
      then
    then
  else dup 2 = if
    # Two args: (gensym prefix n) -> <prefix><n>
    drop
    swap scdr  # Skip 'gensym' -> Env Args
    dup scar 2 pick eval-with-env  # Eval first arg (prefix) -> Env Args EvalResult
    dup eval-err? if
      nip nip
    else
      eval-ok-value  # -> Env Args PrefixVal
      dup ssym? if
        ssym-val  # -> Env Args PrefixStr
        swap scdr scar 2 pick eval-with-env  # Eval second arg (n) -> Env PrefixStr EvalResult
        dup eval-err? if
          nip nip
        else
          eval-ok-value  # -> Env PrefixStr NVal
          dup snum? if
            snum-val  # -> Env PrefixStr N
            make-gensym-name ssym eval-ok nip
          else
            drop drop drop "gensym: second argument must be a number" eval-err
          then
        then
      else
        drop drop drop "gensym: first argument must be a symbol" eval-err
      then
    then
  else
    drop drop drop "gensym expects 1 or 2 argument(s)" eval-err
  then then
;

# ============================================
# Begin (sequencing)
# ============================================

: eval-begin-with-env ( SexprList Env -- EvalResult )
  # Stack: List Env
  # (begin expr1 expr2 ... exprN) - evaluate all, return last result
  swap scdr  # Skip 'begin' -> Env Exprs
  swap eval-begin-exprs
;

: eval-begin-exprs ( SexprList Env -- EvalResult )
  # Stack: Exprs Env
  # Evaluate expressions in sequence, return last result
  over snil? if
    # No expressions - return empty list
    drop drop snil slist eval-ok
  else
    over scdr snil? if
      # Last expression - evaluate and return (TAIL CALL)
      # TCO Note: Stack naturally has (Expr Env) - no cleanup needed
      swap scar swap eval-with-env
    else
      # More expressions - evaluate this one
      over scar over eval-with-env
      dup eval-err? if
        nip nip  # Error - propagate
      else
        dup eval-define? if
          # Define - extend environment with the binding
          dup eval-define-name swap eval-define-value
          # Stack: Exprs Env Name Value
          rot env-extend  # -> Exprs NewEnv
          # Recurse on remaining exprs (TAIL CALL)
          swap scdr swap eval-begin-exprs
        else
          drop  # Discard EvalOk result
          # Recurse on remaining exprs (TAIL CALL)
          swap scdr swap eval-begin-exprs
        then
      then
    then
  then
;

# ============================================
# Try (error handling)
# ============================================

: eval-try-with-env ( SexprList Env -- EvalResult )
  # Stack: List Env
  # (try expr) - evaluate expr, return (ok value) or (error message)
  swap scdr scar  # Get the expression -> Env Expr
  swap eval-with-env  # Evaluate it -> EvalResult
  dup eval-err? if
    # Error: return (error "message")
    eval-err-message  # -> ErrorMessage (String)
    ssym  # Convert to symbol Sexpr -> ErrorMsgSexpr
    "error" ssym swap  # -> 'error ErrorMsgSexpr
    2 make-slist slist eval-ok  # -> (error message)
  else
    # Success: return (ok value)
    eval-ok-value  # -> Value
    "ok" ssym swap  # -> 'ok Value
    2 make-slist slist eval-ok  # -> (ok value)
  then
;

# Helper to make a 2-element list
: make-slist ( Sexpr Sexpr Int -- SexprList )
  # Stack: Item1 Item2 Count
  # Build list (item1 item2) - item1 at front
  drop  # ignore count, we know it's 2
  snil scons scons  # Item1 (Item2 . nil) -> (Item1 Item2)
;

# ============================================
# Cond (multi-way conditional)
# ============================================

: eval-cond-with-env ( SexprList Env -- EvalResult )
  # Stack: List Env
  # (cond (test1 expr1) (test2 expr2) ... (else exprN))
  swap scdr  # Skip 'cond' -> Env Clauses
  swap eval-cond-clauses
;

: eval-cond-clauses ( SexprList Env -- EvalResult )
  # Stack: Clauses Env
  # Process clauses until one matches
  # TCO Note: All exit paths are TAIL CALLS - either to eval-cond-body
  # (for matched clauses) or recursive eval-cond-clauses (for unmatched).
  # Stack is naturally cleaned to (Exprs Env) or (Clauses Env) before each call.
  over snil? if
    # No more clauses - return empty list
    drop drop snil slist eval-ok
  else
    # Get first clause: (test expr...)
    over scar slist-val  # Clauses Env ClauseList
    dup scar  # Clauses Env ClauseList Test
    # Check for 'else' keyword
    dup ssym? if
      dup ssym-val "else" string.equal? if
        # else clause - evaluate the expression(s) (TAIL CALL)
        drop scdr  # Clauses Env BodyExprs
        rot drop  # Env BodyExprs
        swap eval-cond-body
      else
        # Regular symbol test - evaluate it
        2 pick eval-with-env  # Clauses Env ClauseList EvalResult
        dup eval-err? if
          nip nip nip  # Error - propagate
        else
          eval-ok-value cond-test-true? if
            # Test passed - evaluate clause body (TAIL CALL)
            scdr  # Clauses Env BodyExprs
            rot drop  # Env BodyExprs
            swap eval-cond-body
          else
            # Test failed - try next clause (TAIL CALL)
            drop  # Clauses Env
            swap scdr swap  # RestClauses Env
            eval-cond-clauses
          then
        then
      then
    else
      # Test is not a symbol - evaluate it
      2 pick eval-with-env  # Clauses Env ClauseList EvalResult
      dup eval-err? if
        nip nip nip  # Error - propagate
      else
        eval-ok-value cond-test-true? if
          # Test passed - evaluate clause body (TAIL CALL)
          scdr  # Clauses Env BodyExprs
          rot drop  # Env BodyExprs
          swap eval-cond-body
        else
          # Test failed - try next clause (TAIL CALL)
          drop  # Clauses Env
          swap scdr swap  # RestClauses Env
          eval-cond-clauses
        then
      then
    then
  then
;

: cond-test-true? ( Sexpr -- Int )
  # Returns 1 if test result is truthy, 0 if falsy
  # Falsy: numeric 0 or #f
  dup snum? if
    snum-val 0 = if 0 else 1 then
  else
    dup ssym? if
      ssym-val "#f" string.equal? if 0 else 1 then
    else
      drop 1  # Lists and other values are truthy
    then
  then
;

: eval-cond-body ( SexprList Env -- EvalResult )
  # Stack: BodyExprs Env
  # Evaluate body expressions, return last result (like begin)
  eval-begin-exprs
;

# ============================================
# Conditional (if)
# ============================================

: eval-if-with-env ( SexprList Env -- EvalResult )
  # Stack: List Env
  # List is (if cond then-expr else-expr)
  over 3 "if" check-arity  # -> List Env List EvalResult
  dup eval-err? if
    nip nip nip  # -> EvalResult
  else
    drop drop  # -> List Env
    swap scdr  # Skip the if -> Env Args
    # Args is (cond then-expr else-expr)
    dup scar   # -> Env Args CondExpr
    2 pick     # -> Env Args CondExpr Env
    eval-with-env  # -> Env Args EvalResult
    dup eval-err? if
      nip nip  # -> EvalResult
    else
      eval-ok-value  # -> Env Args CondResult
      # Check if condition is false (numeric 0 or #f)
      # TCO Note: All branches below are TRUE TAIL CALLS.
      # Unlike apply-full, no explicit cleanup is needed because the stack
      # naturally has only (Expr Env) when we call eval-with-env.
      # The branch operations consume Args and produce the branch Expr.
      dup snum? if
        snum-val 0 = if  # -> Env Args
          # False (0) - eval else branch (TAIL CALL)
          scdr scdr scar swap eval-with-env
        else
          # True (non-zero) - eval then branch (TAIL CALL)
          scdr scar swap eval-with-env
        then
      else
        # Check for #f symbol
        dup ssym? if
          ssym-val "#f" string.equal? if  # -> Env Args
            # False (#f) - eval else branch (TAIL CALL)
            scdr scdr scar swap eval-with-env
          else
            # Other symbol - treat as true (TAIL CALL)
            scdr scar swap eval-with-env
          then
        else
          # Non-numeric, non-symbol (list) - treat as true (TAIL CALL)
          drop  # -> Env Args
          scdr scar swap eval-with-env
        then
      then
    then
  then
;

# ============================================
# Let Binding
# ============================================

: eval-let-with-env ( SexprList Env -- EvalResult )
  # Stack: List Env
  # List is (let name value body)
  over 3 "let" check-arity  # -> List Env List EvalResult
  dup eval-err? if
    nip nip nip
  else
    drop drop  # -> List Env
    swap scdr  # Skip the 'let' -> Env Args
  dup scar ssym-val  # Get binding name -> Env Args Name
  swap scdr  # -> Env Name RestArgs
  dup scar  # -> Env Name RestArgs ValueExpr
  3 pick eval-with-env  # Evaluate value -> Env Name RestArgs EvalResult
  dup eval-err? if
    nip nip nip  # Error - propagate (drop RestArgs, Name, Env)
  else
    eval-ok-value  # Unwrap -> Env Name RestArgs Value
    rot  # -> Env RestArgs Value Name
    swap  # -> Env RestArgs Name Value
    3 pick  # -> Env RestArgs Name Value Env
    env-extend  # -> Env RestArgs NewEnv
    swap scdr scar  # Get body expr -> Env NewEnv BodyExpr
    swap  # -> Env BodyExpr NewEnv
    # TCO: Clean up stack BEFORE tail call (not after)
    rot drop  # -> BodyExpr NewEnv
    eval-with-env  # TRUE TAIL CALL - Seq's TCO handles the rest
  then
  then
;

# ============================================
# Lambda
# ============================================

: eval-lambda-with-env ( SexprList Env -- EvalResult )
  # Stack: List Env
  # List is (lambda (params) body)
  over 2 "lambda" check-arity  # -> List Env List EvalResult
  dup eval-err? if
    nip nip nip  # -> EvalResult
  else
    drop drop  # -> List Env
    swap scdr  # Skip 'lambda' -> Env Args
    # Args is ((params) body)
    dup scar  # -> Env Args Params (Params is Sexpr/SList containing param list)
    # Note: We keep params as Sexpr, not unwrapping with slist-val
    # This matches what apply-closure-val expects
    swap scdr scar  # -> Env Params Body
    rot  # -> Params Body Env
    make-closure  # -> Closure (params stored as Sexpr)
    sclosure      # -> Sexpr (wrapping the closure)
    eval-ok       # -> EvalResult
  then
;

# ============================================
# Closure Application (with Currying)
# ============================================

# Apply closure with automatic currying/partial application
# - Fewer args than params: return partially applied closure
# - Exact args: evaluate body
# - More args than params: apply first batch, chain-apply rest
# - Variadic closures: rest param collects extra args
: apply-closure ( Sexpr SexprList Env -- EvalResult )
  # Stack: ClosureSexpr Args CallerEnv
  # Check if this is a variadic closure (has rest param)
  2 pick sclosure-val closure-params slist-val  # -> ... Params
  dup has-rest-param? if
    # Variadic closure: compare ArgCount vs RequiredCount
    dup count-required-params  # -> ... Params RequiredCount
    3 pick list-length         # -> ... Params RequiredCount ArgCount
    # Stack: Params RequiredCount ArgCount - test if ArgCount >= RequiredCount
    # In Seq, `a b <=` tests a <= b, where a=RequiredCount, b=ArgCount
    # RequiredCount <= ArgCount is what we want
    <= if
      # RequiredCount <= ArgCount: full variadic application
      drop apply-full-variadic
    else
      # RequiredCount > ArgCount: partial application
      drop apply-partial
    then
  else
    # Non-variadic closure: original logic
    drop  # drop Params
    # Count args and params
    2 pick sclosure-val closure-params slist-val list-length  # -> ... ParamCount
    2 pick list-length  # -> ... ParamCount ArgCount

    # Compare: ArgCount vs ParamCount
    over over = if
      # Exact match: full application
      drop drop apply-full
    else
      dup 2 pick < if
        # ArgCount < ParamCount: partial application
        drop drop apply-partial
      else
        # ArgCount > ParamCount: apply then chain
        drop drop apply-chain
      then
    then
  then
;

# Partial application: bind available args, return new closure
: apply-partial ( Sexpr SexprList Env -- EvalResult )
  # Stack: ClosureSexpr Args CallerEnv (pos 2,1,0)
  # Evaluate all provided args and bind them
  2 pick sclosure-val  # -> ClosureSexpr Args CallerEnv Closure (pos 3,2,1,0)
  dup closure-env 2 pick env-concat  # -> ClosureSexpr Args CallerEnv Closure BaseEnv (pos 4,3,2,1,0)

  # Bind args to first N params (where N = arg count)
  over closure-params slist-val  # -> ... Closure BaseEnv Params (unwrap to SexprList, pos 5,4,3,2,1,0)
  4 pick  # -> ... Params Args (Args is at position 4)
  4 pick  # -> ... Params Args CallerEnv (CallerEnv is now at position 4)
  partial-bind-loop  # -> ... Closure ExtEnv RemainingParams EvalResult

  dup eval-err? if
    # Error during arg eval
    nip nip nip nip nip nip
  else
    drop  # drop success marker
    # Stack: ClosureSexpr Args CallerEnv Closure ExtEnv RemainingParams
    # Create new closure with remaining params, same body, extended env
    rot closure-body  # -> ... ExtEnv RemainingParams Body
    swap              # -> ... ExtEnv Body RemainingParams
    slist             # -> ... ExtEnv Body ParamsSexpr
    swap rot          # -> ... ParamsSexpr Body ExtEnv
    make-closure sclosure eval-ok
    nip nip nip
  then
;

# Helper: rearrange stack after binding for next recursion
# Takes old layout, advances Params/Args, returns new layout
: bind-rearrange ( SexprList SexprList Env Env -- Env SexprList SexprList Env )
  # Input: Params Args EvalEnv NewEnv (3,2,1,0) - 4 items
  # Output: NewEnv NewParams NewArgs EvalEnv (3,2,1,0) - 4 items
  # Step 1: Compute NewParams and NewArgs
  swap rot   # -> Params NewEnv EvalEnv Args (4 items)
  scdr       # -> Params NewEnv EvalEnv NewArgs (4 items)
  3 roll     # -> NewEnv EvalEnv NewArgs Params (moves item at depth 3 to top)
  scdr       # -> NewEnv EvalEnv NewArgs NewParams (4 items)
  # Step 2: Rearrange to final order
  # Current: NewEnv EvalEnv NewArgs NewParams (3,2,1,0)
  # Want: NewEnv NewParams NewArgs EvalEnv (3,2,1,0)
  rot        # -> NewEnv NewArgs NewParams EvalEnv
  rot swap   # -> NewEnv NewParams NewArgs EvalEnv
;

# Helper: bind args to params, return extended env and remaining params
: partial-bind-loop ( Env SexprList SexprList Env -- Env SexprList EvalResult )
  # Stack: AccEnv Params Args EvalEnv
  # Base case: no more args
  over snil? if
    drop drop  # -> AccEnv Params (remove EvalEnv then Args from top)
    0 snum eval-ok  # success marker (dummy value, we only care about Params)
  else
    # Eval first arg
    over scar over eval-with-env  # -> AccEnv Params Args EvalEnv EvalResult
    dup eval-err? if
      # Error - clean up and return
      # Stack: AccEnv Params Args EvalEnv EvalResult (4,3,2,1,0)
      swap drop    # -> AccEnv Params Args EvalResult
      swap drop    # -> AccEnv Params EvalResult
      swap drop    # -> AccEnv EvalResult
      swap snil swap  # -> AccEnv () EvalResult
    else
      eval-ok-value  # -> AccEnv Params Args EvalEnv ArgVal
      # Rearrange to get AccEnv to top for env-extend
      4 roll  # -> Params Args EvalEnv ArgVal AccEnv
      # Get param name from Params
      4 pick scar ssym-val  # -> Params Args EvalEnv ArgVal AccEnv ParamName
      # env-extend: String Sexpr Env -> Env
      rot rot env-extend  # -> Params Args EvalEnv NewEnv
      # Use helper to rearrange and advance for recursion
      bind-rearrange
      partial-bind-loop
    then
  then
;

# Full application: bind all args, evaluate body
: apply-full ( Sexpr SexprList Env -- EvalResult )
  # Stack: ClosureSexpr Args CallerEnv (pos 2,1,0)
  2 pick sclosure-val  # -> ClosureSexpr Args CallerEnv Closure (pos 3,2,1,0)
  # For named closures, add self-binding for recursion (O(1) instead of O(n) env-concat)
  # For anonymous closures, just use captured env
  dup closure-env  # -> ClosureSexpr Args CallerEnv Closure ClosureEnv
  over named-closure? if
    # Named: add self-binding so function can call itself
    # env-extend signature: ( String Sexpr Env -- Env )
    over closure-self-name  # -> ... Closure ClosureEnv SelfName
    5 pick  # -> ... Closure ClosureEnv SelfName ClosureSexpr
    rot env-extend  # -> ... Closure BaseEnv
  then  # -> ClosureSexpr Args CallerEnv Closure BaseEnv (pos 4,3,2,1,0)
  over closure-params slist-val  # -> ClosureSexpr Args CallerEnv Closure BaseEnv Params (unwrap to SexprList, pos 5,4,3,2,1,0)
  4 pick  # -> ... Params Args (Args is at position 4)
  4 pick  # -> ... Params Args CallerEnv (CallerEnv is now at position 4)
  full-bind-loop  # -> ... Closure ExtEnv EvalResult

  dup eval-err? if
    nip nip nip nip nip
  else
    drop  # drop success marker
    # Stack: ClosureSexpr Args CallerEnv Closure ExtEnv
    swap closure-body swap  # -> ClosureSexpr Args CallerEnv Body ExtEnv
    # TCO: Clean up stack BEFORE tail call (not after)
    rot drop rot drop rot drop  # -> Body ExtEnv
    eval-with-env  # TRUE TAIL CALL - Seq's TCO handles the rest
  then
;

# Helper: bind all args to all params
: full-bind-loop ( Env SexprList SexprList Env -- Env EvalResult )
  # Stack: AccEnv Params Args EvalEnv
  # Base case: no more params (and args)
  2 pick snil? if
    drop drop drop  # -> AccEnv
    snil slist eval-ok  # success marker
  else
    # Eval first arg
    over scar over eval-with-env  # -> AccEnv Params Args EvalEnv EvalResult
    dup eval-err? if
      # Error - clean up and return
      # Stack: AccEnv Params Args EvalEnv EvalResult
      nip nip nip  # -> AccEnv EvalResult
    else
      eval-ok-value  # -> AccEnv Params Args EvalEnv ArgVal
      # Rearrange to get AccEnv to top for env-extend
      4 roll  # -> Params Args EvalEnv ArgVal AccEnv
      # Get param name from Params
      4 pick scar ssym-val  # -> Params Args EvalEnv ArgVal AccEnv ParamName
      # env-extend: String Sexpr Env -> Env
      rot rot env-extend  # -> Params Args EvalEnv NewEnv
      # Use helper to rearrange and advance for recursion
      bind-rearrange
      full-bind-loop
    then
  then
;

# Full application for variadic closures (with rest params)
: apply-full-variadic ( Sexpr SexprList Env -- EvalResult )
  # Stack: ClosureSexpr Args CallerEnv (pos 2,1,0)
  2 pick sclosure-val  # -> ClosureSexpr Args CallerEnv Closure (pos 3,2,1,0)
  # For named closures, add self-binding for recursion
  dup closure-env  # -> ClosureSexpr Args CallerEnv Closure ClosureEnv
  over named-closure? if
    over closure-self-name  # -> ... Closure ClosureEnv SelfName
    5 pick  # -> ... Closure ClosureEnv SelfName ClosureSexpr
    rot env-extend  # -> ... Closure BaseEnv
  then  # -> ClosureSexpr Args CallerEnv Closure BaseEnv (pos 4,3,2,1,0)
  over closure-params slist-val  # -> ... Closure BaseEnv Params (pos 5,4,3,2,1,0)
  4 pick  # -> ... Params Args
  4 pick  # -> ... Params Args CallerEnv
  variadic-bind-loop  # -> ... Closure ExtEnv EvalResult

  dup eval-err? if
    nip nip nip nip nip
  else
    drop  # drop success marker
    # Stack: ClosureSexpr Args CallerEnv Closure ExtEnv
    swap closure-body swap  # -> ClosureSexpr Args CallerEnv Body ExtEnv
    # TCO: Clean up stack BEFORE tail call (not after)
    rot drop rot drop rot drop  # -> Body ExtEnv
    eval-with-env  # TRUE TAIL CALL - Seq's TCO handles the rest
  then
;

# Helper: bind args to params for variadic closures (handles . rest)
: variadic-bind-loop ( Env SexprList SexprList Env -- Env EvalResult )
  # Stack: AccEnv Params Args EvalEnv
  # Check if first param is the dot
  2 pick scar is-dot-symbol? if
    # Rest param: evaluate all remaining args and bind as list
    # Stack: AccEnv Params Args EvalEnv
    # Get rest param name (param after the dot)
    2 pick scdr scar ssym-val  # -> ... EvalEnv RestParamName
    # Evaluate all remaining args and collect as list
    2 pick                     # -> ... RestParamName Args
    3 pick                     # -> ... RestParamName Args EvalEnv
    eval-collect-rest          # -> ... RestParamName EvalResult
    dup eval-err? if
      # Error during evaluation
      nip nip nip nip nip  # -> EvalResult... need to fix stack
      swap drop swap drop swap drop  # -> AccEnv EvalResult
    else
      eval-ok-value              # -> AccEnv Params Args EvalEnv RestParamName RestList
      # Bind rest param name to the collected list
      5 roll                     # -> Params Args EvalEnv RestParamName RestList AccEnv
      env-extend                 # -> Params Args EvalEnv ExtEnv
      nip nip nip                # -> ExtEnv
      snil slist eval-ok         # success marker
    then
  else
    # Regular param or base case
    2 pick snil? if
      # No more params - return accumulated env
      drop drop drop  # -> AccEnv
      snil slist eval-ok  # success marker
    else
      # Eval first arg
      over scar over eval-with-env  # -> AccEnv Params Args EvalEnv EvalResult
      dup eval-err? if
        nip nip nip  # -> AccEnv EvalResult
      else
        eval-ok-value  # -> AccEnv Params Args EvalEnv ArgVal
        4 roll  # -> Params Args EvalEnv ArgVal AccEnv
        4 pick scar ssym-val  # -> Params Args EvalEnv ArgVal AccEnv ParamName
        rot rot env-extend  # -> Params Args EvalEnv NewEnv
        bind-rearrange
        variadic-bind-loop
      then
    then
  then
;

# Helper: evaluate all args and collect as a list
: eval-collect-rest ( SexprList Env -- EvalResult )
  # Stack: Args EvalEnv
  # Returns EvalOk with a list of evaluated args, or EvalErr
  swap snil swap  # -> EvalEnv AccList Args
  eval-collect-rest-loop
;

: eval-collect-rest-loop ( Env SexprList SexprList -- EvalResult )
  # Stack: EvalEnv AccList Args
  dup snil? if
    # No more args - reverse AccList and return
    drop           # -> EvalEnv AccList
    nip            # -> AccList
    reverse-sexprlist slist eval-ok
  else
    # Eval first arg
    dup scar       # -> EvalEnv AccList Args FirstArg
    3 pick         # -> EvalEnv AccList Args FirstArg EvalEnv
    eval-with-env  # -> EvalEnv AccList Args EvalResult
    dup eval-err? if
      nip nip nip  # -> EvalResult
    else
      eval-ok-value  # -> EvalEnv AccList Args EvalValue
      # Prepend EvalValue to AccList: need to get AccList
      2 pick         # -> EvalEnv AccList Args EvalValue AccList
      scons          # -> EvalEnv AccList Args NewAccList
      # Rearrange to: EvalEnv NewAccList RestArgs
      rot drop       # -> EvalEnv Args NewAccList
      swap scdr      # -> EvalEnv NewAccList RestArgs
      eval-collect-rest-loop
    then
  then
;

# Helper: reverse an SexprList
: reverse-sexprlist ( SexprList -- SexprList )
  snil swap reverse-sexprlist-loop
;

: reverse-sexprlist-loop ( SexprList SexprList -- SexprList )
  # Stack: Acc Input
  dup snil? if
    drop  # -> Acc
  else
    dup scar     # -> Acc Input Head
    rot          # -> Input Head Acc
    scons        # -> Input NewAcc
    swap scdr    # -> NewAcc RestInput
    reverse-sexprlist-loop
  then
;

# Over-application: apply with available params, chain-apply rest
: apply-chain ( Sexpr SexprList Env -- EvalResult )
  # Stack: ClosureSexpr Args CallerEnv
  # Get param count to know how many args to consume
  2 pick sclosure-val closure-params slist-val list-length  # -> ... ParamCount

  # Split args into first batch (for this call) and rest (for chaining)
  2 pick swap split-list  # -> ClosureSexpr Args CallerEnv FirstArgs RestArgs

  # Apply closure to first batch
  # Stack: ClosureSexpr Args CallerEnv FirstArgs RestArgs (4,3,2,1,0)
  swap             # -> ClosureSexpr Args CallerEnv RestArgs FirstArgs
  4 pick           # -> ... FirstArgs ClosureSexpr (copy closure)
  swap             # -> ... ClosureSexpr FirstArgs
  3 pick           # -> ... ClosureSexpr FirstArgs CallerEnv (copy env)
  apply-full       # -> ClosureSexpr Args CallerEnv RestArgs EvalResult

  dup eval-err? if
    # Error - clean up and return
    nip nip nip nip  # -> EvalResult
  else
    # Got a result - verify it's a closure before trying to apply more args
    eval-ok-value  # -> ClosureSexpr Args CallerEnv RestArgs ResultValue
    dup sclosure? if
      # It's a closure - apply rest args to it
      swap rot       # -> ClosureSexpr Args ResultClosure RestArgs CallerEnv
      # TCO: Clean up stack BEFORE tail call (not after)
      4 roll drop    # -> Args ResultClosure RestArgs CallerEnv (ClosureSexpr dropped)
      3 roll drop    # -> ResultClosure RestArgs CallerEnv (Args dropped)
      apply-closure  # TRUE TAIL CALL - Seq's TCO handles the rest
    else
      # Not a closure - can't apply more arguments
      drop drop drop drop drop "over-application: result is not a function" eval-err
    then
  then
;

# Split a list: take first N elements, return (first-n, rest)
: split-list ( SexprList Int -- SexprList SexprList )
  # Stack: List Count
  snil rot rot  # -> snil List Count (Acc Rest Count for loop)
  split-list-loop
  swap list-reverse swap  # reverse accumulated first part
;

: split-list-loop ( SexprList SexprList Int -- SexprList SexprList )
  # Stack: Acc Rest Count (2,1,0)
  dup 0 = if
    drop  # -> Acc Rest
  else
    # Count > 0: take one element from Rest, add to Acc, decrement Count
    1 subtract         # -> Acc Rest NewCount
    swap               # -> Acc NewCount Rest
    dup scar           # -> Acc NewCount Rest FirstElem
    swap scdr          # -> Acc NewCount FirstElem RestTail
    # Rearrange and cons FirstElem onto Acc
    rot                # -> Acc FirstElem RestTail NewCount
    3 roll             # -> FirstElem RestTail NewCount Acc
    rot                # -> FirstElem NewCount Acc RestTail
    3 roll             # -> NewCount Acc RestTail FirstElem
    3 roll             # -> Acc RestTail FirstElem NewCount
    rot                # -> Acc FirstElem NewCount RestTail
    rot                # -> Acc NewCount RestTail FirstElem
    3 roll             # -> NewCount RestTail FirstElem Acc
    scons              # -> NewCount RestTail NewAcc
    rot rot swap       # -> NewAcc RestTail NewCount
    split-list-loop
  then
;

# Note: list-reverse is already defined in parser.seq

# Single-parameter closure application for map/filter
# Does NOT evaluate the argument - it's already a value
: apply-closure-val ( LispClosure Sexpr Env -- EvalResult )
  # Stack: Closure ArgVal CallerEnv
  # ArgVal is already evaluated, just bind and run
  # Get closure components
  2 pick closure-params slist-val scar ssym-val  # -> Closure ArgVal CallerEnv ParamName
  rot  # -> Closure CallerEnv ParamName ArgVal
  3 pick closure-env  # -> Closure CallerEnv ParamName ArgVal ClosureEnv
  # For named closures, add self-binding for recursion (O(1) instead of O(n) env-concat)
  4 pick named-closure? if
    4 pick closure-self-name  # -> ... ClosureEnv SelfName
    5 pick sclosure  # -> ... ClosureEnv SelfName ClosureSexpr
    rot env-extend  # -> ... BaseEnv
  then  # -> Closure CallerEnv ParamName ArgVal BaseEnv
  env-extend  # -> Closure CallerEnv ExtendedEnv
  # Evaluate body
  rot closure-body  # -> CallerEnv ExtendedEnv Body
  swap eval-with-env  # -> CallerEnv EvalResult
  nip  # -> EvalResult
;

# Two-parameter closure application (for fold)
# Simple approach: build env first, then evaluate
: apply-closure-2 ( LispClosure SexprList Env -- EvalResult )
  # Input stack: Closure Args CallerEnv (pos: 2 1 0)
  # Args is (Arg1 Arg2) where Arg1=acc, Arg2=elem for fold

  # Build extended environment: bind both params then eval body
  # For named closures, add self-binding for recursion (O(1) instead of O(n) env-concat)
  # then extend with param1=arg1, then param2=arg2

  # Get closure's captured env
  2 pick closure-env     # -> Closure Args CallerEnv ClosureEnv
  # For named closures, add self-binding
  3 pick named-closure? if
    3 pick closure-self-name  # -> ... ClosureEnv SelfName
    4 pick sclosure  # -> ... ClosureEnv SelfName ClosureSexpr
    rot env-extend  # -> ... BaseEnv
  then  # -> Closure Args CallerEnv BaseEnv

  # Now bind param1 (first param gets first arg)
  # env-extend signature: ( String Sexpr Env -- Env )
  3 pick closure-params slist-val scar ssym-val  # -> ... BaseEnv Param1Name
  3 pick scar                          # -> ... BaseEnv Param1Name Arg1
  rot env-extend                       # -> Closure Args CallerEnv Env1

  # Now bind param2 (second param gets second arg)
  3 pick closure-params slist-val scdr scar ssym-val  # -> ... Env1 Param2Name
  3 pick scdr scar                          # -> ... Env1 Param2Name Arg2
  rot env-extend                            # -> Closure Args CallerEnv Env2

  # Evaluate body in extended environment
  3 pick closure-body                  # -> Closure Args CallerEnv Env2 Body
  swap eval-with-env                   # -> Closure Args CallerEnv EvalResult
  nip nip nip                          # -> EvalResult
;

# ============================================
# Macro Application
# ============================================

# Check macro arity - returns 1 if OK, 0 if mismatch
# Also returns error message (or empty string if OK)
: check-macro-arity ( SexprList SexprList -- Int String )
  # Stack: Params Args
  # Returns: (IsOK, ErrorMsg)
  over has-rest-param? if
    # Variadic: need >= required params
    over count-required-params  # -> Params Args Required
    over list-length            # -> Params Args Required ArgCount
    over over <= if             # Required <= ArgCount means ArgCount >= Required
      drop drop drop drop 1 ""  # OK
    else
      # Not enough args
      # Stack: Params Args Required ArgCount
      swap  # -> Params Args ArgCount Required
      "macro expects at least " swap int->string string.concat
      " argument(s), got " string.concat
      swap int->string string.concat
      # Stack: Params Args ErrorMsg
      nip nip       # -> ErrorMsg
      0 swap        # -> 0 ErrorMsg
    then
  else
    # Non-variadic: need exact match
    # Stack: Params Args
    swap dup list-length  # -> Args Params ParamCount
    rot dup list-length   # -> Params ParamCount Args ArgCount
    rot swap              # -> Params Args ParamCount ArgCount
    over over = if
      drop drop drop drop 1 ""  # OK
    else
      # Mismatch: Stack is Params Args ParamCount ArgCount
      swap  # -> Params Args ArgCount ParamCount
      "macro expects " swap int->string string.concat
      " argument(s), got " string.concat
      swap int->string string.concat
      # Stack: Params Args ErrorMsg
      nip nip       # -> ErrorMsg
      0 swap        # -> 0 ErrorMsg
    then
  then
;

# Apply macro: args are NOT evaluated, bind directly to params
# Then evaluate body (produces expansion), then evaluate expansion
: apply-macro ( Sexpr SexprList Env -- EvalResult )
  # Stack: MacroSexpr Args CallerEnv

  # Check arity
  2 pick smacro-val closure-params slist-val  # -> MacroSexpr Args CallerEnv Params
  2 pick  # -> MacroSexpr Args CallerEnv Params Args
  check-macro-arity  # -> MacroSexpr Args CallerEnv IsOK ErrorMsg

  swap if
    # Arity OK - proceed with expansion
    drop  # Drop empty error message
    # Get macro components
    2 pick smacro-val  # -> MacroSexpr Args CallerEnv MacroClosure
    dup closure-env    # -> MacroSexpr Args CallerEnv MacroClosure MacroEnv
    swap closure-params slist-val  # -> MacroSexpr Args CallerEnv MacroEnv Params

    # Bind unevaluated args to params
    3 pick  # -> MacroSexpr Args CallerEnv MacroEnv Params Args
    macro-bind-loop  # -> MacroSexpr Args CallerEnv ExtendedEnv

    # Evaluate macro body in extended env (produces expansion)
    3 pick smacro-val closure-body  # -> MacroSexpr Args CallerEnv ExtendedEnv Body
    swap eval-with-env  # -> MacroSexpr Args CallerEnv EvalResult

    dup eval-err? if
      # Error during expansion - propagate
      nip nip nip
    else
      # Got expansion - now evaluate it in caller's environment
      eval-ok-value  # -> MacroSexpr Args CallerEnv Expansion
      swap eval-with-env  # -> MacroSexpr Args EvalResult
      nip nip
    then
  else
    # Arity mismatch - return error
    eval-err nip nip nip
  then
;

# Check if a symbol is the dot (.) for rest params
: is-dot-symbol? ( Sexpr -- Int )
  dup ssym? if
    ssym-val "." string.equal?
  else
    drop 0
  then
;

# Check if params list has a rest param (contains .)
: has-rest-param? ( SexprList -- Int )
  dup snil? if
    drop 0
  else
    dup scar is-dot-symbol? if
      drop 1
    else
      scdr has-rest-param?
    then
  then
;

# Count params before the dot (or all if no dot)
: count-required-params ( SexprList -- Int )
  0 swap count-required-params-loop
;

: count-required-params-loop ( Int SexprList -- Int )
  dup snil? if
    drop
  else
    dup scar is-dot-symbol? if
      drop  # Found dot, return current count
    else
      scdr swap 1 add swap count-required-params-loop
    then
  then
;

# Count dot symbols in a param list
: count-dots ( SexprList -- Int )
  0 swap count-dots-loop
;

: count-dots-loop ( Int SexprList -- Int )
  dup snil? if
    drop
  else
    dup scar is-dot-symbol? if
      scdr swap 1 add swap count-dots-loop
    else
      scdr count-dots-loop
    then
  then
;

# Validate rest parameter syntax
# Returns: 1 if valid, 0 if invalid
# Also returns error message (or empty string if valid)
: validate-rest-params ( SexprList -- Int String )
  # Check number of dots
  dup count-dots
  dup 1 > if
    # More than one dot
    drop drop 0 "defmacro: multiple dots in parameter list"
  else dup 0 = if
    # No dots - valid
    drop drop 1 ""
  else
    # Exactly one dot - check syntax
    drop  # -> Params
    dup has-rest-param? if
      # Find the dot and check what follows
      validate-after-dot
    else
      drop 1 ""  # No rest param (shouldn't happen if count-dots is 1)
    then
  then then
;

# Helper to validate what comes after the dot
: validate-after-dot ( SexprList -- Int String )
  dup snil? if
    drop 1 ""
  else
    dup scar is-dot-symbol? if
      # Found the dot - check what follows
      scdr  # -> RestOfList (after dot)
      dup snil? if
        # Dot at end with nothing after
        drop 0 "defmacro: dot requires a parameter name after it"
      else
        dup scar dup ssym? if
          # Next element is a symbol - good!
          drop scdr  # -> Rest after the symbol
          snil? if
            # Nothing after the rest param name - valid!
            1 ""
          else
            # Extra elements after rest param
            0 "defmacro: only one parameter allowed after dot"
          then
        else
          # Not a symbol after dot
          drop drop 0 "defmacro: parameter after dot must be a symbol"
        then
      then
    else
      scdr validate-after-dot
    then
  then
;

# Collect remaining args into a list (as Sexpr)
: collect-rest-args ( SexprList -- Sexpr )
  slist
;

# Helper: bind unevaluated args to params (supports rest params)
: macro-bind-loop ( Env SexprList SexprList -- Env )
  # Stack: AccEnv Params Args
  over snil? if
    # No more params - return accumulated env
    drop drop  # -> AccEnv
  else
    # Check if first param is the dot
    over scar is-dot-symbol? if
      # Rest param: bind remaining args to param after dot
      swap scdr scar ssym-val  # -> AccEnv Args RestParamName
      swap collect-rest-args   # -> AccEnv RestParamName ArgsAsList
      rot env-extend           # -> ExtendedEnv
    else dup snil? if
      # No more args but have params - error case, just stop
      drop drop  # -> AccEnv
    else
      # Regular param: bind first arg to first param
      over scar ssym-val  # -> AccEnv Params Args ParamName
      over scar           # -> AccEnv Params Args ParamName ArgExpr
      # Extend env
      4 pick              # -> AccEnv Params Args ParamName ArgExpr AccEnv
      env-extend          # -> AccEnv Params Args NewEnv
      # Rearrange: need NewEnv RestParams RestArgs
      3 roll drop         # -> Params Args NewEnv (remove old AccEnv)
      rot scdr            # -> Args NewEnv RestParams
      rot scdr            # -> NewEnv RestParams RestArgs
      rot                 # -> RestParams RestArgs NewEnv
      rot rot             # -> NewEnv RestParams RestArgs
      macro-bind-loop
    then then
  then
;

# ============================================
# REPL Helper
# ============================================

: eval-print ( String -- )
  parse env-empty eval-with-env
  dup eval-err? if
    "Error: " swap eval-err-message string.concat io.write-line
  else
    eval-ok-value sexpr-to-string io.write-line
  then ;
