# Evaluator for SeqLisp
#
# Currently supports:
# - Numbers: return as-is
# - Symbols: lookup in environment
# - Arithmetic: +, -, *, /
# - Comparisons: <, >, <=, >=, =
# - let: local binding
# - if: conditional
# - lambda: anonymous functions
# - define: global definitions
# - print: output

include "parser"

# ============================================
# EvalResult Union Type
#
# All eval functions return EvalResult for consistent error handling.
# This replaces the ad-hoc high-tag approach with a proper union type.
# ============================================

union EvalResult {
  EvalOk { value: Sexpr }
  EvalErr { message: String }
  EvalDefine { name: String, def_value: Sexpr }
}

# Constructors
: eval-ok ( Sexpr -- EvalResult )
  Make-EvalOk ;

: eval-err ( String -- EvalResult )
  Make-EvalErr ;

: eval-define ( String Sexpr -- EvalResult )
  Make-EvalDefine ;

# Predicates
: eval-ok? ( EvalResult -- Int )
  variant.tag 0 = ;

: eval-err? ( EvalResult -- Int )
  variant.tag 1 = ;

: eval-define? ( EvalResult -- Int )
  variant.tag 2 = ;

# Accessors
: eval-ok-value ( EvalResult -- Sexpr )
  0 variant.field-at ;

: eval-err-message ( EvalResult -- String )
  0 variant.field-at ;

: eval-define-name ( EvalResult -- String )
  0 variant.field-at ;

: eval-define-value ( EvalResult -- Sexpr )
  1 variant.field-at ;


# ============================================
# Arity Checking Helpers
# ============================================

# Count elements in an SexprList
: list-length ( SexprList -- Int )
  0 swap list-length-loop ;

: list-length-loop ( Int SexprList -- Int )
  dup snil? if
    drop
  else
    scdr swap 1 add swap list-length-loop
  then ;

# Count arguments in a list (excluding the function name)
: count-args ( SexprList -- Int )
  scdr  # Skip function name
  list-length ;

# Check if argument count equals expected
# Returns: EvalOk with unit value (empty list) on success, EvalErr on failure
# The original List is left on stack in both cases for caller to clean up
# Usage pattern in caller:
#   over 1 "funcname" check-arity    # List Env List EvalResult
#   dup eval-err? if
#     nip nip nip                    # EvalErr
#   else
#     drop drop                      # List Env (drop List copy and EvalOk)
#     ... normal implementation
#   then
: check-arity ( SexprList Int String -- SexprList EvalResult )
  # Stack: List Expected FuncName
  2 pick count-args  # Stack: List Expected FuncName Actual
  2 pick = if        # Compares Actual with Expected (copy), consumes both
    # Stack: List Expected FuncName - arity matches
    drop drop        # Stack: List
    snil slist eval-ok  # Return List and EvalOk
  else
    # Stack: List Expected FuncName - arity mismatch
    " expects " string.concat  # "funcname expects "
    swap int->string string.concat  # "funcname expects N"
    " argument(s)" string.concat  # "funcname expects N argument(s)"
    eval-err  # Stack: List EvalErr
  then ;

# Check minimum arity (for variadic forms like function define)
: check-min-arity ( SexprList Int String -- SexprList EvalResult )
  # Stack: List MinExpected FuncName
  2 pick count-args  # Stack: List MinExpected FuncName Actual
  2 pick >= if       # Actual >= MinExpected
    # Stack: List MinExpected FuncName - arity ok
    drop drop        # Stack: List
    snil slist eval-ok  # Return List and EvalOk
  else
    # Stack: List MinExpected FuncName - not enough args
    " expects at least " string.concat
    swap int->string string.concat
    " argument(s)" string.concat
    eval-err  # Stack: List EvalErr
  then ;

# ============================================
# Environment Operations
#
# Types are defined in sexpr.seq:
#   Binding, Env, Closure are now part of the core type system
# ============================================

: env-lookup ( String Env -- EvalResult )
  # Stack: Name Env
  # Returns EvalOk with the value, or EvalErr if not found
  dup variant.tag 0 = if
    # EnvEmpty - not found, return error
    drop "undefined symbol: " swap string.concat eval-err
  else
    # EnvExtend - extract binding and parent
    dup 0 variant.field-at  # Name Env Binding
    dup binding-name        # Name Env Binding BindingName
    3 pick string.equal? if
      # Found it
      binding-value         # Name Env Value
      nip nip               # Value
      eval-ok
    else
      # Keep looking
      drop                  # Name Env
      1 variant.field-at    # Name Parent
      env-lookup
    then
  then ;

# Concatenate two environments (Env1 bindings prepended to Env2)
: env-concat ( Env Env -- Env )
  # Stack: Env1 Env2 -> Result where Env1 bindings come first
  swap  # Env2 Env1
  dup variant.tag 0 = if
    # EnvEmpty - just return Env2
    drop
  else
    # EnvExtend - extract binding and parent
    dup 0 variant.field-at  # Env2 Env1 Binding
    swap 1 variant.field-at # Env2 Binding Parent
    rot                     # Binding Parent Env2
    env-concat              # Binding ConcatResult
    Make-EnvExtend          # Result
  then ;

# ============================================
# Main Evaluator
# ============================================

# Simple eval without environment (for backward compatibility)
# Returns raw Sexpr for convenience - unwraps EvalOk, returns snil on error
: eval ( Sexpr -- Sexpr )
  env-empty eval-with-env
  dup eval-ok? if
    eval-ok-value
  else
    drop snil slist  # Return empty list on error
  then ;

# Eval with explicit environment
# Returns: EvalResult (EvalOk, EvalErr, or EvalDefine)
: eval-with-env ( Sexpr Env -- EvalResult )
  # Stack: Expr Env
  over variant.tag
  dup 0 = if
    # SNum - return as-is wrapped in EvalOk
    drop drop eval-ok
  else
    dup 1 = if
      # SSym - check for self-evaluating symbols (#t, #f) or lookup
      drop swap dup ssym-val
      dup "#t" string.equal? over "#f" string.equal? or if
        # Boolean literal - return as-is
        drop nip eval-ok
      else
        # Regular symbol - lookup in environment
        swap drop swap env-lookup
        # env-lookup now returns EvalResult directly
      then
    else
      2 = if
        # SList - function application
        eval-list-with-env
      else
        # Unknown - return as-is
        drop drop eval-ok
      then
    then
  then
;

# ============================================
# List Evaluation (Function Application)
# ============================================

: eval-list-with-env ( Sexpr Env -- EvalResult )
  # Stack: Expr Env
  swap slist-val
  dup snil? if
    # Empty list - return empty list
    nip slist eval-ok
  else
    # Non-empty list: first element is function
    dup scar
    dup ssym? if
      # Symbol - check for built-in functions
      # Stack: Env List Head
      ssym-val swap rot eval-builtin-with-env
    else
      dup slist? if
        # List in function position - evaluate it (likely a lambda)
        # Stack: Env List Head
        2 pick eval-with-env  # -> Env List EvalResult
        dup eval-err? if
          # Error - propagate it
          nip nip nip
        else
          eval-ok-value  # Unwrap to get the Sexpr
          dup sclosure? if
            # It's a closure - apply it
            # Stack: Env List ClosureSexpr
            rot rot  # -> ClosureSexpr Env List
            scdr     # -> ClosureSexpr Env Args
            swap     # -> ClosureSexpr Args Env
            apply-closure
          else
            # Not a closure - error
            drop drop drop "not a function" eval-err
          then
        then
      else
        # Non-symbol, non-list in function position
        drop drop drop "invalid function position" eval-err
      then
    then
  then
;

# ============================================
# Built-in Function Dispatch
#
# Dispatch is organized into logical groups to reduce nesting.
# Each group handles related builtins and delegates to the next
# group if no match is found.
#
# Groups:
#   1. Arithmetic: + - * /
#   2. Comparison: < > <= >= =
#   3. Special forms: if let lambda define quote
#   4. List operations: cons car cdr list
#   5. Predicates: null? number? symbol? list? boolean?
#   6. Control flow: begin cond
#   7. I/O: print
#   8. Fallback: environment lookup for user-defined functions
# ============================================

: eval-builtin-with-env ( String SexprList Env -- EvalResult )
  # Stack: FuncName List Env
  rot  # -> List Env FuncName
  dispatch-arithmetic
;

# ----------------------------------------
# Group 1: Arithmetic (+, -, *, /)
# ----------------------------------------
: dispatch-arithmetic ( SexprList Env String -- EvalResult )
  dup "+" string.equal? if
    drop eval-add-with-env
  else dup "-" string.equal? if
    drop eval-sub-with-env
  else dup "*" string.equal? if
    drop eval-mul-with-env
  else dup "/" string.equal? if
    drop eval-div-with-env
  else
    dispatch-comparison
  then then then then
;

# ----------------------------------------
# Group 2: Comparison (<, >, <=, >=, =)
# ----------------------------------------
: dispatch-comparison ( SexprList Env String -- EvalResult )
  dup "<" string.equal? if
    drop eval-lt-with-env
  else dup ">" string.equal? if
    drop eval-gt-with-env
  else dup "<=" string.equal? if
    drop eval-lte-with-env
  else dup ">=" string.equal? if
    drop eval-gte-with-env
  else dup "=" string.equal? if
    drop eval-eq-with-env
  else
    dispatch-special-forms
  then then then then then
;

# ----------------------------------------
# Group 3: Special Forms (if, let, lambda, define, quote)
# ----------------------------------------
: dispatch-special-forms ( SexprList Env String -- EvalResult )
  dup "if" string.equal? if
    drop eval-if-with-env
  else dup "let" string.equal? if
    drop eval-let-with-env
  else dup "lambda" string.equal? if
    drop eval-lambda-with-env
  else dup "define" string.equal? if
    drop eval-define-with-env
  else dup "quote" string.equal? if
    drop eval-quote-with-env
  else
    dispatch-list-ops
  then then then then then
;

# ----------------------------------------
# Group 4: List Operations (cons, car, cdr, list, append, reverse, map, filter, fold)
# ----------------------------------------
: dispatch-list-ops ( SexprList Env String -- EvalResult )
  dup "cons" string.equal? if
    drop eval-cons-with-env
  else dup "car" string.equal? if
    drop eval-car-with-env
  else dup "cdr" string.equal? if
    drop eval-cdr-with-env
  else dup "list" string.equal? if
    drop eval-list-builtin-with-env
  else dup "append" string.equal? if
    drop eval-append-with-env
  else dup "reverse" string.equal? if
    drop eval-reverse-with-env
  else dup "map" string.equal? if
    drop eval-map-with-env
  else dup "filter" string.equal? if
    drop eval-filter-with-env
  else dup "fold" string.equal? if
    drop eval-fold-with-env
  else
    dispatch-predicates
  then then then then then then then then then
;

# ----------------------------------------
# Group 5: Predicates (null?, number?, symbol?, list?, boolean?)
# ----------------------------------------
: dispatch-predicates ( SexprList Env String -- EvalResult )
  dup "null?" string.equal? if
    drop eval-null?-with-env
  else dup "number?" string.equal? if
    drop eval-number?-with-env
  else dup "symbol?" string.equal? if
    drop eval-symbol?-with-env
  else dup "list?" string.equal? if
    drop eval-list?-with-env
  else dup "boolean?" string.equal? if
    drop eval-boolean?-with-env
  else
    dispatch-control-flow
  then then then then then
;

# ----------------------------------------
# Group 6: Control Flow (begin, cond)
# ----------------------------------------
: dispatch-control-flow ( SexprList Env String -- EvalResult )
  dup "begin" string.equal? if
    drop eval-begin-with-env
  else dup "cond" string.equal? if
    drop eval-cond-with-env
  else
    dispatch-io
  then then
;

# ----------------------------------------
# Group 7: I/O (print)
# ----------------------------------------
: dispatch-io ( SexprList Env String -- EvalResult )
  dup "print" string.equal? if
    drop eval-print-with-env
  else
    dispatch-user-defined
  then
;

# ----------------------------------------
# Group 8: User-defined functions (environment lookup)
# ----------------------------------------
: dispatch-user-defined ( SexprList Env String -- EvalResult )
  # Stack: List Env FuncName
  over  # List Env FuncName Env
  env-lookup  # List Env EvalResult
  dup eval-err? if
    # Symbol not found - propagate error
    nip nip
  else
    # Found something
    eval-ok-value  # List Env Value
    dup sclosure? if
      # Apply the closure
      # Stack: List Env ClosureSexpr
      rot  # Env ClosureSexpr List
      scdr  # Env ClosureSexpr Args (skip function name)
      rot  # ClosureSexpr Args Env
      apply-closure
    else
      # Not a closure - type error
      drop drop drop "not a function" eval-err
    then
  then
;

# ============================================
# Arithmetic Operations
# ============================================

: eval-add-with-env ( SexprList Env -- EvalResult )
  # Stack: List Env
  swap scdr swap  # Skip the + -> RestList Env
  0 swap eval-fold-add-with-env
;

: eval-fold-add-with-env ( SexprList Int Env -- EvalResult )
  # Stack: List Acc Env
  2 pick snil? if
    # List is empty, return Acc as Sexpr wrapped in EvalOk
    drop nip snum eval-ok
  else
    # Get first element and eval it
    2 pick scar over eval-with-env
    # Stack: List Acc Env EvalResult
    dup eval-err? if
      # Error - propagate it up, clean stack
      nip nip nip
    else
      eval-ok-value
      # Stack: List Acc Env Value
      dup snum? if
        snum-val
        # Stack: List Acc Env FirstVal
        rot add
        # Stack: List Env NewAcc
        swap rot scdr rot rot
        # Stack: RestList NewAcc Env
        eval-fold-add-with-env
      else
        # Type error - not a number
        drop drop drop drop "+: argument must be a number" eval-err
      then
    then
  then
;

: eval-sub-with-env ( SexprList Env -- EvalResult )
  # Stack: List Env
  swap scdr
  dup snil? if
    drop drop 0 snum eval-ok
  else
    dup scar 2 pick eval-with-env
    dup eval-err? if
      nip nip nip
    else
      eval-ok-value
      dup snum? if
        snum-val
        swap scdr
        dup snil? if
          # Unary minus: negate
          drop nip 0 swap subtract snum eval-ok
        else
          # Binary minus: first - rest
          # Stack: Env FirstVal RestList -> need RestList FirstVal Env
          rot rot swap eval-fold-sub-with-env
        then
      else
        # Type error - not a number
        drop drop drop "-: argument must be a number" eval-err
      then
    then
  then
;

: eval-fold-sub-with-env ( SexprList Int Env -- EvalResult )
  # Stack: List Acc Env
  2 pick snil? if
    # List is empty, return Acc
    drop nip snum eval-ok
  else
    # Get first element and eval it
    2 pick scar over eval-with-env
    dup eval-err? if
      nip nip nip
    else
      eval-ok-value
      dup snum? if
        snum-val
        # Stack: List Acc Env FirstVal
        rot swap subtract
        # Stack: List Env NewAcc
        swap rot scdr rot rot
        # Stack: RestList NewAcc Env
        eval-fold-sub-with-env
      else
        # Type error - not a number
        drop drop drop drop "-: argument must be a number" eval-err
      then
    then
  then
;

: eval-mul-with-env ( SexprList Env -- EvalResult )
  # Stack: List Env
  swap scdr swap  # Skip the * -> RestList Env
  1 swap eval-fold-mul-with-env
;

: eval-fold-mul-with-env ( SexprList Int Env -- EvalResult )
  # Stack: List Acc Env
  2 pick snil? if
    # List is empty, return Acc
    drop nip snum eval-ok
  else
    # Get first element and eval it
    2 pick scar over eval-with-env
    dup eval-err? if
      nip nip nip
    else
      eval-ok-value
      dup snum? if
        snum-val
        # Stack: List Acc Env FirstVal
        rot multiply
        # Stack: List Env NewAcc
        swap rot scdr rot rot
        # Stack: RestList NewAcc Env
        eval-fold-mul-with-env
      else
        # Type error - not a number
        drop drop drop drop "*: argument must be a number" eval-err
      then
    then
  then
;

: eval-div-with-env ( SexprList Env -- EvalResult )
  # Stack: List Env
  swap scdr
  dup snil? if
    drop drop 0 snum eval-ok
  else
    dup scar 2 pick eval-with-env
    dup eval-err? if
      nip nip nip
    else
      eval-ok-value
      dup snum? if
        snum-val
        swap scdr
        dup snil? if
          drop nip snum eval-ok
        else
          # Stack: Env FirstVal RestList -> need RestList FirstVal Env
          rot rot swap eval-fold-div-with-env
        then
      else
        # Type error - not a number
        drop drop drop "/: argument must be a number" eval-err
      then
    then
  then
;

: eval-fold-div-with-env ( SexprList Int Env -- EvalResult )
  # Stack: List Acc Env
  2 pick snil? if
    # List is empty, return Acc
    drop nip snum eval-ok
  else
    # Get first element and eval it
    2 pick scar over eval-with-env
    dup eval-err? if
      nip nip nip
    else
      eval-ok-value
      dup snum? if
        snum-val
        # Stack: List Acc Env FirstVal
        dup 0 = if
          # Division by zero - return error
          drop drop drop drop "/: division by zero" eval-err
        else
          rot swap divide
          # Stack: List Env NewAcc
          swap rot scdr rot rot
          # Stack: RestList NewAcc Env
          eval-fold-div-with-env
        then
      else
        # Type error - not a number
        drop drop drop drop "/: argument must be a number" eval-err
      then
    then
  then
;

# ============================================
# Comparison Operations
# ============================================

: eval-lt-with-env ( SexprList Env -- EvalResult )
  # Stack: List Env
  # (< a b) returns #t if a < b, else #f
  over 2 "<" check-arity  # -> List Env List EvalResult
  dup eval-err? if
    nip nip nip
  else
    drop drop  # -> List Env
    swap scdr  # Skip the < -> Env Args
    dup scar 2 pick eval-with-env  # Eval first arg -> Env Args EvalResult
    dup eval-err? if
      nip nip nip  # Error - propagate
    else
      eval-ok-value  # -> Env Args FirstVal
      dup snum? if
        snum-val  # -> Env Args First
        swap scdr scar 2 pick eval-with-env  # Eval second arg -> Env First EvalResult
        dup eval-err? if
          nip nip nip  # Error - propagate
        else
          eval-ok-value  # -> Env First SecondVal
          dup snum? if
            snum-val  # -> Env First Second
            < if "#t" else "#f" then ssym eval-ok nip
          else
            drop drop drop "<: arguments must be numbers" eval-err
          then
        then
      else
        drop drop drop "<: arguments must be numbers" eval-err
      then
    then
  then
;

: eval-gt-with-env ( SexprList Env -- EvalResult )
  # (> a b) returns #t if a > b, else #f
  over 2 ">" check-arity  # -> List Env List EvalResult
  dup eval-err? if
    nip nip nip  # -> EvalResult
  else
    drop drop  # -> List Env
    swap scdr  # -> Env Args
    dup scar 2 pick eval-with-env  # -> Env Args EvalResult
    dup eval-err? if
      nip nip nip  # -> EvalResult
    else
      eval-ok-value  # -> Env Args FirstVal
      dup snum? if
        snum-val  # -> Env Args First
        swap scdr scar 2 pick eval-with-env  # -> Env First EvalResult
        dup eval-err? if
          nip nip nip  # -> EvalResult
        else
          eval-ok-value  # -> Env First SecondVal
          dup snum? if
            snum-val  # -> Env First Second
            > if "#t" else "#f" then ssym eval-ok nip  # -> EvalResult
          else
            drop drop drop ">: arguments must be numbers" eval-err
          then
        then
      else
        drop drop drop ">: arguments must be numbers" eval-err
      then
    then
  then
;

: eval-lte-with-env ( SexprList Env -- EvalResult )
  # (<= a b) returns #t if a <= b, else #f
  over 2 "<=" check-arity  # -> List Env List EvalResult
  dup eval-err? if
    nip nip nip  # -> EvalResult
  else
    drop drop  # -> List Env
    swap scdr  # -> Env Args
    dup scar 2 pick eval-with-env  # -> Env Args EvalResult
    dup eval-err? if
      nip nip nip  # -> EvalResult
    else
      eval-ok-value  # -> Env Args FirstVal
      dup snum? if
        snum-val  # -> Env Args First
        swap scdr scar 2 pick eval-with-env  # -> Env First EvalResult
        dup eval-err? if
          nip nip nip  # -> EvalResult
        else
          eval-ok-value  # -> Env First SecondVal
          dup snum? if
            snum-val  # -> Env First Second
            <= if "#t" else "#f" then ssym eval-ok nip  # -> EvalResult
          else
            drop drop drop "<=: arguments must be numbers" eval-err
          then
        then
      else
        drop drop drop "<=: arguments must be numbers" eval-err
      then
    then
  then
;

: eval-gte-with-env ( SexprList Env -- EvalResult )
  # (>= a b) returns #t if a >= b, else #f
  over 2 ">=" check-arity  # -> List Env List EvalResult
  dup eval-err? if
    nip nip nip  # -> EvalResult
  else
    drop drop  # -> List Env
    swap scdr  # -> Env Args
    dup scar 2 pick eval-with-env  # -> Env Args EvalResult
    dup eval-err? if
      nip nip nip  # -> EvalResult
    else
      eval-ok-value  # -> Env Args FirstVal
      dup snum? if
        snum-val  # -> Env Args First
        swap scdr scar 2 pick eval-with-env  # -> Env First EvalResult
        dup eval-err? if
          nip nip nip  # -> EvalResult
        else
          eval-ok-value  # -> Env First SecondVal
          dup snum? if
            snum-val  # -> Env First Second
            >= if "#t" else "#f" then ssym eval-ok nip  # -> EvalResult
          else
            drop drop drop ">=: arguments must be numbers" eval-err
          then
        then
      else
        drop drop drop ">=: arguments must be numbers" eval-err
      then
    then
  then
;

: eval-eq-with-env ( SexprList Env -- EvalResult )
  # (= a b) returns #t if a equals b, else #f
  over 2 "=" check-arity  # -> List Env List EvalResult
  dup eval-err? if
    nip nip nip  # -> EvalResult
  else
    drop drop  # -> List Env
    swap scdr  # -> Env Args
    dup scar 2 pick eval-with-env  # -> Env Args EvalResult
    dup eval-err? if
      nip nip nip  # -> EvalResult
    else
      eval-ok-value  # -> Env Args FirstVal
      dup snum? if
        snum-val  # -> Env Args First
        swap scdr scar 2 pick eval-with-env  # -> Env First EvalResult
        dup eval-err? if
          nip nip nip  # -> EvalResult
        else
          eval-ok-value  # -> Env First SecondVal
          dup snum? if
            snum-val  # -> Env First Second
            = if "#t" else "#f" then ssym eval-ok nip  # -> EvalResult
          else
            drop drop drop "=: arguments must be numbers" eval-err
          then
        then
      else
        drop drop drop "=: arguments must be numbers" eval-err
      then
    then
  then
;

# ============================================
# Print
# ============================================

: eval-print-with-env ( SexprList Env -- EvalResult )
  # Stack: List Env
  # (print expr) - evaluate expr, print result, return result
  swap scdr scar  # Get the expression to print
  swap eval-with-env  # Evaluate it -> EvalResult
  dup eval-err? if
    # Error - just return it
  else
    dup eval-ok-value sexpr-to-string io.write-line  # Print it
    # Return the EvalResult as-is
  then
;

# ============================================
# Define (returns a special result for REPL)
# ============================================

# Simple value binding: (define name value)
: eval-define-simple ( SexprList Env -- EvalResult )
  # Stack: Args Env (Args = (name value))
  over scar ssym-val  # -> Args Env Name
  rot scdr scar  # -> Env Name ValueExpr
  rot  # -> Name ValueExpr Env
  eval-with-env  # -> Name EvalResult
  dup eval-err? if
    nip  # -> EvalResult
  else
    eval-ok-value  # -> Name Value
    eval-define  # -> EvalDefine
  then
;

# Function shorthand: (define (name params...) body)
: eval-define-function ( SexprList Env -- EvalResult )
  # Stack: Args Env (Args = ((name params...) body))
  # For (define (square n) (* n n)):
  #   Args = ((square n) (* n n))
  #   Extract: name="square", params=(n), body=(* n n)

  # Validate that the name/params list is not empty
  over scar slist-val snil? if
    drop drop "define: empty function name" eval-err
  else
    # Get name first and keep it safe at bottom
    over scar slist-val scar ssym-val  # -> Args Env Name
    rot rot  # -> Name Args Env

    # Now build closure like lambda: need Params Body Env
    swap  # -> Name Env Args
    dup scar slist-val scdr slist  # -> Name Env Args Params (skip name, wrap as Sexpr)
    swap scdr scar  # -> Name Env Params Body
    rot  # -> Name Params Body Env
    make-closure  # -> Name Closure
    sclosure  # -> Name ClosureSexpr
    eval-define  # -> EvalDefine
  then
;

: eval-define-with-env ( SexprList Env -- EvalResult )
  # Stack: List Env
  # Two forms:
  #   (define name value) - simple binding
  #   (define (name params...) body) - function shorthand
  # First check we have at least 2 args before accessing them
  over 2 "define" check-min-arity
  dup eval-err? if
    nip nip nip
  else
    drop drop  # -> List Env
    over scdr scar  # -> List Env FirstArg
    dup slist? if
      # Function shorthand
      drop
      swap scdr swap  # -> Args Env
      eval-define-function
    else
      # Value binding - need exactly 2 args (name and value)
      drop
      # Check: skip 'define', skip name, skip value, should be nil
      over scdr scdr scdr snil? if
        swap scdr swap  # -> Args Env
        eval-define-simple
      else
        drop drop "define expects 2 argument(s)" eval-err
      then
    then
  then
;

# ============================================
# Quote (returns argument unevaluated)
# ============================================

: eval-quote-with-env ( SexprList Env -- EvalResult )
  # Stack: List Env
  # (quote expr) - return expr without evaluating
  over 1 "quote" check-arity  # -> List Env List EvalResult
  dup eval-err? if
    nip nip nip  # -> EvalResult
  else
    drop drop  # -> List Env
    drop  # -> List (drop environment, not needed)
    scdr scar  # -> Expr (skip 'quote', get the expression)
    eval-ok  # -> EvalResult
  then
;

# ============================================
# List Operations (cons, car, cdr, list)
# ============================================

: eval-cons-with-env ( SexprList Env -- EvalResult )
  # Stack: List Env
  # (cons head tail) - create new cons cell
  over 2 "cons" check-arity  # -> List Env List EvalResult
  dup eval-err? if
    nip nip nip
  else
    drop drop  # -> List Env
    swap scdr  # Skip 'cons' -> Env Args
    dup scar 2 pick eval-with-env  # Eval head -> Env Args EvalResult
    dup eval-err? if
      nip nip nip
    else
      eval-ok-value  # -> Env Args Head
      swap scdr scar 2 pick eval-with-env  # Eval tail -> Env Head EvalResult
      dup eval-err? if
        nip nip nip
      else
        eval-ok-value  # -> Env Head Tail
        # Tail must be a list (SList)
        dup slist? if
          slist-val  # -> Env Head TailList
          scons slist nip eval-ok  # -> (Head . TailList) as EvalOk
        else
          # Error: tail is not a list
          drop drop drop "cons: second argument must be a list" eval-err
        then
      then
    then
  then
;

: eval-car-with-env ( SexprList Env -- EvalResult )
  # Stack: List Env
  # (car lst) - get first element of list
  over  # -> List Env List
  1 "car" check-arity  # -> List Env List EvalResult
  dup eval-err? if
    # Arity error - return it, drop List copy, List and Env
    nip nip nip
  else
    # Arity OK - drop EvalOk and List copy, proceed with evaluation
    drop drop
    swap scdr scar  # Skip 'car', get arg -> Env Arg
    swap eval-with-env  # Eval arg -> EvalResult
    dup eval-err? if
      # Error - propagate
    else
      eval-ok-value  # Unwrap
      dup slist? if
        slist-val  # -> SexprList
        dup snil? if
          # Empty list - error
          drop "car: cannot take car of empty list" eval-err
        else
          scar eval-ok  # -> First element
        then
      else
        # Not a list - type error
        drop "car: argument must be a list" eval-err
      then
    then
  then
;

: eval-cdr-with-env ( SexprList Env -- EvalResult )
  # Stack: List Env
  # (cdr lst) - get rest of list (tail)
  over  # -> List Env List
  1 "cdr" check-arity  # -> List Env List EvalResult
  dup eval-err? if
    # Arity error - return it, drop List copy, List and Env
    nip nip nip
  else
    # Arity OK - drop EvalOk and List copy, proceed with evaluation
    drop drop
    swap scdr scar  # Skip 'cdr', get arg -> Env Arg
    swap eval-with-env  # Eval arg -> EvalResult
    dup eval-err? if
      # Error - propagate
    else
      eval-ok-value  # Unwrap
      dup slist? if
        slist-val  # -> SexprList
        dup snil? if
          # Empty list - error
          drop "cdr: cannot take cdr of empty list" eval-err
        else
          scdr slist eval-ok  # -> Rest as EvalOk
        then
      else
        # Not a list - type error
        drop "cdr: argument must be a list" eval-err
      then
    then
  then
;

: eval-list-builtin-with-env ( SexprList Env -- EvalResult )
  # Stack: List Env
  # (list a b c ...) - create list from evaluated arguments
  swap scdr  # Skip 'list' -> Env Args
  swap  # -> Args Env
  snil swap  # -> Args Acc Env (Acc starts empty)
  eval-list-items
;

: eval-list-items ( SexprList SexprList Env -- EvalResult )
  # Stack: Args Acc Env
  # Evaluate each arg and cons onto accumulator (in reverse)
  2 pick snil? if
    # Done - reverse accumulator and wrap in SList
    drop nip list-reverse slist eval-ok
  else
    # Eval first arg
    2 pick scar over eval-with-env  # -> Args Acc Env EvalResult
    dup eval-err? if
      nip nip nip  # Error - propagate
    else
      eval-ok-value  # Unwrap -> Args Acc Env Sexpr
      rot scons  # -> Args Env NewAcc
      swap  # -> Args NewAcc Env
      rot scdr rot rot  # -> RestArgs NewAcc Env
      eval-list-items
    then
  then
;

: eval-append-with-env ( SexprList Env -- EvalResult )
  # Stack: List Env
  # (append list1 list2) - concatenates two lists
  over 2 "append" check-arity  # -> List Env List EvalResult
  dup eval-err? if
    nip nip nip
  else
    drop drop  # -> List Env
    swap scdr  # -> Env Args (skip 'append')
    dup scar 2 pick eval-with-env  # Eval first arg -> Env Args EvalResult
    dup eval-err? if
      nip nip nip  # Error - propagate
    else
      eval-ok-value  # -> Env Args List1Val
      dup slist? if
        slist-val  # -> Env Args List1
        swap scdr scar 2 pick eval-with-env  # Eval second arg -> Env List1 EvalResult
        dup eval-err? if
          nip nip nip  # Error - propagate
        else
          eval-ok-value  # -> Env List1 List2Val
          dup slist? if
            slist-val  # -> Env List1 List2
            append-lists slist nip eval-ok
          else
            drop drop drop "append: arguments must be lists" eval-err
          then
        then
      else
        drop drop drop "append: arguments must be lists" eval-err
      then
    then
  then
;

# Helper: append two SexprLists
: append-lists ( SexprList SexprList -- SexprList )
  # Stack: List1 List2
  # Reverse List1, then prepend each element to List2
  swap list-reverse swap append-loop
;

: append-loop ( SexprList SexprList -- SexprList )
  # Stack: ReversedList1 List2
  over snil? if
    nip  # List1 empty - return List2
  else
    over scar swap scons  # -> RevList1 (car :: List2)
    swap scdr swap  # -> RestRevList1 NewList2
    append-loop
  then
;

: eval-reverse-with-env ( SexprList Env -- EvalResult )
  # Stack: List Env
  # (reverse list) - reverses a list
  over 1 "reverse" check-arity  # -> List Env List EvalResult
  dup eval-err? if
    nip nip nip
  else
    drop drop  # -> List Env
    swap scdr scar  # -> Env Arg (skip 'reverse', get arg)
    swap eval-with-env  # Eval arg -> EvalResult
    dup eval-err? if
      # Error - propagate
    else
      eval-ok-value  # -> ListVal
      dup slist? if
        slist-val list-reverse slist eval-ok
      else
        drop "reverse: argument must be a list" eval-err
      then
    then
  then
;

# ============================================
# Higher-Order Functions (map, filter, fold)
# ============================================

: eval-map-with-env ( SexprList Env -- EvalResult )
  # Stack: List Env
  # (map fn list) - applies fn to each element, returns new list
  over 2 "map" check-arity  # -> List Env List EvalResult
  dup eval-err? if
    nip nip nip
  else
    drop drop  # -> List Env
    swap scdr  # -> Env Args (skip 'map')
    dup scar 2 pick eval-with-env  # Eval fn -> Env Args EvalResult
    dup eval-err? if
      nip nip nip  # Error - propagate
    else
      eval-ok-value  # -> Env Args FnVal
      dup sclosure? if
        sclosure-val  # -> Env Args Closure (unwrap from Sexpr)
        swap scdr scar 2 pick eval-with-env  # Eval list arg -> Env Closure EvalResult
        dup eval-err? if
          nip nip nip  # Error - propagate
        else
          eval-ok-value  # -> Env Closure ListVal
          dup slist? if
            slist-val  # -> Env Closure SexprList
            snil swap  # -> Env Closure Acc InputList
            map-loop
          else
            drop drop drop "map: second argument must be a list" eval-err
          then
        then
      else
        drop drop drop "map: first argument must be a function" eval-err
      then
    then
  then
;

: map-loop ( Env LispClosure SexprList SexprList -- EvalResult )
  # Stack: Env Closure Acc InputList
  dup snil? if
    # Done - reverse accumulator and return
    drop nip nip list-reverse slist eval-ok
  else
    # Apply closure to car of input (value, not expression)
    dup scar  # -> Env Closure Acc InputList Elem
    # Stack positions: 0:Elem 1:InputList 2:Acc 3:Closure 4:Env
    3 pick  # -> ... Elem Closure
    swap  # -> ... Closure Elem
    5 pick  # -> ... Closure Elem Env
    apply-closure-val  # -> Env Closure Acc InputList EvalResult
    dup eval-err? if
      nip nip nip nip nip  # Error - propagate
    else
      eval-ok-value  # -> Env Closure Acc InputList MappedVal
      rot scons  # -> Env Closure InputList NewAcc
      swap scdr  # -> Env Closure NewAcc RestInput
      map-loop
    then
  then
;

: eval-filter-with-env ( SexprList Env -- EvalResult )
  # Stack: List Env
  # (filter pred list) - keeps elements where (pred elem) is truthy
  over 2 "filter" check-arity  # -> List Env List EvalResult
  dup eval-err? if
    nip nip nip
  else
    drop drop  # -> List Env
    swap scdr  # -> Env Args (skip 'filter')
    dup scar 2 pick eval-with-env  # Eval pred -> Env Args EvalResult
    dup eval-err? if
      nip nip nip  # Error - propagate
    else
      eval-ok-value  # -> Env Args PredVal
      dup sclosure? if
        sclosure-val  # -> Env Args Closure (unwrap from Sexpr)
        swap scdr scar 2 pick eval-with-env  # Eval list arg -> Env Closure EvalResult
        dup eval-err? if
          nip nip nip  # Error - propagate
        else
          eval-ok-value  # -> Env Closure ListVal
          dup slist? if
            slist-val  # -> Env Closure SexprList
            snil swap  # -> Env Closure Acc InputList
            filter-loop
          else
            drop drop drop "filter: second argument must be a list" eval-err
          then
        then
      else
        drop drop drop "filter: first argument must be a function" eval-err
      then
    then
  then
;

: filter-loop ( Env LispClosure SexprList SexprList -- EvalResult )
  # Stack: Env Closure Acc InputList
  dup snil? if
    # Done - reverse accumulator and return
    drop nip nip list-reverse slist eval-ok
  else
    # Apply predicate to car of input (value, not expression)
    dup scar  # -> Env Closure Acc InputList Elem
    dup  # Save elem for later -> Env Closure Acc InputList Elem Elem
    # Stack positions: 0:Elem 1:Elem 2:InputList 3:Acc 4:Closure 5:Env
    4 pick  # -> ... Elem Elem Closure
    swap  # -> ... Elem Closure Elem
    6 pick  # -> ... Elem Closure Elem Env
    apply-closure-val  # -> Env Closure Acc InputList Elem EvalResult
    dup eval-err? if
      nip nip nip nip nip nip  # Error - propagate
    else
      eval-ok-value  # -> Env Closure Acc InputList Elem PredResult
      # Check if truthy (not #f and not ())
      dup ssym? if
        ssym-val "#f" string.equal? if
          # False - don't include, drop elem and advance
          # Stack: Env Closure Acc InputList Elem
          drop  # -> Env Closure Acc InputList
          scdr  # -> Env Closure Acc RestInput
          filter-loop
        else
          # Truthy symbol - include elem
          # Stack: Env Closure Acc InputList Elem (result was consumed by ssym-val)
          rot scons  # -> Env Closure InputList NewAcc
          swap scdr  # -> Env Closure NewAcc RestInput
          filter-loop
        then
      else
        dup slist? if
          slist-val snil? if
            # Empty list is falsy - don't include
            # Stack: Env Closure Acc InputList Elem (slist-val consumed result)
            drop  # -> Env Closure Acc InputList
            scdr  # -> Env Closure Acc RestInput
            filter-loop
          else
            # Non-empty list is truthy - include elem
            # Stack: Env Closure Acc InputList Elem
            rot scons  # -> Env Closure InputList NewAcc
            swap scdr  # -> Env Closure NewAcc RestInput
            filter-loop
          then
        else
          # Number or other - truthy, include elem
          # Stack: Env Closure Acc InputList Elem PredResult
          drop  # drop result -> Env Closure Acc InputList Elem
          rot scons  # -> Env Closure InputList NewAcc
          swap scdr  # -> Env Closure NewAcc RestInput
          filter-loop
        then
      then
    then
  then
;

: eval-fold-with-env ( SexprList Env -- EvalResult )
  # Stack: List Env
  # (fold fn init list) - left fold: fn takes (acc elem) returns new acc
  over 3 "fold" check-arity  # -> List Env List EvalResult
  dup eval-err? if
    nip nip nip
  else
    drop drop  # -> List Env
    swap scdr  # -> Env Args (skip 'fold')
    dup scar 2 pick eval-with-env  # Eval fn -> Env Args EvalResult
    dup eval-err? if
      nip nip nip  # Error - propagate
    else
      eval-ok-value  # -> Env Args FnVal
      dup sclosure? if
        sclosure-val  # -> Env Args Closure (unwrap from Sexpr)
        swap scdr  # -> Env Closure RestArgs
        dup scar 2 pick eval-with-env  # Eval init -> Env Closure RestArgs EvalResult
        dup eval-err? if
          nip nip nip nip  # Error - propagate
        else
          eval-ok-value  # -> Env Closure RestArgs InitVal
          swap scdr scar 3 pick eval-with-env  # Eval list -> Env Closure InitVal EvalResult
          dup eval-err? if
            nip nip nip nip  # Error - propagate
          else
            eval-ok-value  # -> Env Closure InitVal ListVal
            dup slist? if
              slist-val  # -> Env Closure Acc InputList
              fold-loop
            else
              drop drop drop drop "fold: third argument must be a list" eval-err
            then
          then
        then
      else
        drop drop drop "fold: first argument must be a function" eval-err
      then
    then
  then
;

: fold-loop ( Env LispClosure Sexpr SexprList -- EvalResult )
  # Stack: Env Closure Acc InputList
  dup snil? if
    # Done - return accumulator
    drop nip nip eval-ok
  else
    # Get current element
    dup scar  # -> Env Closure Acc InputList Elem
    # Build args list (Acc Elem)
    snil scons  # -> Env Closure Acc InputList (Elem)
    # Stack: pos 4:Env 3:Closure 2:Acc 1:InputList 0:(Elem)
    2 pick  # Get Acc
    swap scons  # -> Env Closure Acc InputList (Acc Elem)
    # Stack: pos 4:Env 3:Closure 2:Acc 1:InputList 0:(Acc Elem)
    # Now need: Closure (Acc Elem) Env for apply-closure-2
    # Rearrange to remove old Acc and call apply-closure-2
    3 pick  # Get Closure -> ... (Acc Elem) Closure
    swap    # -> ... Closure (Acc Elem)
    5 pick  # Get Env -> ... Closure (Acc Elem) Env
    apply-closure-2  # -> Env Closure Acc InputList EvalResult
    # Stack: pos 4:Env 3:Closure 2:Acc 1:InputList 0:EvalResult
    dup eval-err? if
      # Error - need to clean up 4 items below result
      nip nip nip nip nip
    else
      eval-ok-value  # -> Env Closure Acc InputList NewAcc
      # Replace old Acc with NewAcc, advance InputList
      # Stack: pos 4:Env 3:Closure 2:Acc 1:InputList 0:NewAcc
      swap scdr  # -> Env Closure Acc NewAcc RestInput
      # Stack: pos 4:Env 3:Closure 2:Acc 1:NewAcc 0:RestInput
      # Need: Env Closure NewAcc RestInput
      rot drop  # Remove old Acc -> Env Closure NewAcc RestInput
      fold-loop
    then
  then
;

# ============================================
# Predicates (null?, number?, symbol?, list?)
# ============================================

: eval-null?-with-env ( SexprList Env -- EvalResult )
  # Stack: List Env
  # (null? expr) - returns #t if expr is empty list, #f otherwise
  over 1 "null?" check-arity  # -> List Env List EvalResult
  dup eval-err? if
    nip nip nip
  else
    drop drop  # -> List Env
    swap scdr scar  # Skip 'null?', get arg -> Env Arg
    swap eval-with-env  # Eval arg -> EvalResult
    dup eval-err? if
      # Error - propagate
    else
      eval-ok-value
      dup slist? if
        slist-val snil? if "#t" else "#f" then
      else
        drop "#f"
      then
      ssym eval-ok
    then
  then
;

: eval-number?-with-env ( SexprList Env -- EvalResult )
  # Stack: List Env
  # (number? expr) - returns #t if expr is a number, #f otherwise
  over 1 "number?" check-arity  # -> List Env List EvalResult
  dup eval-err? if
    nip nip nip
  else
    drop drop  # -> List Env
    swap scdr scar  # Skip 'number?', get arg -> Env Arg
    swap eval-with-env  # Eval arg -> EvalResult
    dup eval-err? if
      # Error - propagate as-is
    else
      eval-ok-value
      snum? if "#t" else "#f" then ssym eval-ok
    then
  then
;

: eval-symbol?-with-env ( SexprList Env -- EvalResult )
  # Stack: List Env
  # (symbol? expr) - returns #t if expr is a symbol, #f otherwise
  over 1 "symbol?" check-arity  # -> List Env List EvalResult
  dup eval-err? if
    nip nip nip
  else
    drop drop  # -> List Env
    swap scdr scar  # Skip 'symbol?', get arg -> Env Arg
    swap eval-with-env  # Eval arg -> EvalResult
    dup eval-err? if
      # Error - propagate as-is
    else
      eval-ok-value
      ssym? if "#t" else "#f" then ssym eval-ok
    then
  then
;

: eval-list?-with-env ( SexprList Env -- EvalResult )
  # Stack: List Env
  # (list? expr) - returns #t if expr is a list, #f otherwise
  over 1 "list?" check-arity  # -> List Env List EvalResult
  dup eval-err? if
    nip nip nip
  else
    drop drop  # -> List Env
    swap scdr scar  # Skip 'list?', get arg -> Env Arg
    swap eval-with-env  # Eval arg -> EvalResult
    dup eval-err? if
      # Error - propagate as-is
    else
      eval-ok-value
      slist? if "#t" else "#f" then ssym eval-ok
    then
  then
;

: eval-boolean?-with-env ( SexprList Env -- EvalResult )
  # Stack: List Env
  # (boolean? expr) - returns #t if expr is #t or #f, #f otherwise
  over 1 "boolean?" check-arity  # -> List Env List EvalResult
  dup eval-err? if
    nip nip nip
  else
    drop drop  # -> List Env
    swap scdr scar  # Skip 'boolean?', get arg -> Env Arg
    swap eval-with-env  # Eval arg -> EvalResult
    dup eval-err? if
      # Error - propagate as-is
    else
      eval-ok-value
      dup ssym? if
        ssym-val dup "#t" string.equal? swap "#f" string.equal? or
        if "#t" else "#f" then
      else
        drop "#f"
      then
      ssym eval-ok
    then
  then
;

# ============================================
# Begin (sequencing)
# ============================================

: eval-begin-with-env ( SexprList Env -- EvalResult )
  # Stack: List Env
  # (begin expr1 expr2 ... exprN) - evaluate all, return last result
  swap scdr  # Skip 'begin' -> Env Exprs
  swap eval-begin-exprs
;

: eval-begin-exprs ( SexprList Env -- EvalResult )
  # Stack: Exprs Env
  # Evaluate expressions in sequence, return last result
  over snil? if
    # No expressions - return empty list
    drop drop snil slist eval-ok
  else
    over scdr snil? if
      # Last expression - evaluate and return
      swap scar swap eval-with-env
    else
      # More expressions - evaluate this one
      over scar over eval-with-env
      dup eval-err? if
        nip nip  # Error - propagate
      else
        dup eval-define? if
          # Define - extend environment with the binding
          dup eval-define-name swap eval-define-value
          # Stack: Exprs Env Name Value
          rot env-extend  # -> Exprs NewEnv
          swap scdr swap eval-begin-exprs
        else
          drop  # Discard EvalOk result
          swap scdr swap eval-begin-exprs
        then
      then
    then
  then
;

# ============================================
# Cond (multi-way conditional)
# ============================================

: eval-cond-with-env ( SexprList Env -- EvalResult )
  # Stack: List Env
  # (cond (test1 expr1) (test2 expr2) ... (else exprN))
  swap scdr  # Skip 'cond' -> Env Clauses
  swap eval-cond-clauses
;

: eval-cond-clauses ( SexprList Env -- EvalResult )
  # Stack: Clauses Env
  # Process clauses until one matches
  over snil? if
    # No more clauses - return empty list
    drop drop snil slist eval-ok
  else
    # Get first clause: (test expr...)
    over scar slist-val  # Clauses Env ClauseList
    dup scar  # Clauses Env ClauseList Test
    # Check for 'else' keyword
    dup ssym? if
      dup ssym-val "else" string.equal? if
        # else clause - evaluate the expression(s)
        drop scdr  # Clauses Env BodyExprs
        rot drop  # Env BodyExprs
        swap eval-cond-body
      else
        # Regular symbol test - evaluate it
        2 pick eval-with-env  # Clauses Env ClauseList EvalResult
        dup eval-err? if
          nip nip nip  # Error - propagate
        else
          eval-ok-value cond-test-true? if
            # Test passed - evaluate clause body
            scdr  # Clauses Env BodyExprs
            rot drop  # Env BodyExprs
            swap eval-cond-body
          else
            # Test failed - try next clause
            # Stack: Clauses Env ClauseList
            drop  # Clauses Env
            swap scdr swap  # RestClauses Env
            eval-cond-clauses
          then
        then
      then
    else
      # Test is not a symbol - evaluate it
      2 pick eval-with-env  # Clauses Env ClauseList EvalResult
      dup eval-err? if
        nip nip nip  # Error - propagate
      else
        eval-ok-value cond-test-true? if
          # Test passed - evaluate clause body
          scdr  # Clauses Env BodyExprs
          rot drop  # Env BodyExprs
          swap eval-cond-body
        else
          # Test failed - try next clause
          # Stack: Clauses Env ClauseList
          drop  # Clauses Env
          swap scdr swap  # RestClauses Env
          eval-cond-clauses
        then
      then
    then
  then
;

: cond-test-true? ( Sexpr -- Int )
  # Returns 1 if test result is truthy, 0 if falsy
  # Falsy: numeric 0 or #f
  dup snum? if
    snum-val 0 = if 0 else 1 then
  else
    dup ssym? if
      ssym-val "#f" string.equal? if 0 else 1 then
    else
      drop 1  # Lists and other values are truthy
    then
  then
;

: eval-cond-body ( SexprList Env -- EvalResult )
  # Stack: BodyExprs Env
  # Evaluate body expressions, return last result (like begin)
  eval-begin-exprs
;

# ============================================
# Conditional (if)
# ============================================

: eval-if-with-env ( SexprList Env -- EvalResult )
  # Stack: List Env
  # List is (if cond then-expr else-expr)
  over 3 "if" check-arity  # -> List Env List EvalResult
  dup eval-err? if
    nip nip nip  # -> EvalResult
  else
    drop drop  # -> List Env
    swap scdr  # Skip the if -> Env Args
    # Args is (cond then-expr else-expr)
    dup scar   # -> Env Args CondExpr
    2 pick     # -> Env Args CondExpr Env
    eval-with-env  # -> Env Args EvalResult
    dup eval-err? if
      nip nip  # -> EvalResult
    else
      eval-ok-value  # -> Env Args CondResult
      # Check if condition is false (numeric 0 or #f)
      dup snum? if
        snum-val 0 = if  # -> Env Args
          # False (0) - eval else branch
          scdr scdr scar swap eval-with-env
        else
          # True (non-zero) - eval then branch
          scdr scar swap eval-with-env
        then
      else
        # Check for #f symbol
        dup ssym? if
          ssym-val "#f" string.equal? if  # -> Env Args
            # False (#f) - eval else branch
            scdr scdr scar swap eval-with-env
          else
            # Other symbol - treat as true
            scdr scar swap eval-with-env
          then
        else
          # Non-numeric, non-symbol (list) - treat as true
          drop  # -> Env Args
          scdr scar swap eval-with-env
        then
      then
    then
  then
;

# ============================================
# Let Binding
# ============================================

: eval-let-with-env ( SexprList Env -- EvalResult )
  # Stack: List Env
  # List is (let name value body)
  over 3 "let" check-arity  # -> List Env List EvalResult
  dup eval-err? if
    nip nip nip
  else
    drop drop  # -> List Env
    swap scdr  # Skip the 'let' -> Env Args
  dup scar ssym-val  # Get binding name -> Env Args Name
  swap scdr  # -> Env Name RestArgs
  dup scar  # -> Env Name RestArgs ValueExpr
  3 pick eval-with-env  # Evaluate value -> Env Name RestArgs EvalResult
  dup eval-err? if
    nip nip nip  # Error - propagate (drop RestArgs, Name, Env)
  else
    eval-ok-value  # Unwrap -> Env Name RestArgs Value
    rot  # -> Env RestArgs Value Name
    swap  # -> Env RestArgs Name Value
    3 pick  # -> Env RestArgs Name Value Env
    env-extend  # -> Env RestArgs NewEnv
    swap scdr scar  # Get body expr -> Env NewEnv BodyExpr
    swap  # -> Env BodyExpr NewEnv
    eval-with-env  # Evaluate body in new env -> Env EvalResult
    nip  # -> EvalResult
  then
  then
;

# ============================================
# Lambda
# ============================================

: eval-lambda-with-env ( SexprList Env -- EvalResult )
  # Stack: List Env
  # List is (lambda (params) body)
  over 2 "lambda" check-arity  # -> List Env List EvalResult
  dup eval-err? if
    nip nip nip  # -> EvalResult
  else
    drop drop  # -> List Env
    swap scdr  # Skip 'lambda' -> Env Args
    # Args is ((params) body)
    dup scar  # -> Env Args Params (Params is Sexpr/SList containing param list)
    # Note: We keep params as Sexpr, not unwrapping with slist-val
    # This matches what apply-closure-val expects
    swap scdr scar  # -> Env Params Body
    rot  # -> Params Body Env
    make-closure  # -> Closure (params stored as Sexpr)
    sclosure      # -> Sexpr (wrapping the closure)
    eval-ok       # -> EvalResult
  then
;

# ============================================
# Closure Application (with Currying)
# ============================================

# Apply closure with automatic currying/partial application
# - Fewer args than params: return partially applied closure
# - Exact args: evaluate body
# - More args than params: apply first batch, chain-apply rest
: apply-closure ( Sexpr SexprList Env -- EvalResult )
  # Stack: ClosureSexpr Args CallerEnv
  # Count args and params
  2 pick sclosure-val closure-params slist-val list-length  # -> ... ParamCount
  2 pick list-length  # -> ... ParamCount ArgCount

  # Compare: ArgCount vs ParamCount
  # Stack is ParamCount ArgCount (ArgCount on top)
  # In Seq, `a b <` checks a < b
  over over = if
    # Exact match: full application
    drop drop apply-full
  else
    # Not equal - check if ArgCount < ParamCount for partial application
    # Stack: ParamCount ArgCount
    # We want to check ArgCount < ParamCount
    # `dup 2 pick <` gives us ArgCount < ParamCount
    dup 2 pick < if
      # ArgCount < ParamCount: partial application
      drop drop apply-partial
    else
      # ArgCount > ParamCount: apply then chain
      drop drop apply-chain
    then
  then
;

# Partial application: bind available args, return new closure
: apply-partial ( Sexpr SexprList Env -- EvalResult )
  # Stack: ClosureSexpr Args CallerEnv (pos 2,1,0)
  # Evaluate all provided args and bind them
  2 pick sclosure-val  # -> ClosureSexpr Args CallerEnv Closure (pos 3,2,1,0)
  dup closure-env 2 pick env-concat  # -> ClosureSexpr Args CallerEnv Closure BaseEnv (pos 4,3,2,1,0)

  # Bind args to first N params (where N = arg count)
  over closure-params slist-val  # -> ... Closure BaseEnv Params (unwrap to SexprList, pos 5,4,3,2,1,0)
  4 pick  # -> ... Params Args (Args is at position 4)
  4 pick  # -> ... Params Args CallerEnv (CallerEnv is now at position 4)
  partial-bind-loop  # -> ... Closure ExtEnv RemainingParams EvalResult

  dup eval-err? if
    # Error during arg eval
    nip nip nip nip nip nip
  else
    drop  # drop success marker
    # Stack: ClosureSexpr Args CallerEnv Closure ExtEnv RemainingParams
    # Create new closure with remaining params, same body, extended env
    rot closure-body  # -> ... ExtEnv RemainingParams Body
    swap              # -> ... ExtEnv Body RemainingParams
    slist             # -> ... ExtEnv Body ParamsSexpr
    swap rot          # -> ... ParamsSexpr Body ExtEnv
    make-closure sclosure eval-ok
    nip nip nip
  then
;

# Helper: rearrange stack after binding for next recursion
# Takes old layout, advances Params/Args, returns new layout
: bind-rearrange ( SexprList SexprList Env Env -- Env SexprList SexprList Env )
  # Input: Params Args EvalEnv NewEnv (3,2,1,0) - 4 items
  # Output: NewEnv NewParams NewArgs EvalEnv (3,2,1,0) - 4 items
  # Step 1: Compute NewParams and NewArgs
  swap rot   # -> Params NewEnv EvalEnv Args (4 items)
  scdr       # -> Params NewEnv EvalEnv NewArgs (4 items)
  3 roll     # -> NewEnv EvalEnv NewArgs Params (moves item at depth 3 to top)
  scdr       # -> NewEnv EvalEnv NewArgs NewParams (4 items)
  # Step 2: Rearrange to final order
  # Current: NewEnv EvalEnv NewArgs NewParams (3,2,1,0)
  # Want: NewEnv NewParams NewArgs EvalEnv (3,2,1,0)
  rot        # -> NewEnv NewArgs NewParams EvalEnv
  rot swap   # -> NewEnv NewParams NewArgs EvalEnv
;

# Helper: bind args to params, return extended env and remaining params
: partial-bind-loop ( Env SexprList SexprList Env -- Env SexprList EvalResult )
  # Stack: AccEnv Params Args EvalEnv
  # Base case: no more args
  over snil? if
    drop drop  # -> AccEnv Params (remove EvalEnv then Args from top)
    0 snum eval-ok  # success marker (dummy value, we only care about Params)
  else
    # Eval first arg
    over scar over eval-with-env  # -> AccEnv Params Args EvalEnv EvalResult
    dup eval-err? if
      # Error - clean up and return
      # Stack: AccEnv Params Args EvalEnv EvalResult (4,3,2,1,0)
      swap drop    # -> AccEnv Params Args EvalResult
      swap drop    # -> AccEnv Params EvalResult
      swap drop    # -> AccEnv EvalResult
      swap snil swap  # -> AccEnv () EvalResult
    else
      eval-ok-value  # -> AccEnv Params Args EvalEnv ArgVal
      # Rearrange to get AccEnv to top for env-extend
      4 roll  # -> Params Args EvalEnv ArgVal AccEnv
      # Get param name from Params
      4 pick scar ssym-val  # -> Params Args EvalEnv ArgVal AccEnv ParamName
      # env-extend: String Sexpr Env -> Env
      rot rot env-extend  # -> Params Args EvalEnv NewEnv
      # Use helper to rearrange and advance for recursion
      bind-rearrange
      partial-bind-loop
    then
  then
;

# Full application: bind all args, evaluate body
: apply-full ( Sexpr SexprList Env -- EvalResult )
  # Stack: ClosureSexpr Args CallerEnv (pos 2,1,0)
  2 pick sclosure-val  # -> ClosureSexpr Args CallerEnv Closure (pos 3,2,1,0)
  dup closure-env 2 pick env-concat  # -> ClosureSexpr Args CallerEnv Closure BaseEnv (pos 4,3,2,1,0)
  over closure-params slist-val  # -> ClosureSexpr Args CallerEnv Closure BaseEnv Params (unwrap to SexprList, pos 5,4,3,2,1,0)
  4 pick  # -> ... Params Args (Args is at position 4)
  4 pick  # -> ... Params Args CallerEnv (CallerEnv is now at position 4)
  full-bind-loop  # -> ... Closure ExtEnv EvalResult

  dup eval-err? if
    nip nip nip nip nip
  else
    drop  # drop success marker
    # Stack: ClosureSexpr Args CallerEnv Closure ExtEnv
    swap closure-body swap eval-with-env
    nip nip nip
  then
;

# Helper: bind all args to all params
: full-bind-loop ( Env SexprList SexprList Env -- Env EvalResult )
  # Stack: AccEnv Params Args EvalEnv
  # Base case: no more params (and args)
  2 pick snil? if
    drop drop drop  # -> AccEnv
    snil slist eval-ok  # success marker
  else
    # Eval first arg
    over scar over eval-with-env  # -> AccEnv Params Args EvalEnv EvalResult
    dup eval-err? if
      # Error - clean up and return
      # Stack: AccEnv Params Args EvalEnv EvalResult
      nip nip nip  # -> AccEnv EvalResult
    else
      eval-ok-value  # -> AccEnv Params Args EvalEnv ArgVal
      # Rearrange to get AccEnv to top for env-extend
      4 roll  # -> Params Args EvalEnv ArgVal AccEnv
      # Get param name from Params
      4 pick scar ssym-val  # -> Params Args EvalEnv ArgVal AccEnv ParamName
      # env-extend: String Sexpr Env -> Env
      rot rot env-extend  # -> Params Args EvalEnv NewEnv
      # Use helper to rearrange and advance for recursion
      bind-rearrange
      full-bind-loop
    then
  then
;

# Over-application: apply with available params, chain-apply rest
: apply-chain ( Sexpr SexprList Env -- EvalResult )
  # Stack: ClosureSexpr Args CallerEnv
  # Get param count to know how many args to consume
  2 pick sclosure-val closure-params slist-val list-length  # -> ... ParamCount

  # Split args into first batch (for this call) and rest (for chaining)
  2 pick swap split-list  # -> ClosureSexpr Args CallerEnv FirstArgs RestArgs

  # Apply closure to first batch
  # Stack: ClosureSexpr Args CallerEnv FirstArgs RestArgs (4,3,2,1,0)
  swap             # -> ClosureSexpr Args CallerEnv RestArgs FirstArgs
  4 pick           # -> ... FirstArgs ClosureSexpr (copy closure)
  swap             # -> ... ClosureSexpr FirstArgs
  3 pick           # -> ... ClosureSexpr FirstArgs CallerEnv (copy env)
  apply-full       # -> ClosureSexpr Args CallerEnv RestArgs EvalResult

  dup eval-err? if
    # Error - clean up and return
    nip nip nip nip  # -> EvalResult
  else
    # Got a result - verify it's a closure before trying to apply more args
    eval-ok-value  # -> ClosureSexpr Args CallerEnv RestArgs ResultValue
    dup sclosure? if
      # It's a closure - apply rest args to it
      swap rot       # -> ... ResultClosure RestArgs CallerEnv
      apply-closure  # -> ClosureSexpr Args EvalResult
      nip nip        # -> EvalResult
    else
      # Not a closure - can't apply more arguments
      drop drop drop drop drop "over-application: result is not a function" eval-err
    then
  then
;

# Split a list: take first N elements, return (first-n, rest)
: split-list ( SexprList Int -- SexprList SexprList )
  # Stack: List Count
  snil rot rot  # -> snil List Count (Acc Rest Count for loop)
  split-list-loop
  swap list-reverse swap  # reverse accumulated first part
;

: split-list-loop ( SexprList SexprList Int -- SexprList SexprList )
  # Stack: Acc Rest Count (2,1,0)
  dup 0 = if
    drop  # -> Acc Rest
  else
    # Count > 0: take one element from Rest, add to Acc, decrement Count
    1 subtract         # -> Acc Rest NewCount
    swap               # -> Acc NewCount Rest
    dup scar           # -> Acc NewCount Rest FirstElem
    swap scdr          # -> Acc NewCount FirstElem RestTail
    # Rearrange and cons FirstElem onto Acc
    rot                # -> Acc FirstElem RestTail NewCount
    3 roll             # -> FirstElem RestTail NewCount Acc
    rot                # -> FirstElem NewCount Acc RestTail
    3 roll             # -> NewCount Acc RestTail FirstElem
    3 roll             # -> Acc RestTail FirstElem NewCount
    rot                # -> Acc FirstElem NewCount RestTail
    rot                # -> Acc NewCount RestTail FirstElem
    3 roll             # -> NewCount RestTail FirstElem Acc
    scons              # -> NewCount RestTail NewAcc
    rot rot swap       # -> NewAcc RestTail NewCount
    split-list-loop
  then
;

# Note: list-reverse is already defined in parser.seq

# Single-parameter closure application for map/filter
# Does NOT evaluate the argument - it's already a value
: apply-closure-val ( LispClosure Sexpr Env -- EvalResult )
  # Stack: Closure ArgVal CallerEnv
  # ArgVal is already evaluated, just bind and run
  # Get closure components
  2 pick closure-params slist-val scar ssym-val  # -> Closure ArgVal CallerEnv ParamName
  rot  # -> Closure CallerEnv ParamName ArgVal
  3 pick closure-env  # -> Closure CallerEnv ParamName ArgVal ClosureEnv
  3 pick env-concat  # -> Closure CallerEnv ParamName ArgVal MergedEnv
  env-extend  # -> Closure CallerEnv ExtendedEnv
  # Evaluate body
  rot closure-body  # -> CallerEnv ExtendedEnv Body
  swap eval-with-env  # -> CallerEnv EvalResult
  nip  # -> EvalResult
;

# Two-parameter closure application (for fold)
# Simple approach: build env first, then evaluate
: apply-closure-2 ( LispClosure SexprList Env -- EvalResult )
  # Input stack: Closure Args CallerEnv (pos: 2 1 0)
  # Args is (Arg1 Arg2) where Arg1=acc, Arg2=elem for fold

  # Build extended environment: bind both params then eval body
  # Strategy: start with closure's env merged with caller env,
  # then extend with param1=arg1, then param2=arg2

  # Get closure's captured env and merge with caller
  2 pick closure-env     # -> Closure Args CallerEnv ClosureEnv
  over env-concat        # -> Closure Args CallerEnv BaseEnv

  # Now bind param1 (first param gets first arg)
  # env-extend signature: ( String Sexpr Env -- Env )
  3 pick closure-params slist-val scar ssym-val  # -> ... BaseEnv Param1Name
  3 pick scar                          # -> ... BaseEnv Param1Name Arg1
  rot env-extend                       # -> Closure Args CallerEnv Env1

  # Now bind param2 (second param gets second arg)
  3 pick closure-params slist-val scdr scar ssym-val  # -> ... Env1 Param2Name
  3 pick scdr scar                          # -> ... Env1 Param2Name Arg2
  rot env-extend                            # -> Closure Args CallerEnv Env2

  # Evaluate body in extended environment
  3 pick closure-body                  # -> Closure Args CallerEnv Env2 Body
  swap eval-with-env                   # -> Closure Args CallerEnv EvalResult
  nip nip nip                          # -> EvalResult
;

# ============================================
# REPL Helper
# ============================================

: eval-print ( String -- )
  parse env-empty eval-with-env
  dup eval-err? if
    "Error: " swap eval-err-message string.concat io.write-line
  else
    eval-ok-value sexpr-to-string io.write-line
  then ;
