# Evaluator for SeqLisp
#
# Currently supports:
# - Numbers: return as-is
# - Symbols: lookup in environment
# - Arithmetic: +, -, *, /
# - Comparisons: <, >, <=, >=, =
# - let: local binding
# - if: conditional
# - lambda: anonymous functions
# - define: global definitions
# - print: output

include "parser"

# ============================================
# Environment Types
#
# Env is a list of bindings (name -> value pairs)
# ============================================

union Binding {
  Bind { name: String, value: Sexpr }
}

union Env {
  EnvEmpty
  EnvExtend { binding: Binding, parent: Env }
}

# ============================================
# Closure Type
#
# Closures capture params, body, and environment
# ============================================

union LispClosure {
  Closure { params: Sexpr, body: Sexpr, captured_env: Env }
}

# ============================================
# Define Result Type
#
# Define result: tag 70, fields: (Name, Value)
# This uses a manual variant with a unique tag to distinguish
# from Sexpr results (which use tags 0, 1, 2)
# ============================================

# ============================================
# Binding Constructors and Accessors
# ============================================

: make-binding ( String Sexpr -- Binding )
  Make-Bind ;

: binding-name ( Binding -- String )
  0 variant-field-at ;

: binding-value ( Binding -- Sexpr )
  1 variant-field-at ;

# ============================================
# Environment Constructors and Accessors
# ============================================

: env-empty ( -- Env )
  Make-EnvEmpty ;

: env-extend ( String Sexpr Env -- Env )
  # Stack: Name Value Env
  rot rot make-binding swap Make-EnvExtend ;

: env-lookup ( String Env -- Sexpr )
  # Stack: Name Env
  # Returns the value or snil if not found
  dup variant-tag 0 = if
    # EnvEmpty - not found
    drop drop 0 snum
  else
    # EnvExtend - extract binding and parent
    dup 0 variant-field-at  # Name Env Binding
    dup binding-name        # Name Env Binding BindingName
    3 pick string-equal if
      # Found it
      binding-value         # Name Env Value
      nip nip               # Value
    else
      # Keep looking
      drop                  # Name Env
      1 variant-field-at    # Name Parent
      env-lookup
    then
  then ;

# Concatenate two environments (Env1 bindings prepended to Env2)
: env-concat ( Env Env -- Env )
  # Stack: Env1 Env2 -> Result where Env1 bindings come first
  swap  # Env2 Env1
  dup variant-tag 0 = if
    # EnvEmpty - just return Env2
    drop
  else
    # EnvExtend - extract binding and parent
    dup 0 variant-field-at  # Env2 Env1 Binding
    swap 1 variant-field-at # Env2 Binding Parent
    rot                     # Binding Parent Env2
    env-concat              # Binding ConcatResult
    Make-EnvExtend          # Result
  then ;

# ============================================
# Closure Constructors and Accessors
# ============================================

: make-closure ( Sexpr Sexpr Env -- LispClosure )
  Make-Closure ;

: closure? ( LispClosure -- Int )
  variant-tag 0 = ;

: closure-params ( LispClosure -- Sexpr )
  0 variant-field-at ;

: closure-body ( LispClosure -- Sexpr )
  1 variant-field-at ;

: closure-env ( LispClosure -- Env )
  2 variant-field-at ;

# ============================================
# Define Result Constructors and Accessors
# ============================================

: make-define-result ( String Sexpr -- Variant )
  70 make-variant-2 ;

: define-result? ( Variant -- Int )
  variant-tag 70 = ;

: define-result-name ( Variant -- String )
  0 variant-field-at ;

: define-result-value ( Variant -- Sexpr )
  1 variant-field-at ;

# ============================================
# Main Evaluator
# ============================================

# Simple eval without environment (for backward compatibility)
: eval ( Sexpr -- Sexpr )
  env-empty eval-with-env ;

# Eval with explicit environment
: eval-with-env ( Sexpr Env -- Sexpr )
  # Stack: Expr Env
  over variant-tag
  dup 0 = if
    # SNum - return as-is
    drop drop
  else
    dup 1 = if
      # SSym - lookup in environment
      drop swap ssym-val swap env-lookup
    else
      2 = if
        # SList - function application
        eval-list-with-env
      else
        # Unknown - return as-is
        drop drop
      then
    then
  then
;

# ============================================
# List Evaluation (Function Application)
# ============================================

: eval-list-with-env ( Sexpr Env -- Sexpr )
  # Stack: Expr Env
  swap slist-val
  dup snil? if
    # Empty list - return empty list
    nip slist
  else
    # Non-empty list: first element is function
    dup scar
    dup ssym? if
      # Symbol - check for built-in functions
      # Stack: Env List Head
      ssym-val swap rot eval-builtin-with-env
    else
      dup slist? if
        # List in function position - evaluate it (likely a lambda)
        # Stack: Env List Head
        2 pick eval-with-env  # -> Env List EvaledHead
        dup closure? if
          # It's a closure - apply it
          # Stack: Env List EvaledHead
          rot rot  # -> EvaledHead Env List
          scdr     # -> EvaledHead Env Args
          swap     # -> EvaledHead Args Env
          apply-closure
        else
          # Not a closure - error
          drop drop slist
        then
      else
        # Non-symbol, non-list in function position
        drop slist nip
      then
    then
  then
;

# ============================================
# Built-in Function Dispatch
# ============================================

: eval-builtin-with-env ( String SexprList Env -- Sexpr )
  # Stack: FuncName List Env
  rot
  dup "+" string-equal if
    drop eval-add-with-env
  else
    dup "-" string-equal if
      drop eval-sub-with-env
    else
      dup "*" string-equal if
        drop eval-mul-with-env
      else
        dup "/" string-equal if
          drop eval-div-with-env
        else
          dup "<" string-equal if
            drop eval-lt-with-env
          else
            dup ">" string-equal if
              drop eval-gt-with-env
            else
              dup "<=" string-equal if
                drop eval-lte-with-env
              else
                dup ">=" string-equal if
                  drop eval-gte-with-env
                else
                  dup "=" string-equal if
                    drop eval-eq-with-env
                  else
                    dup "if" string-equal if
                    drop eval-if-with-env
                  else
                    dup "let" string-equal if
                      drop eval-let-with-env
                    else
                      dup "lambda" string-equal if
                        drop eval-lambda-with-env
                      else
                        dup "print" string-equal if
                          drop eval-print-with-env
                        else
                          dup "define" string-equal if
                            drop eval-define-with-env
                          else
                            # Unknown function - look up in environment
                            # Stack: List Env FuncName
                            over  # List Env FuncName Env
                            env-lookup  # List Env Value
                            dup closure? if
                              # Apply the closure
                              # Stack: List Env Closure
                              rot  # Env Closure List
                              scdr  # Env Closure Args (skip function name)
                              rot  # Closure Args Env
                              apply-closure
                            else
                              # Not a closure, return as list
                              drop drop slist
                            then
                          then
                        then
                      then
                    then
                  then
                then
              then
            then
          then
        then
      then
    then
  then
then
;

# ============================================
# Arithmetic Operations
# ============================================

: eval-add-with-env ( SexprList Env -- Sexpr )
  # Stack: List Env
  swap scdr swap  # Skip the + -> RestList Env
  0 swap eval-fold-add-with-env snum
;

: eval-fold-add-with-env ( SexprList Int Env -- Int )
  # Stack: List Acc Env
  2 pick snil? if
    # List is empty, return Acc
    drop nip
  else
    # Get first element and eval it
    2 pick scar over eval-with-env snum-val
    # Stack: List Acc Env FirstVal
    rot add
    # Stack: List Env NewAcc
    swap rot scdr rot rot
    # Stack: RestList NewAcc Env
    eval-fold-add-with-env
  then
;

: eval-sub-with-env ( SexprList Env -- Sexpr )
  # Stack: List Env
  swap scdr
  dup snil? if
    drop drop 0 snum
  else
    dup scar 2 pick eval-with-env snum-val
    swap scdr
    dup snil? if
      # Unary minus: negate
      drop nip 0 swap subtract snum
    else
      # Binary minus: first - rest
      # Stack: Env FirstVal RestList -> need RestList FirstVal Env
      rot rot swap eval-fold-sub-with-env snum
    then
  then
;

: eval-fold-sub-with-env ( SexprList Int Env -- Int )
  # Stack: List Acc Env
  2 pick snil? if
    # List is empty, return Acc
    drop nip
  else
    # Get first element and eval it
    2 pick scar over eval-with-env snum-val
    # Stack: List Acc Env FirstVal
    rot swap subtract
    # Stack: List Env NewAcc
    swap rot scdr rot rot
    # Stack: RestList NewAcc Env
    eval-fold-sub-with-env
  then
;

: eval-mul-with-env ( SexprList Env -- Sexpr )
  # Stack: List Env
  swap scdr swap  # Skip the * -> RestList Env
  1 swap eval-fold-mul-with-env snum
;

: eval-fold-mul-with-env ( SexprList Int Env -- Int )
  # Stack: List Acc Env
  2 pick snil? if
    # List is empty, return Acc
    drop nip
  else
    # Get first element and eval it
    2 pick scar over eval-with-env snum-val
    # Stack: List Acc Env FirstVal
    rot multiply
    # Stack: List Env NewAcc
    swap rot scdr rot rot
    # Stack: RestList NewAcc Env
    eval-fold-mul-with-env
  then
;

: eval-div-with-env ( SexprList Env -- Sexpr )
  # Stack: List Env
  swap scdr
  dup snil? if
    drop drop 0 snum
  else
    dup scar 2 pick eval-with-env snum-val
    swap scdr
    dup snil? if
      drop nip snum
    else
      # Stack: Env FirstVal RestList -> need RestList FirstVal Env
      rot rot swap eval-fold-div-with-env snum
    then
  then
;

: eval-fold-div-with-env ( SexprList Int Env -- Int )
  # Stack: List Acc Env
  2 pick snil? if
    # List is empty, return Acc
    drop nip
  else
    # Get first element and eval it
    2 pick scar over eval-with-env snum-val
    # Stack: List Acc Env FirstVal
    rot swap divide
    # Stack: List Env NewAcc
    swap rot scdr rot rot
    # Stack: RestList NewAcc Env
    eval-fold-div-with-env
  then
;

# ============================================
# Comparison Operations
# ============================================

: eval-lt-with-env ( SexprList Env -- Sexpr )
  # Stack: List Env
  # (< a b) returns 1 if a < b, else 0
  swap scdr  # Skip the < -> Env Args
  dup scar 2 pick eval-with-env snum-val  # Eval first arg
  swap scdr scar 2 pick eval-with-env snum-val  # Eval second arg
  # Stack: Env First Second
  < if 1 else 0 then snum nip
;

: eval-gt-with-env ( SexprList Env -- Sexpr )
  swap scdr
  dup scar 2 pick eval-with-env snum-val
  swap scdr scar 2 pick eval-with-env snum-val
  > if 1 else 0 then snum nip
;

: eval-lte-with-env ( SexprList Env -- Sexpr )
  swap scdr
  dup scar 2 pick eval-with-env snum-val
  swap scdr scar 2 pick eval-with-env snum-val
  <= if 1 else 0 then snum nip
;

: eval-gte-with-env ( SexprList Env -- Sexpr )
  swap scdr
  dup scar 2 pick eval-with-env snum-val
  swap scdr scar 2 pick eval-with-env snum-val
  >= if 1 else 0 then snum nip
;

: eval-eq-with-env ( SexprList Env -- Sexpr )
  swap scdr
  dup scar 2 pick eval-with-env snum-val
  swap scdr scar 2 pick eval-with-env snum-val
  = if 1 else 0 then snum nip
;

# ============================================
# Print
# ============================================

: eval-print-with-env ( SexprList Env -- Sexpr )
  # Stack: List Env
  # (print expr) - evaluate expr, print result, return result
  swap scdr scar  # Get the expression to print
  swap eval-with-env  # Evaluate it
  dup sexpr-to-string write_line  # Print it
  # Return the value
;

# ============================================
# Define (returns a special result for REPL)
# ============================================

: eval-define-with-env ( SexprList Env -- DefineResult )
  # Stack: List Env
  # (define name value) - evaluate value, return special result
  swap scdr  # Skip 'define' -> Env Args
  dup scar ssym-val  # Get name string -> Env Args Name
  swap scdr scar  # Get value expr -> Env Name ValueExpr
  rot  # -> Name ValueExpr Env
  eval-with-env  # Evaluate value -> Name Value
  make-define-result  # Return (Name, Value) tagged result
;

# ============================================
# Conditional (if)
# ============================================

: eval-if-with-env ( SexprList Env -- Sexpr )
  # Stack: List Env
  # List is (if cond then-expr else-expr)
  swap scdr  # Skip the if -> Env Args
  # Args is (cond then-expr else-expr)
  dup scar   # -> Env Args CondExpr
  2 pick     # -> Env Args CondExpr Env
  eval-with-env  # -> Env Args CondResult
  # Check if condition is numeric 0 (false)
  dup snum? if
    snum-val 0 = if
      # False (0) - eval else branch
      # Stack: Env Args
      scdr scdr scar swap eval-with-env
    else
      # True (non-zero) - eval then branch
      # Stack: Env Args
      scdr scar swap eval-with-env
    then
  else
    # Non-numeric condition - treat as true
    drop  # Drop CondResult -> Env Args
    scdr scar swap eval-with-env
  then
;

# ============================================
# Let Binding
# ============================================

: eval-let-with-env ( SexprList Env -- Sexpr )
  # Stack: List Env
  # List is (let name value body)
  swap scdr  # Skip the 'let' -> Env Args
  dup scar ssym-val  # Get binding name -> Env Args Name
  swap scdr  # -> Env Name RestArgs
  dup scar  # -> Env Name RestArgs ValueExpr
  3 pick eval-with-env  # Evaluate value -> Env Name RestArgs Value
  rot  # -> Env RestArgs Value Name
  swap  # -> Env RestArgs Name Value
  3 pick  # -> Env RestArgs Name Value Env
  env-extend  # -> Env RestArgs NewEnv
  swap scdr scar  # Get body expr -> Env NewEnv BodyExpr
  swap  # -> Env BodyExpr NewEnv
  eval-with-env  # Evaluate body in new env -> Env Result
  nip  # -> Result
;

# ============================================
# Lambda
# ============================================

: eval-lambda-with-env ( SexprList Env -- LispClosure )
  # Stack: List Env
  # List is (lambda (params) body)
  swap scdr  # Skip 'lambda' -> Env Args
  # Args is ((params) body)
  dup scar slist-val  # Get params list -> Env Args Params
  swap scdr scar  # Get body -> Env Params Body
  rot  # -> Params Body Env
  make-closure  # -> Closure
;

# ============================================
# Closure Application
# ============================================

: apply-closure ( LispClosure SexprList Env -- Sexpr )
  # Stack: Closure Args CallerEnv
  # For simplicity, support single-parameter lambdas
  # 1. Evaluate the single argument
  # 2. Bind param to value in merged env (closure + caller for recursion)
  # 3. Evaluate body in extended env
  over scar  # -> Closure Args CallerEnv ArgExpr
  over eval-with-env  # -> Closure Args CallerEnv ArgVal
  # Now get closure components
  3 pick closure-params scar ssym-val  # -> Closure Args CallerEnv ArgVal ParamName
  swap  # -> Closure Args CallerEnv ParamName ArgVal
  4 pick closure-env  # -> Closure Args CallerEnv ParamName ArgVal ClosureEnv
  3 pick env-concat  # -> Closure Args CallerEnv ParamName ArgVal MergedEnv
  env-extend  # -> Closure Args CallerEnv ExtendedEnv
  # Evaluate body
  3 pick closure-body  # -> Closure Args CallerEnv ExtendedEnv Body
  swap eval-with-env  # -> Closure Args CallerEnv Result
  nip nip nip  # -> Result
;

# ============================================
# REPL Helper
# ============================================

: eval-print ( String -- )
  parse eval sexpr-to-string write_line ;
