# Parser for SeqLisp
#
# Converts token list to s-expressions
# Uses ADT for parse result

include "sexpr"
include "tokenizer"

# ============================================
# Parse Result Type
# ============================================

union ParseResult {
  PResult { expr: Sexpr, remaining: TokenList }
}

# ============================================
# Parse Result Constructors and Accessors
# ============================================

: make-parse-result ( Sexpr TokenList -- ParseResult )
  Make-PResult ;

: result-expr ( ParseResult -- Sexpr )
  0 variant.field-at ;

: result-tokens ( ParseResult -- TokenList )
  1 variant.field-at ;

# ============================================
# Span Helpers
# ============================================

# Combine two spans: take start from first, end from second
: span-combine ( SourceSpan SourceSpan -- SourceSpan )
  # Stack: span1 span2
  over span? over span? and if
    # Both have spans - combine them
    over span-start-line   # span1 span2 start-line
    2 pick span-start-col  # span1 span2 start-line start-col
    2 pick span-end-line   # span1 span2 start-line start-col end-line
    3 pick span-end-col    # span1 span2 start-line start-col end-line end-col
    make-span              # span1 span2 combined-span
    nip nip                # combined-span
  else
    # At least one has no span - prefer one that does, or return no-span
    dup span? if
      nip  # return span2
    else
      drop  # return span1
    then
  then
;

# ============================================
# Token Predicates
# ============================================

: is-lparen ( String -- Int )
  "(" string.equal? ;

: is-rparen ( String -- Int )
  ")" string.equal? ;

: is-quote ( String -- Int )
  "'" string.equal? ;

: is-quasiquote ( String -- Int )
  "`" string.equal? ;

: is-unquote ( String -- Int )
  "," string.equal? ;

: is-unquote-splice ( String -- Int )
  ",@" string.equal? ;

: is-digit ( Int -- Int )
  dup 48 >= swap 57 <= and ;

# Check if token is a string literal (starts with double quote)
: is-string-token ( String -- Int )
  dup string.length 0 = if
    drop 0
  else
    0 string.char-at 34 =  # char 34 is double quote
  then
;

# Check if char is a decimal point
: is-dot ( Int -- Int )
  46 = ;  # char 46 is '.'

# Check if token contains a decimal point (for float detection)
: has-decimal-point ( String -- Int )
  0 has-decimal-loop ;

: has-decimal-loop ( String Int -- Int )
  # Stack: str pos
  over string.length over <= if
    drop drop 0  # Reached end, no decimal found
  else
    2dup string.char-at is-dot if
      drop drop 1  # Found decimal
    else
      1 add has-decimal-loop  # Check next char
    then
  then
;

# Check if token is a float (number with decimal point)
: is-float-token ( String -- Int )
  dup is-number-start? if
    has-decimal-point
  else
    drop 0
  then
;

# Check if token starts like a number (digit or minus-digit)
: is-number-start? ( String -- Int )
  dup string.length 0 = if
    drop 0
  else
    dup 0 string.char-at
    dup 45 = if
      # Starts with minus - check if length > 1 and second char is digit
      drop dup string.length 1 > if
        1 string.char-at is-digit
      else
        drop 0
      then
    else
      is-digit nip
    then
  then
;

: is-number-token ( String -- Int )
  # Check if first char is a digit or minus followed by digit
  # and does NOT contain a decimal point (integers only)
  dup is-number-start? if
    has-decimal-point 0 =  # True if no decimal point
  else
    drop 0
  then
;

# ============================================
# Main Parser
# ============================================

: parse ( String -- Sexpr )
  tokenize parse-tokens result-expr ;

# Get token text from first token in list
: tcar-text ( TokenList -- String )
  tcar tok-text ;

# Get first token (for accessing both text and span)
: tcar-token ( TokenList -- Token )
  tcar ;

: parse-tokens ( TokenList -- ParseResult )
  # TokenList is a token list, returns parse result
  dup tnil? if
    # Empty token list - return nil expression
    snil slist swap make-parse-result
  else
    # Get first token for both text and span
    dup tcar-token        # tokens token
    dup tok-text          # tokens token text
    dup is-lparen if
      # Start of list - parse list contents, passing opening paren span
      drop                # tokens token
      tok-span            # tokens lparen-span
      swap tcdr           # lparen-span rest-tokens
      parse-list-with-span
    else
      dup is-rparen if
        # Unexpected ) - error, just skip
        drop drop tcdr parse-tokens
      else
        dup is-quote if
          # Quote: 'expr -> (quote expr)
          drop tok-span swap tcdr parse-quote-with-span
        else
          dup is-quasiquote if
            # Quasiquote: `expr -> (quasiquote expr)
            drop tok-span swap tcdr parse-quasiquote-with-span
          else
            dup is-unquote-splice if
              # Unquote-splice: ,@expr -> (unquote-splicing expr)
              drop tok-span swap tcdr parse-unquote-splice-with-span
            else
              dup is-unquote if
                # Unquote: ,expr -> (unquote expr)
                drop tok-span swap tcdr parse-unquote-with-span
              else
                # Atom (string, float, number, or symbol)
                # Stack: tokens token text
                over tok-span  # tokens token text span
                swap           # tokens token span text
                # Stack: tokens token span text
                dup is-string-token if
                  # String literal - strip quotes and create SString
                  # Stack: tokens token span text
                  dup string.length 2 subtract    # tokens token span text len
                  over                            # tokens token span text len text
                  1 rot                           # tokens token span text text 1 len
                  string.substring                # tokens token span text content
                  nip                             # tokens token span content
                  swap sstring-at                 # tokens token sexpr
                  nip swap tcdr make-parse-result
                else
                  dup is-float-token if
                    # Stack: tokens token span text
                    string->float drop            # tokens token span float-val
                    swap sfloat-at                # tokens token sexpr
                    nip swap tcdr make-parse-result
                  else
                    dup is-number-token if
                      # Stack: tokens token span text
                      string->int drop            # tokens token span int-val
                      swap snum-at                # tokens token sexpr
                      nip swap tcdr make-parse-result
                    else
                      # Symbol
                      # Stack: tokens token span text
                      swap ssym-at                # tokens token sexpr
                      nip swap tcdr make-parse-result
                    then
                  then
                then
              then
            then
          then
        then
      then
    then
  then
;

# Parse quote: expand 'expr to (quote expr)
: parse-quote ( TokenList -- ParseResult )
  no-span swap parse-quote-with-span ;

# Parse quote with span: expand 'expr to (quote expr)
: parse-quote-with-span ( SourceSpan TokenList -- ParseResult )
  # Stack: quote-span tokens
  parse-tokens
  # Stack: quote-span ParseResult
  dup result-expr       # quote-span result expr
  dup sexpr-span        # quote-span result expr expr-span
  3 pick swap           # quote-span result expr quote-span expr-span
  span-combine          # quote-span result expr combined-span
  # Build (quote expr) with combined span
  swap snil scons       # quote-span result combined-span (expr)
  "quote" ssym swap scons  # quote-span result combined-span (quote expr)
  swap slist-at         # quote-span result quoted-sexpr
  swap result-tokens    # quote-span quoted-sexpr tokens
  make-parse-result nip
;

# Parse quasiquote: expand `expr to (quasiquote expr)
: parse-quasiquote ( TokenList -- ParseResult )
  no-span swap parse-quasiquote-with-span ;

: parse-quasiquote-with-span ( SourceSpan TokenList -- ParseResult )
  parse-tokens
  dup result-expr
  dup sexpr-span
  3 pick swap span-combine
  swap snil scons
  "quasiquote" ssym swap scons
  swap slist-at
  swap result-tokens
  make-parse-result nip
;

# Parse unquote: expand ,expr to (unquote expr)
: parse-unquote ( TokenList -- ParseResult )
  no-span swap parse-unquote-with-span ;

: parse-unquote-with-span ( SourceSpan TokenList -- ParseResult )
  parse-tokens
  dup result-expr
  dup sexpr-span
  3 pick swap span-combine
  swap snil scons
  "unquote" ssym swap scons
  swap slist-at
  swap result-tokens
  make-parse-result nip
;

# Parse unquote-splice: expand ,@expr to (unquote-splicing expr)
: parse-unquote-splice ( TokenList -- ParseResult )
  no-span swap parse-unquote-splice-with-span ;

: parse-unquote-splice-with-span ( SourceSpan TokenList -- ParseResult )
  parse-tokens
  dup result-expr
  dup sexpr-span
  3 pick swap span-combine
  swap snil scons
  "unquote-splicing" ssym swap scons
  swap slist-at
  swap result-tokens
  make-parse-result nip
;

# Parse list contents until )
: parse-list ( TokenList -- ParseResult )
  # Input: token list after opening paren
  # Returns: (SList of elements, tokens after closing paren)
  no-span swap parse-list-with-span
;

# Parse list with lparen span
: parse-list-with-span ( SourceSpan TokenList -- ParseResult )
  # Stack: lparen-span tokens
  snil rot  # tokens snil lparen-span
  rot       # snil lparen-span tokens
  parse-list-items-with-span
;

: parse-list-items ( SexprList TokenList -- ParseResult )
  no-span rot rot parse-list-items-with-span ;

: parse-list-items-with-span ( SexprList SourceSpan TokenList -- ParseResult )
  # Stack: Acc LparenSpan Tokens (Tokens on top)
  dup tnil? if
    # Ran out of tokens - return accumulated list with empty token list
    drop swap list-reverse swap slist-at tnil make-parse-result
  else
    dup tcar-token        # Acc LparenSpan Tokens Token
    dup tok-text is-rparen if
      # End of list - combine lparen span with rparen span
      tok-span            # Acc LparenSpan Tokens RparenSpan
      rot                 # Acc Tokens RparenSpan LparenSpan
      swap span-combine   # Acc Tokens CombinedSpan
      rot list-reverse    # Tokens CombinedSpan ReversedList
      swap slist-at       # Tokens Sexpr
      swap tcdr           # Sexpr RemainingTokens
      make-parse-result
    else
      # Parse next element from Tokens
      # Stack: Acc LparenSpan Tokens Token
      drop                      # Acc LparenSpan Tokens
      parse-tokens              # Acc LparenSpan ParseResult
      dup result-tokens         # Acc LparenSpan ParseResult RemTokens
      swap result-expr          # Acc LparenSpan RemTokens Expr
      # Add Expr to Acc (at bottom of stack)
      # Stack: Acc LparenSpan RemTokens Expr (indices 3 2 1 0)
      3 pick scons              # Acc LparenSpan RemTokens NewAcc
      # Stack: Acc LparenSpan RemTokens NewAcc (indices 3 2 1 0)
      # Drop old Acc (index 3) and rearrange to: NewAcc LparenSpan RemTokens
      3 roll drop               # LparenSpan RemTokens NewAcc
      rot                       # RemTokens NewAcc LparenSpan
      rot                       # NewAcc LparenSpan RemTokens
      parse-list-items-with-span
    then
  then
;

# Reverse a cons list
: list-reverse ( SexprList -- SexprList )
  snil list-reverse-loop ;

: list-reverse-loop ( SexprList SexprList -- SexprList )
  swap dup snil? if drop else
    dup scar rot scons swap scdr swap list-reverse-loop
  then
;

# ============================================
# Debug
# ============================================

: print-parse ( String -- )
  parse sexpr-to-string io.write-line ;
