# Parser for SeqLisp
#
# Converts token list to s-expressions
# Uses a state variant to track remaining tokens

include "sexpr"
include "tokenizer"

# ============================================
# Parser State: (Tokens)
# Stored as a 1-field variant
# ============================================

: make-pstate ( Variant -- Variant )
  200 make-variant-1 ;

: pstate-tokens ( Variant -- Variant )
  0 variant-field-at ;

# ============================================
# Token Predicates
# ============================================

: is-lparen ( String -- Int )
  "(" string-equal ;

: is-rparen ( String -- Int )
  ")" string-equal ;

: is-digit ( Int -- Int )
  dup 48 >= swap 57 <= and ;

: is-number-token ( String -- Int )
  # Check if first char is a digit or minus followed by digit
  dup string-length 0 = if
    drop 0
  else
    dup 0 string-char-at
    dup 45 = if
      # Starts with minus - check if length > 1 and second char is digit
      drop dup string-length 1 > if
        1 string-char-at is-digit
      else
        drop 0
      then
    else
      is-digit nip
    then
  then
;

# ============================================
# Parse a single expression
# Returns (Sexpr, RemainingTokens)
# Stored as a 2-field variant
# ============================================

: make-parse-result ( Variant Variant -- Variant )
  201 make-variant-2 ;

: result-expr ( Variant -- Variant )
  0 variant-field-at ;

: result-tokens ( Variant -- Variant )
  1 variant-field-at ;

# ============================================
# Main Parser
# ============================================

: parse ( String -- Variant )
  tokenize parse-tokens result-expr ;

: parse-tokens ( Variant -- Variant )
  # Variant is a token list, returns parse result
  dup tnil? if
    # Empty token list - return nil expression
    snil slist swap make-parse-result
  else
    dup tcar
    dup is-lparen if
      # Start of list - parse list contents
      drop tcdr parse-list
    else
      dup is-rparen if
        # Unexpected ) - error, just skip
        drop tcdr parse-tokens
      else
        # Atom (number or symbol)
        dup is-number-token if
          string->int drop snum swap tcdr make-parse-result
        else
          ssym swap tcdr make-parse-result
        then
      then
    then
  then
;

# Parse list contents until )
: parse-list ( Variant -- Variant )
  # Input: token list after opening paren
  # Returns: (SList of elements, tokens after closing paren)
  snil swap parse-list-items
;

: parse-list-items ( Variant Variant -- Variant )
  # Stack: Acc Tokens (Tokens on top)
  dup tnil? if
    # Ran out of tokens - return accumulated list with empty token list
    drop list-reverse slist tnil make-parse-result
  else
    dup tcar is-rparen if
      # End of list - return accumulated list and tokens after )
      tcdr swap list-reverse slist swap make-parse-result
    else
      # Parse next element from Tokens
      dup parse-tokens
      # Stack: Acc Tokens ParseResult
      dup result-tokens
      # Stack: Acc Tokens ParseResult RemTokens
      swap result-expr
      # Stack: Acc Tokens RemTokens Expr
      rot drop
      # Stack: Acc RemTokens Expr
      rot
      # Stack: RemTokens Expr Acc
      scons
      # Stack: RemTokens NewAcc
      swap
      # Stack: NewAcc RemTokens
      parse-list-items
    then
  then
;

# Reverse a cons list
: list-reverse ( Variant -- Variant )
  snil list-reverse-loop ;

: list-reverse-loop ( Variant Variant -- Variant )
  swap dup snil? if drop else
    dup scar rot scons swap scdr swap list-reverse-loop
  then
;

# ============================================
# Debug
# ============================================

: print-parse ( String -- )
  parse sexpr-to-string write_line ;
