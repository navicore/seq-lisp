# Parser for SeqLisp
#
# Converts token list to s-expressions
# Uses ADT for parse result

include "sexpr"
include "tokenizer"

# ============================================
# Parse Result Type
# ============================================

union ParseResult {
  PResult { expr: Sexpr, remaining: TokenList }
}

# ============================================
# Parse Result Constructors and Accessors
# ============================================

: make-parse-result ( Sexpr TokenList -- ParseResult )
  Make-PResult ;

: result-expr ( ParseResult -- Sexpr )
  0 variant.field-at ;

: result-tokens ( ParseResult -- TokenList )
  1 variant.field-at ;

# ============================================
# Token Predicates
# ============================================

: is-lparen ( String -- Int )
  "(" string.equal? ;

: is-rparen ( String -- Int )
  ")" string.equal? ;

: is-quote ( String -- Int )
  "'" string.equal? ;

: is-quasiquote ( String -- Int )
  "`" string.equal? ;

: is-unquote ( String -- Int )
  "," string.equal? ;

: is-unquote-splice ( String -- Int )
  ",@" string.equal? ;

: is-digit ( Int -- Int )
  dup 48 >= swap 57 <= and ;

# Check if token is a string literal (starts with double quote)
: is-string-token ( String -- Int )
  dup string.length 0 = if
    drop 0
  else
    0 string.char-at 34 =  # char 34 is double quote
  then
;

# Check if char is a decimal point
: is-dot ( Int -- Int )
  46 = ;  # char 46 is '.'

# Check if token contains a decimal point (for float detection)
: has-decimal-point ( String -- Int )
  0 has-decimal-loop ;

: has-decimal-loop ( String Int -- Int )
  # Stack: str pos
  over string.length over <= if
    drop drop 0  # Reached end, no decimal found
  else
    2dup string.char-at is-dot if
      drop drop 1  # Found decimal
    else
      1 add has-decimal-loop  # Check next char
    then
  then
;

# Check if token is a float (number with decimal point)
: is-float-token ( String -- Int )
  dup is-number-start? if
    has-decimal-point
  else
    drop 0
  then
;

# Check if token starts like a number (digit or minus-digit)
: is-number-start? ( String -- Int )
  dup string.length 0 = if
    drop 0
  else
    dup 0 string.char-at
    dup 45 = if
      # Starts with minus - check if length > 1 and second char is digit
      drop dup string.length 1 > if
        1 string.char-at is-digit
      else
        drop 0
      then
    else
      is-digit nip
    then
  then
;

: is-number-token ( String -- Int )
  # Check if first char is a digit or minus followed by digit
  # and does NOT contain a decimal point (integers only)
  dup is-number-start? if
    has-decimal-point 0 =  # True if no decimal point
  else
    drop 0
  then
;

# ============================================
# Main Parser
# ============================================

: parse ( String -- Sexpr )
  tokenize parse-tokens result-expr ;

: parse-tokens ( TokenList -- ParseResult )
  # TokenList is a token list, returns parse result
  dup tnil? if
    # Empty token list - return nil expression
    snil slist swap make-parse-result
  else
    dup tcar
    dup is-lparen if
      # Start of list - parse list contents
      drop tcdr parse-list
    else
      dup is-rparen if
        # Unexpected ) - error, just skip
        drop tcdr parse-tokens
      else
        dup is-quote if
          # Quote: 'expr -> (quote expr)
          drop tcdr parse-quote
        else
          dup is-quasiquote if
            # Quasiquote: `expr -> (quasiquote expr)
            drop tcdr parse-quasiquote
          else
            dup is-unquote-splice if
              # Unquote-splice: ,@expr -> (unquote-splicing expr)
              drop tcdr parse-unquote-splice
            else
              dup is-unquote if
                # Unquote: ,expr -> (unquote expr)
                drop tcdr parse-unquote
              else
                # Atom (string, float, number, or symbol)
                dup is-string-token if
                  # String literal - strip quotes and create SString
                  # Stack: tokens str
                  dup string.length 2 subtract  # tokens str content-len
                  swap                          # tokens content-len str
                  1                             # tokens content-len str 1
                  rot                           # tokens str 1 content-len
                  string.substring              # tokens content
                  sstring swap tcdr make-parse-result
                else
                  dup is-float-token if
                    string->float drop sfloat swap tcdr make-parse-result
                  else
                    dup is-number-token if
                      string->int drop snum swap tcdr make-parse-result
                    else
                      ssym swap tcdr make-parse-result
                    then
                  then
                then
              then
            then
          then
        then
      then
    then
  then
;

# Parse quote: expand 'expr to (quote expr)
: parse-quote ( TokenList -- ParseResult )
  # Parse the next expression
  parse-tokens
  # Stack: ParseResult
  dup result-expr   # ParseResult Expr
  swap result-tokens  # Expr RemTokens
  # Build (quote expr) -> SList of (SSym "quote", expr)
  swap snil scons  # RemTokens (expr)
  "quote" ssym swap scons  # RemTokens (quote expr)
  slist  # RemTokens SList
  swap make-parse-result
;

# Parse quasiquote: expand `expr to (quasiquote expr)
: parse-quasiquote ( TokenList -- ParseResult )
  parse-tokens
  dup result-expr
  swap result-tokens
  swap snil scons
  "quasiquote" ssym swap scons
  slist
  swap make-parse-result
;

# Parse unquote: expand ,expr to (unquote expr)
: parse-unquote ( TokenList -- ParseResult )
  parse-tokens
  dup result-expr
  swap result-tokens
  swap snil scons
  "unquote" ssym swap scons
  slist
  swap make-parse-result
;

# Parse unquote-splice: expand ,@expr to (unquote-splicing expr)
: parse-unquote-splice ( TokenList -- ParseResult )
  parse-tokens
  dup result-expr
  swap result-tokens
  swap snil scons
  "unquote-splicing" ssym swap scons
  slist
  swap make-parse-result
;

# Parse list contents until )
: parse-list ( TokenList -- ParseResult )
  # Input: token list after opening paren
  # Returns: (SList of elements, tokens after closing paren)
  snil swap parse-list-items
;

: parse-list-items ( SexprList TokenList -- ParseResult )
  # Stack: Acc Tokens (Tokens on top)
  dup tnil? if
    # Ran out of tokens - return accumulated list with empty token list
    drop list-reverse slist tnil make-parse-result
  else
    dup tcar is-rparen if
      # End of list - return accumulated list and tokens after )
      tcdr swap list-reverse slist swap make-parse-result
    else
      # Parse next element from Tokens
      dup parse-tokens
      # Stack: Acc Tokens ParseResult
      dup result-tokens
      # Stack: Acc Tokens ParseResult RemTokens
      swap result-expr
      # Stack: Acc Tokens RemTokens Expr
      rot drop
      # Stack: Acc RemTokens Expr
      rot
      # Stack: RemTokens Expr Acc
      scons
      # Stack: RemTokens NewAcc
      swap
      # Stack: NewAcc RemTokens
      parse-list-items
    then
  then
;

# Reverse a cons list
: list-reverse ( SexprList -- SexprList )
  snil list-reverse-loop ;

: list-reverse-loop ( SexprList SexprList -- SexprList )
  swap dup snil? if drop else
    dup scar rot scons swap scdr swap list-reverse-loop
  then
;

# ============================================
# Debug
# ============================================

: print-parse ( String -- )
  parse sexpr-to-string io.write-line ;
