# Test evaluator

include "eval"

: main ( -- )
  "Testing evaluator:" write_line

  # Simple numbers
  "42" eval-print

  # Addition
  "(+ 1 2)" eval-print
  "(+ 1 2 3 4 5)" eval-print

  # Subtraction
  "(- 10 3)" eval-print
  "(- 5)" eval-print

  # Multiplication
  "(* 3 4)" eval-print
  "(* 2 3 4)" eval-print

  # Division
  "(/ 10 2)" eval-print
  "(/ 100 2 5)" eval-print

  # Nested expressions
  "(+ 1 (* 2 3))" eval-print
  "(* (+ 1 2) (- 10 5))" eval-print

  # Conditionals
  "(if 1 42 0)" eval-print
  "(if 0 42 99)" eval-print

  # Let bindings
  "(let x 10 x)" eval-print
  "(let x 5 (+ x 3))" eval-print
  "(let a 10 (let b 20 (+ a b)))" eval-print

  # Lambda
  "((lambda (x) x) 42)" eval-print
  "((lambda (x) (+ x 1)) 5)" eval-print
  "((lambda (x) (* x x)) 7)" eval-print

  # Closure capturing environment
  "(let y 10 ((lambda (x) (+ x y)) 5))" eval-print

  # Quote - returns unevaluated
  "'x" eval-print
  "'(1 2 3)" eval-print
  "(quote (+ 1 2))" eval-print

  # List operations
  "(list 1 2 3)" eval-print
  "(list (+ 1 2) (* 3 4))" eval-print
  "(car '(1 2 3))" eval-print
  "(cdr '(1 2 3))" eval-print
  "(cons 1 '(2 3))" eval-print
  "(cons 'a '())" eval-print
  "(car (cdr '(1 2 3)))" eval-print

  # Predicates
  "(null? '())" eval-print
  "(null? '(1 2))" eval-print
  "(number? 42)" eval-print
  "(number? 'x)" eval-print
  "(symbol? 'x)" eval-print
  "(symbol? 42)" eval-print
  "(list? '(1 2 3))" eval-print
  "(list? 42)" eval-print
  "(number? (+ 1 2))" eval-print
  "(list? (list 1 2))" eval-print
;
