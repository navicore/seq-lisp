# SeqLisp - A Lisp interpreter written in Seq
#
# Usage:
#   ./seqlisp              - Interactive REPL (multi-line, Ctrl+D to exit)
#   ./seqlisp file.lisp    - Run a file
#   ./seqlisp --version    - Print version
#   ./seqlisp --help       - Print help
#   echo "(+ 1 2)" | ./seqlisp - Piped input
#
# REPL features:
#   - Line editing with arrow keys (via libedit)
#   - Command history (up/down arrows)
#   - Persistent history saved to ~/.seqlisp_history
#   - Multi-line input (detects incomplete expressions)
#   - Continuation prompt (...) for multi-line
#   - Environment persists across expressions
#   - Error recovery (REPL continues after errors)
#
# Build: seqc src/repl.seq -o seqlisp

include "eval"
include "version"
include ffi:libedit

# ============================================
# File Mode - Read file, parse all, evaluate
# ============================================

# Parse all expressions from token list
: parse-all ( TokenList -- SexprList )
    snil parse-all-loop list-reverse
;

: parse-all-loop ( TokenList SexprList -- SexprList )
    # Stack: Tokens Exprs
    over tnil? if
        nip  # No more tokens, return expressions
    else
        swap parse-tokens  # -> Exprs ParseResult
        dup result-expr swap result-tokens  # -> Exprs Expr RemainingTokens
        rot rot swap scons  # -> RemainingTokens NewExprs
        parse-all-loop
    then
;

# Evaluate all expressions with persistent environment (no output)
: eval-all-quiet ( SexprList Env -- Env )
    # Stack: Exprs Env -> FinalEnv
    swap dup snil? if
        drop  # Return env
    else
        dup scar 2 pick eval-with-env
        dup eval-define? if
            dup eval-define-name swap eval-define-value
            3 pick env-extend
            rot drop swap scdr swap
            eval-all-quiet
        else
            dup eval-err? if
                # Print error but continue
                format-eval-error io.write-line
                scdr swap
                eval-all-quiet
            else
                # EvalOk - drop result
                drop scdr swap
                eval-all-quiet
            then
        then
    then
;

# Evaluate all expressions, print non-trivial results
: eval-all-print ( SexprList Env -- Env )
    # Stack: Exprs Env -> FinalEnv
    swap dup snil? if
        drop  # Return env
    else
        dup scar 2 pick eval-with-env
        dup eval-define? if
            dup eval-define-name swap eval-define-value
            3 pick env-extend
            rot drop swap scdr swap
            eval-all-print
        else
            dup eval-err? if
                # Print error and continue
                format-eval-error io.write-line
                scdr swap
                eval-all-print
            else
                # EvalOk result - unwrap and print if not empty list
                eval-ok-value
                dup variant.tag :SList symbol.= if
                    dup slist-val snil? if
                        drop
                    else
                        sexpr-to-string io.write-line
                    then
                else
                    sexpr-to-string io.write-line
                then
                scdr swap
                eval-all-print
            then
        then
    then
;

# Run a file
: run-file ( String -- )
    file.slurp drop tokenize parse-all
    env-empty eval-all-print drop
;

# ============================================
# Paren Balancing for Multi-line Input
# ============================================

# Count paren balance in a string: returns (opens - closes)
# Positive = need more closing parens, Negative = too many closes, Zero = balanced
: paren-balance ( String -- Int )
    0 swap 0 paren-balance-loop ;

: paren-balance-loop ( Int String Int -- Int )
    # Stack: Balance Str Pos
    # Check if Pos >= Length (done)
    dup 2 pick string.length i.>= if
        # End of string - return Balance
        drop drop  # Drop Str Pos, leave Balance
    else
        # Get char at pos
        over over string.char-at
        dup 40 i.= if      # '('
            drop rot 1 i.add rot rot 1 i.add paren-balance-loop
        else
            dup 41 i.= if  # ')'
                drop rot 1 i.subtract rot rot 1 i.add paren-balance-loop
            else
                # Skip other chars
                drop 1 i.add paren-balance-loop
            then
        then
    then ;

# Check if input has content (non-whitespace, non-comment)
# Returns true if there's non-whitespace before any comment, false otherwise
: has-content ( String -- Bool )
    false swap 0 has-content-loop ;

: has-content-loop ( Bool String Int -- Bool )
    # Stack: Found Str Pos
    # Check if Pos >= Length (done)
    dup 2 pick string.length i.>= if
        # End of string - return Found
        drop drop  # Drop Str Pos, leave Found
    else
        over over string.char-at
        # Stack: Found Str Pos CharCode
        dup 59 i.= if  # ';' - comment starts, stop scanning
            # Return what we've found so far (false if nothing before comment)
            drop drop drop
        else
            dup 32 i.> if  # Non-whitespace - found content
                drop drop drop drop true
            else
                # Whitespace - continue searching
                drop 1 i.add has-content-loop
            then
        then
    then ;

# ============================================
# Interactive REPL Mode
# ============================================

# History file path - uses os.home-dir to get user's home directory
: history-file ( -- String )
    os.home-dir if
        "/.seqlisp_history" string.concat
    else
        drop "/tmp/.seqlisp_history"  # Fallback if os.home-dir fails
    then ;

# Get prompt string based on whether we're continuing a multi-line expression
: get-prompt ( Int -- String )
    0 i.= if
        "> "
    else
        "... "
    then ;

# Handle EOF in REPL
: repl-handle-eof ( String Env -- )
    # Stack: Acc Env
    over has-content if
        over paren-balance 0 i.= if
            # Balanced - evaluate remaining
            swap tokenize parse-all
            swap eval-all-print drop
            "Goodbye!" io.write-line
        else
            # Unbalanced at EOF
            drop drop "Error: unbalanced parentheses" io.write-line
        then
    else
        drop drop "Goodbye!" io.write-line
    then ;

# Handle a line of input
: repl-handle-line ( String Env String -- )
    # Stack: Acc Env Line
    # Build: Acc + Line (Acc already has newlines from previous lines)
    rot swap string.concat
    # Stack: Env NewAcc
    swap
    # Stack: NewAcc Env
    over paren-balance
    # Stack: NewAcc Env Balance
    dup 0 i.< if
        # Negative balance - too many closing parens
        drop "Error: unexpected ')'" io.write-line
        drop "" swap repl-loop
    else
        0 i.=
        # Stack: NewAcc Env BalancedBool
        2 pick has-content
        # Stack: NewAcc Env BalancedBool HasContentBool
        and if
            # Balanced and has content - i.add to history and evaluate
            over add-history
            swap tokenize parse-all
            swap eval-all-print
            "" swap repl-loop
        else
            # Need more input (positive balance or no content yet)
            repl-loop
        then
    then ;

# Interactive REPL loop with multi-line support
: repl-loop ( String Env -- )
    # Stack: Accumulator Env
    over paren-balance get-prompt readline
    dup string.empty? if
        # EOF (Ctrl+D or empty input)
        drop repl-handle-eof
    else
        # Got a line - i.add newline since readline strips it
        "\n" string.concat
        repl-handle-line
    then ;

# Start interactive REPL
: run-repl ( -- )
    # Load history from previous sessions (ignore error if file doesn't exist)
    history-file read-history drop
    "" env-empty repl-loop
    # Save history for next session
    history-file write-history drop ;

# ============================================
# Stdin Mode - Read all lines, then evaluate (for piped input)
# ============================================

# Read all lines until EOF (preserves newlines for comments and line tracking)
: read-all-stdin ( String -- String )
    io.read-line+
    0 i.= if
        # EOF reached
        drop
    else
        # Got a line - append newline since io.read-line+ strips it
        "\n" string.concat
        string.concat
        read-all-stdin
    then
;

# Run from stdin (non-interactive, for piped input)
: run-stdin ( -- )
    "" read-all-stdin
    dup string.empty? if
        drop
    else
        tokenize parse-all
        env-empty eval-all-print drop
    then ;

# ============================================
# Main Entry Point
# ============================================

# Check if argument is a version flag
: is-version-flag ( String -- Bool )
    dup "--version" string.equal? if
        drop true
    else
        "-v" string.equal?
    then
;

# Check if argument is a help flag
: is-help-flag ( String -- Bool )
    dup "--help" string.equal? if
        drop true
    else
        "-h" string.equal?
    then
;

# Check if argument is LSP flag
: is-lsp-flag ( String -- Bool )
    "--lsp" string.equal?
;

# Print version information
: print-version ( -- )
    "seqlisp " seqlisp-version string.concat io.write-line
;

# Print help information
: print-help ( -- )
    "SeqLisp - A Lisp interpreter" io.write-line
    "" io.write-line
    "Usage:" io.write-line
    "  seqlisp              Interactive REPL" io.write-line
    "  seqlisp <file>       Run a Lisp file" io.write-line
    "  seqlisp --lsp        Run as Language Server" io.write-line
    "  seqlisp --version    Show version" io.write-line
    "  seqlisp --help       Show this help" io.write-line
    "" io.write-line
    "Examples:" io.write-line
    "  seqlisp examples/factorial.lisp" io.write-line
    "  echo '(+ 1 2)' | seqlisp" io.write-line
;

# Run a file safely (handle missing files)
: run-file-safe ( String -- )
    dup file.exists? if
        file.slurp if
            # Stack: Content (success)
            tokenize parse-all
            env-empty eval-all-print drop
        else
            drop  # Drop empty/error content
            "Error: Cannot read file" io.write-line
        then
    else
        "Error: Cannot read file '" swap string.concat "'" string.concat io.write-line
    then
;

# Run LSP server (load lib/lsp.slisp)
: run-lsp ( -- )
    "lib/lsp.slisp" file.exists? if
        "lib/lsp.slisp" file.slurp if
            tokenize parse-all
            env-empty eval-all-quiet drop
        else
            drop "Error: Cannot read lib/lsp.slisp" io.write-line
        then
    else
        "Error: Cannot find lib/lsp.slisp" io.write-line
    then
;

: main ( -- )
    args.count 1 i.> if
        1 args.at
        dup is-version-flag if
            drop print-version
        else
            dup is-help-flag if
                drop print-help
            else
                dup is-lsp-flag if
                    drop run-lsp
                else
                    run-file-safe
                then
            then
        then
    else
        "SeqLisp " seqlisp-version string.concat io.write-line
        run-repl
    then
;
