# SeqLisp - A Lisp interpreter written in Seq
#
# Usage:
#   ./seqlisp              - Interactive REPL (multi-line, Ctrl+D to exit)
#   ./seqlisp file.lisp    - Run a file
#   ./seqlisp --version    - Print version
#   echo "(+ 1 2)" | ./seqlisp - Piped input
#
# REPL features:
#   - Multi-line input (detects incomplete expressions)
#   - Continuation prompt (...) for multi-line
#   - Environment persists across expressions
#   - Error recovery (REPL continues after errors)
#
# Build: seqc src/repl.seq -o seqlisp

include "eval"
include "version"

# ============================================
# File Mode - Read file, parse all, evaluate
# ============================================

# Parse all expressions from token list
: parse-all ( TokenList -- SexprList )
    snil parse-all-loop list-reverse
;

: parse-all-loop ( TokenList SexprList -- SexprList )
    # Stack: Tokens Exprs
    over tnil? if
        nip  # No more tokens, return expressions
    else
        swap parse-tokens  # -> Exprs ParseResult
        dup result-expr swap result-tokens  # -> Exprs Expr RemainingTokens
        rot rot swap scons  # -> RemainingTokens NewExprs
        parse-all-loop
    then
;

# Evaluate all expressions with persistent environment (no output)
: eval-all-quiet ( SexprList Env -- Env )
    # Stack: Exprs Env -> FinalEnv
    swap dup snil? if
        drop  # Return env
    else
        dup scar 2 pick eval-with-env
        dup define-result? if
            dup define-result-name swap define-result-value
            3 pick env-extend
            rot drop swap scdr swap
            eval-all-quiet
        else
            dup error-result? if
                # Print error but continue
                "Error: " swap error-result-message string-concat write_line
                scdr swap
                eval-all-quiet
            else
                drop scdr swap
                eval-all-quiet
            then
        then
    then
;

# Evaluate all expressions, print non-trivial results
: eval-all-print ( SexprList Env -- Env )
    # Stack: Exprs Env -> FinalEnv
    swap dup snil? if
        drop  # Return env
    else
        dup scar 2 pick eval-with-env
        dup define-result? if
            dup define-result-name swap define-result-value
            3 pick env-extend
            rot drop swap scdr swap
            eval-all-print
        else
            dup error-result? if
                # Print error and continue
                "Error: " swap error-result-message string-concat write_line
                scdr swap
                eval-all-print
            else
                # Normal Sexpr result - print if not empty list
                dup variant-tag 2 = if
                    dup slist-val snil? if
                        drop
                    else
                        sexpr-to-string write_line
                    then
                else
                    sexpr-to-string write_line
                then
                scdr swap
                eval-all-print
            then
        then
    then
;

# Run a file
: run-file ( String -- )
    file-slurp tokenize parse-all
    env-empty eval-all-print drop
;

# ============================================
# Paren Balancing for Multi-line Input
# ============================================

# Count paren balance in a string: returns (opens - closes)
# Positive = need more closing parens, Negative = too many closes, Zero = balanced
: paren-balance ( String -- Int )
    0 swap 0 paren-balance-loop ;

: paren-balance-loop ( Int String Int -- Int )
    # Stack: Balance Str Pos
    # Check if Pos >= Length (done)
    dup 2 pick string-length >= if
        # End of string - return Balance
        drop drop  # Drop Str Pos, leave Balance
    else
        # Get char at pos
        over over string-char-at
        dup 40 = if      # '('
            drop rot 1 add rot rot 1 add paren-balance-loop
        else
            dup 41 = if  # ')'
                drop rot 1 subtract rot rot 1 add paren-balance-loop
            else
                # Skip other chars
                drop 1 add paren-balance-loop
            then
        then
    then ;

# Check if input has content (non-whitespace, non-comment)
# Returns 1 if there's non-whitespace before any comment, 0 otherwise
: has-content ( String -- Int )
    0 swap 0 has-content-loop ;

: has-content-loop ( Int String Int -- Int )
    # Stack: Found Str Pos
    # Check if Pos >= Length (done)
    dup 2 pick string-length >= if
        # End of string - return Found
        drop drop  # Drop Str Pos, leave Found
    else
        over over string-char-at
        # Stack: Found Str Pos CharCode
        dup 59 = if  # ';' - comment starts, stop scanning
            # Return what we've found so far (0 if nothing before comment)
            drop drop drop
        else
            dup 32 > if  # Non-whitespace - found content
                drop drop drop drop 1
            else
                # Whitespace - continue searching
                drop 1 add has-content-loop
            then
        then
    then ;

# ============================================
# Interactive REPL Mode
# ============================================

# Print prompt based on whether we're continuing a multi-line expression
# Note: write_line adds newline, so prompt appears on its own line
: print-prompt ( Int -- )
    0 = if
        ">" write_line
    else
        "..." write_line
    then ;

# Handle EOF in REPL
: repl-handle-eof ( String Env -- )
    # Stack: Acc Env
    over has-content if
        over paren-balance 0 = if
            # Balanced - evaluate remaining
            swap tokenize parse-all
            swap eval-all-print drop
            "Goodbye!" write_line
        else
            # Unbalanced at EOF
            drop drop "Error: unbalanced parentheses" write_line
        then
    else
        drop drop "Goodbye!" write_line
    then ;

# Handle a line of input
: repl-handle-line ( String Env String -- )
    # Stack: Acc Env Line
    # Build: Acc + Line (Acc already has newlines from previous lines)
    rot swap string-concat
    # Stack: Env NewAcc
    swap
    # Stack: NewAcc Env
    over paren-balance
    # Stack: NewAcc Env Balance
    dup 0 < if
        # Negative balance - too many closing parens
        drop "Error: unexpected ')'" write_line
        drop "" swap repl-loop
    else
        0 =
        # Stack: NewAcc Env BalancedBool
        2 pick has-content
        # Stack: NewAcc Env BalancedBool HasContentBool
        and if
            # Balanced and has content - evaluate
            swap tokenize parse-all
            swap eval-all-print
            "" swap repl-loop
        else
            # Need more input (positive balance or no content yet)
            repl-loop
        then
    then ;

# Interactive REPL loop with multi-line support
: repl-loop ( String Env -- )
    # Stack: Accumulator Env
    over paren-balance print-prompt
    read_line+
    0 = if
        # EOF
        drop repl-handle-eof
    else
        # Got a line
        repl-handle-line
    then ;

# Start interactive REPL
: run-repl ( -- )
    "" env-empty repl-loop ;

# ============================================
# Stdin Mode - Read all lines, then evaluate (for piped input)
# ============================================

# Read all lines until EOF (preserves newlines for comments)
: read-all-stdin ( String -- String )
    read_line+
    0 = if
        # EOF reached
        drop
    else
        # Got a line - append to accumulator (keep newline for comments)
        string-concat
        read-all-stdin
    then
;

# Run from stdin (non-interactive, for piped input)
: run-stdin ( -- )
    "" read-all-stdin
    dup string-empty if
        drop
    else
        tokenize parse-all
        env-empty eval-all-print drop
    then ;

# ============================================
# Main Entry Point
# ============================================

# Check if argument is a version flag
: is-version-flag ( String -- Int )
    dup "--version" string-equal if
        drop 1
    else
        "-v" string-equal
    then
;

# Print version information
: print-version ( -- )
    "seqlisp " seqlisp-version string-concat write_line
;

: main ( -- )
    arg-count 1 > if
        1 arg dup is-version-flag if
            drop print-version
        else
            run-file
        then
    else
        "SeqLisp " seqlisp-version string-concat write_line
        run-repl
    then
;
