# Minimal reproduction: Type checker bug with `n roll` inside if/else
#
# Bug: When `n roll` is used inside an if/else branch, the type checker
# incorrectly includes the numeric parameter `n` in the resulting stack type,
# reporting an extra "roll_input" or "roll_rest" item.
#
# Expected: Both branches should have the same stack effect since roll
# doesn't change stack depth (it only rotates existing items).
#
# seqc version: 0.9.0 (or current version)

# CASE 1: 3 roll outside conditional - WORKS
: works-outside ( Int Int Int Int -- Int Int Int Int )
  3 roll ;

# CASE 2: 3 roll inside else branch - FAILS
# Error: else branch produces extra "roll_input$N" item
: fails-inside ( Int Int Int Int -- Int Int Int Int )
  dup 0 = if
    # then branch: no-op (stack unchanged)
  else
    # else branch: 3 roll (same stack depth, different order)
    3 roll
  then ;

# CASE 3: rot inside else branch - WORKS
# rot is semantically equivalent to 3 roll but is a primitive
: works-rot ( Int Int Int -- Int Int Int )
  dup 0 = if
  else
    rot  # Works! rot is a primitive, not parameterized
  then ;

: main ( -- )
  1 2 3 4 works-outside drop drop drop drop
  "If you see this, the bug may be fixed" io.write-line ;

# Expected error when compiling:
#
# Error: if/else branches have incompatible stack effects:
#   then branch produces: (..rest Int Int Int Int)
#   else branch produces: (..rest Int Int Int Int roll_input$N)
